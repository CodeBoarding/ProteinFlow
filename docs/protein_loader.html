<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>proteinflow.protein_loader API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="shortcut icon" type="image/x-icon" href="favicon.png?">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>proteinflow.protein_loader</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
import numpy as np
import torch
from torch.utils.data import DataLoader
from proteinflow.constants import CDR

from proteinflow.protein_dataset import ProteinDataset


class _PadCollate:
    &#34;&#34;&#34;
    A variant of `collate_fn` that pads according to the longest sequence in
    a batch of sequences

    If `mask_residues` is `True`, an additional `&#39;masked_res&#39;` key is added to the output. The value is a binary
    tensor where 1 denotes the part that needs to be predicted and 0 is everything else. The tensors are generated
    according to the following rules:
    - if `mask_whole_chains` is `True`, the whole chain is masked
    - if `mask_frac` is given, the number of residues to mask is `mask_frac` times the length of the chain,
    - otherwise, the number of residues to mask is sampled uniformly from the range [`lower_limit`, `upper_limit`].

    If `force_binding_sites_frac` &gt; 0 and `mask_whole_chains` is `False`, in the fraction of cases where a chain
    from a polymer is sampled, the center of the masked region will be forced to be in a binding site.
    &#34;&#34;&#34;

    def __init__(
        self,
        mask_residues=True,
        lower_limit=15,
        upper_limit=100,
        mask_frac=None,
        mask_whole_chains=False,
        force_binding_sites_frac=0.15,
        mask_all_cdrs=False,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        batch : dict
            a batch generated by `ProteinDataset` and `PadCollate`
        lower_limit : int, default 15
            the minimum number of residues to mask
        upper_limit : int, default 100
            the maximum number of residues to mask
        mask_frac : float, optional
            if given, the `lower_limit` and `upper_limit` are ignored and the number of residues to mask is `mask_frac` times the length of the chain
        mask_whole_chains : bool, default False
            if `True`, `upper_limit`, `force_binding_sites` and `lower_limit` are ignored and the whole chain is masked instead
        force_binding_sites_frac : float, default 0.15
            if &gt; 0, in the fraction of cases where a chain from a polymer is sampled, the center of the masked region will be
            forced to be in a binding site
        mask_all_cdrs : bool, default False
            if `True`, all CDRs are masked

        Returns
        -------
        chain_M : torch.Tensor
            a `(B, L)` shaped binary tensor where 1 denotes the part that needs to be predicted and
            0 is everything else
        &#34;&#34;&#34;

        super().__init__()
        self.mask_residues = mask_residues
        self.lower_limit = lower_limit
        self.upper_limit = upper_limit
        self.mask_frac = mask_frac
        self.mask_whole_chains = mask_whole_chains
        self.force_binding_sites_frac = force_binding_sites_frac
        self.mask_all_cdrs = mask_all_cdrs

    def _get_masked_sequence(
        self,
        batch,
    ):
        &#34;&#34;&#34;
        Get the mask for the residues that need to be predicted

        Depending on the parameters the residues are selected as follows:
        - if `mask_whole_chains` is `True`, the whole chain is masked
        - if `mask_frac` is given, the number of residues to mask is `mask_frac` times the length of the chain,
        - otherwise, the number of residues to mask is sampled uniformly from the range [`lower_limit`, `upper_limit`].

        If `force_binding_sites_frac` &gt; 0 and `mask_whole_chains` is `False`, in the fraction of cases where a chain
        from a polymer is sampled, the center of the masked region will be forced to be in a binding site.

        Parameters
        ----------
        batch : dict
            a batch generated by `ProteinDataset` and `PadCollate`

        Returns
        -------
        chain_M : torch.Tensor
            a `(B, L)` shaped binary tensor where 1 denotes the part that needs to be predicted and
            0 is everything else
        &#34;&#34;&#34;

        if &#34;cdr&#34; in batch and &#34;cdr_id&#34; in batch:
            chain_M = torch.zeros_like(batch[&#34;cdr&#34;])
            for i, cdr_arr in enumerate(batch[&#34;cdr&#34;]):
                if self.mask_all_cdrs:
                    chain_M[i] = cdr_arr != CDR[&#34;-&#34;]
                else:
                    chain_M[i] = cdr_arr == batch[&#34;cdr_id&#34;][i]
        else:
            chain_M = torch.zeros(batch[&#34;S&#34;].shape)
            for i, coords in enumerate(batch[&#34;X&#34;]):
                chain_index = batch[&#34;chain_id&#34;][i]
                chain_bool = batch[&#34;chain_encoding_all&#34;][i] == chain_index

                if self.mask_whole_chains:
                    chain_M[i, chain_bool] = 1
                else:
                    chains = torch.unique(batch[&#34;chain_encoding_all&#34;][i])
                    chain_start = torch.where(chain_bool)[0][0]
                    chain = coords[chain_bool]
                    res_i = None
                    interface = []
                    non_masked_interface = []
                    if len(chains) &gt; 1 and self.force_binding_sites_frac &gt; 0:
                        if random.uniform(0, 1) &lt;= self.force_binding_sites_frac:
                            X_copy = coords

                            i_indices = (chain_bool == 0).nonzero().flatten()
                            j_indices = chain_bool.nonzero().flatten()

                            distances = torch.norm(
                                X_copy[i_indices, 2, :]
                                - X_copy[j_indices, 2, :].unsqueeze(1),
                                dim=-1,
                            ).cpu()
                            close_idx = (
                                np.where(torch.min(distances, dim=1)[0] &lt;= 10)[0]
                                + chain_start.item()
                            )

                            no_mask_idx = np.where(batch[&#34;mask&#34;][i][chain_bool])[0]
                            interface = np.intersect1d(close_idx, j_indices)

                            not_end_mask = np.where(
                                ((X_copy[:, 2, :].cpu() == 0).sum(-1) != 3)
                            )[0]
                            interface = np.intersect1d(interface, not_end_mask)

                            non_masked_interface = np.intersect1d(
                                interface, no_mask_idx
                            )
                            interpolate = True
                            if len(non_masked_interface) &gt; 0:
                                res_i = non_masked_interface[
                                    random.randint(0, len(non_masked_interface) - 1)
                                ]
                            elif len(interface) &gt; 0 and interpolate:
                                res_i = interface[random.randint(0, len(interface) - 1)]
                            else:
                                res_i = no_mask_idx[
                                    random.randint(0, len(no_mask_idx) - 1)
                                ]
                    if res_i is None:
                        non_zero = torch.where(batch[&#34;mask&#34;][i][chain_bool])[0]
                        res_i = non_zero[random.randint(0, len(non_zero) - 1)]
                    res_coords = coords[res_i, 2, :]
                    neighbor_indices = torch.where(batch[&#34;mask&#34;][i][chain_bool])[0]
                    if self.mask_frac is not None:
                        assert self.mask_frac &gt; 0 and self.mask_frac &lt; 1
                        k = int(len(neighbor_indices) * self.mask_frac)
                        k = max(k, 10)
                    else:
                        up = min(
                            self.upper_limit, int(len(neighbor_indices) * 0.5)
                        )  # do not mask more than half of the sequence
                        low = min(up - 1, self.lower_limit)
                        k = random.choice(range(low, up))
                    dist = torch.norm(
                        chain[neighbor_indices, 2, :] - res_coords.unsqueeze(0), dim=-1
                    )
                    closest_indices = neighbor_indices[
                        torch.topk(dist, k, largest=False)[1]
                    ]
                    chain_M[i, closest_indices + chain_start] = 1
        return chain_M

    def pad_collate(self, batch):
        # find longest sequence
        out = {}
        max_len = max(map(lambda x: x[&#34;S&#34;].shape[0], batch))

        # pad according to max_len
        to_pad = [max_len - b[&#34;S&#34;].shape[0] for b in batch]
        for key in batch[0].keys():
            if key in [&#34;chain_id&#34;, &#34;chain_dict&#34;, &#34;pdb_id&#34;, &#34;cdr_id&#34;]:
                continue
            out[key] = torch.stack(
                [
                    torch.cat([b[key], torch.zeros((pad, *b[key].shape[1:]))], 0)
                    for b, pad in zip(batch, to_pad)
                ],
                0,
            )
        out[&#34;chain_id&#34;] = torch.tensor([b[&#34;chain_id&#34;] for b in batch])
        if &#34;cdr_id&#34; in batch[0]:
            out[&#34;cdr_id&#34;] = torch.tensor([b[&#34;cdr_id&#34;] for b in batch])
        out[&#34;masked_res&#34;] = self._get_masked_sequence(out)
        out[&#34;chain_dict&#34;] = [b[&#34;chain_dict&#34;] for b in batch]
        out[&#34;pdb_id&#34;] = [b[&#34;pdb_id&#34;] for b in batch]
        return out

    def __call__(self, batch):
        return self.pad_collate(batch)


class ProteinLoader(DataLoader):
    &#34;&#34;&#34;
    A subclass of `torch.data.utils.DataLoader` tuned for the `proteinflow` dataset

    Creates and iterates over an instance of `ProteinDataset`, omitting the `&#39;chain_dict&#39;` keys.
    See the `ProteinDataset` documentation for more information.

    If batch size is larger than one, all objects are padded with zeros at the ends to reach the length of the
    longest protein in the batch.

    If `mask_residues` is `True`, an additional `&#39;masked_res&#39;` key is added to the output. The value is a binary
    tensor shaped `(B, L)` where 1 denotes the part that needs to be predicted and 0 is everything else. The tensors are generated
    according to the following rulesd:
    - if the dataset is generated from SAbDab files, the sampled CDR is masked,
    - if `mask_whole_chains` is `True`, the whole chain is masked,
    - if `mask_frac` is given, the number of residues to mask is `mask_frac` times the length of the chain,
    - otherwise, the number of residues to mask is sampled uniformly from the range [`lower_limit`, `upper_limit`].

    If `force_binding_sites_frac` &gt; 0 and `mask_whole_chains` is `False`, in the fraction of cases where a chain
    from a polymer is sampled, the center of the masked region will be forced to be in a binding site (in PDB datasets).
    &#34;&#34;&#34;

    def __init__(
        self,
        dataset,
        lower_limit=15,
        upper_limit=100,
        mask_residues=True,
        mask_whole_chains=False,
        mask_frac=None,
        collate_func=_PadCollate,
        force_binding_sites_frac=0,
        shuffle_batches=True,
        mask_all_cdrs=False,
        *args,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        dataset : ProteinDataset
            a ProteinDataset instance
        lower_limit : int, default 15
            the minimum number of residues to mask
        upper_limit : int, default 100
            the maximum number of residues to mask
        mask_frac : float, optional
            if given, the `lower_limit` and `upper_limit` are ignored and the number of residues to mask is `mask_frac` times the length of the chain
        mask_whole_chains : bool, default False
            if `True`, `upper_limit`, `force_binding_sites` and `lower_limit` are ignored and the whole chain is masked instead
        force_binding_sites_frac : float, default 0
            if &gt; 0, in the fraction of cases where a chain from a polymer is sampled, the center of the masked region will be
            forced to be in a binding site
        shuffle_clusters : bool, default True
            if `True`, a new representative is randomly selected for each cluster at each epoch (if `clustering_dict_path` is given)
        shuffle_batches : bool, default True
            if `True`, the batches are shuffled at each epoch
        mask_all_cdrs : bool, default False
            if `True`, all CDRs are masked instead of just the sampled one
        collate_func : callable, optional
            a function that takes a list of samples and returns a batch and inherits from _PadCollate
        &#34;&#34;&#34;

        super().__init__(
            dataset,
            collate_fn=collate_func(
                mask_residues=mask_residues,
                mask_whole_chains=mask_whole_chains,
                mask_frac=mask_frac,
                lower_limit=lower_limit,
                upper_limit=upper_limit,
                force_binding_sites_frac=force_binding_sites_frac,
                mask_all_cdrs=mask_all_cdrs,
            ),
            shuffle=shuffle_batches,
            *args,
            **kwargs,
        )

    @staticmethod
    def from_args(
        dataset_folder,
        features_folder=&#34;./data/tmp/&#34;,
        clustering_dict_path=None,
        max_length=None,
        rewrite=False,
        use_fraction=1,
        load_to_ram=False,
        debug=False,
        interpolate=&#34;none&#34;,
        node_features_type=None,
        entry_type=&#34;biounit&#34;,  # biounit, chain, pair
        classes_to_exclude=None,
        lower_limit=15,
        upper_limit=100,
        mask_residues=True,
        mask_whole_chains=False,
        mask_frac=None,
        force_binding_sites_frac=0,
        shuffle_clusters=True,
        shuffle_batches=True,
        mask_all_cdrs=False,
        *args,
        **kwargs,
    ) -&gt; None:
        &#34;&#34;&#34;
        Creates a `ProteinLoader` instance with a `ProteinDataset` from the given arguments

        Parameters
        ----------
        dataset_folder : str
            the path to the folder with proteinflow format input files (assumes that files are named {biounit_id}.pickle)
        features_folder : str
            the path to the folder where the ProteinMPNN features will be saved
        clustering_dict_path : str, optional
            path to the pickled clustering dictionary (keys are cluster ids, values are (biounit id, chain id) tuples)
        max_length : int, optional
            entries with total length of chains larger than `max_length` will be disregarded
        rewrite : bool, default False
            if `False`, existing feature files are not overwritten
        use_fraction : float, default 1
            the fraction of the clusters to use (first N in alphabetic order)
        load_to_ram : bool, default False
            if `True`, the data will be stored in RAM (use with caution! if RAM isn&#39;t big enough the machine might crash)
        debug : bool, default False
            only process 1000 files
        interpolate : {&#34;none&#34;, &#34;only_middle&#34;, &#34;all&#34;}
            `&#34;none&#34;` for no interpolation, `&#34;only_middle&#34;` for only linear interpolation in the middle, `&#34;all&#34;` for linear interpolation + ends generation
        node_features_type : {&#34;dihedral&#34;, &#34;sidechain_orientation&#34;, &#34;chemical&#34;, &#34;secondary_structure&#34;, &#34;sidechain_coords&#34;, or combinations with &#34;+&#34;}, optional
            the type of node features, e.g. `&#34;dihedral&#34;` or `&#34;sidechain_orientation+chemical&#34;`
        entry_type : {&#34;biounit&#34;, &#34;chain&#34;, &#34;pair&#34;}
            the type of entries to generate (`&#34;biounit&#34;` for biounit-level, `&#34;chain&#34;` for chain-level, `&#34;pair&#34;` for chain-chain pairs)
        classes_to_exclude : list of str, optional
            a list of classes to exclude from the dataset (select from `&#34;single_chains&#34;`, `&#34;heteromers&#34;`, `&#34;homomers&#34;`)
        lower_limit : int, default 15
            the minimum number of residues to mask
        upper_limit : int, default 100
            the maximum number of residues to mask
        mask_frac : float, optional
            if given, the `lower_limit` and `upper_limit` are ignored and the number of residues to mask is `mask_frac` times the length of the chain
        mask_whole_chains : bool, default False
            if `True`, `upper_limit`, `force_binding_sites` and `lower_limit` are ignored and the whole chain is masked instead
        force_binding_sites_frac : float, default 0
            if &gt; 0, in the fraction of cases where a chain from a polymer is sampled, the center of the masked region will be
            forced to be in a binding site
        shuffle_clusters : bool, default True
            if `True`, a new representative is randomly selected for each cluster at each epoch (if `clustering_dict_path` is given)
        shuffle_batches : bool, default True
            if `True`, the batches are shuffled at each epoch
        mask_all_cdrs : bool, default False
            if `True`, all CDRs are masked instead of just the sampled one
        &#34;&#34;&#34;

        dataset = ProteinDataset(
            dataset_folder=dataset_folder,
            features_folder=features_folder,
            clustering_dict_path=clustering_dict_path,
            max_length=max_length,
            rewrite=rewrite,
            use_fraction=use_fraction,
            load_to_ram=load_to_ram,
            debug=debug,
            interpolate=interpolate,
            node_features_type=node_features_type,
            entry_type=entry_type,
            classes_to_exclude=classes_to_exclude,
            shuffle_clusters=shuffle_clusters,
        )
        return ProteinLoader(
            dataset=dataset,
            lower_limit=lower_limit,
            upper_limit=upper_limit,
            mask_residues=mask_residues,
            mask_whole_chains=mask_whole_chains,
            mask_frac=mask_frac,
            force_binding_sites_frac=force_binding_sites_frac,
            shuffle_batches=shuffle_batches,
            mask_all_cdrs=mask_all_cdrs,
            *args,
            **kwargs,
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="proteinflow.protein_loader.ProteinLoader"><code class="flex name class">
<span>class <span class="ident">ProteinLoader</span></span>
<span>(</span><span>dataset, lower_limit=15, upper_limit=100, mask_residues=True, mask_whole_chains=False, mask_frac=None, collate_func=proteinflow.protein_loader._PadCollate, force_binding_sites_frac=0, shuffle_batches=True, mask_all_cdrs=False, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of <code>torch.data.utils.DataLoader</code> tuned for the <code><a title="proteinflow" href="index.html">proteinflow</a></code> dataset</p>
<p>Creates and iterates over an instance of <code>ProteinDataset</code>, omitting the <code>'chain_dict'</code> keys.
See the <code>ProteinDataset</code> documentation for more information.</p>
<p>If batch size is larger than one, all objects are padded with zeros at the ends to reach the length of the
longest protein in the batch.</p>
<p>If <code>mask_residues</code> is <code>True</code>, an additional <code>'masked_res'</code> key is added to the output. The value is a binary
tensor shaped <code>(B, L)</code> where 1 denotes the part that needs to be predicted and 0 is everything else. The tensors are generated
according to the following rulesd:
- if the dataset is generated from SAbDab files, the sampled CDR is masked,
- if <code>mask_whole_chains</code> is <code>True</code>, the whole chain is masked,
- if <code>mask_frac</code> is given, the number of residues to mask is <code>mask_frac</code> times the length of the chain,
- otherwise, the number of residues to mask is sampled uniformly from the range [<code>lower_limit</code>, <code>upper_limit</code>].</p>
<p>If <code>force_binding_sites_frac</code> &gt; 0 and <code>mask_whole_chains</code> is <code>False</code>, in the fraction of cases where a chain
from a polymer is sampled, the center of the masked region will be forced to be in a binding site (in PDB datasets).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dataset</code></strong> :&ensp;<code>ProteinDataset</code></dt>
<dd>a ProteinDataset instance</dd>
<dt><strong><code>lower_limit</code></strong> :&ensp;<code>int</code>, default <code>15</code></dt>
<dd>the minimum number of residues to mask</dd>
<dt><strong><code>upper_limit</code></strong> :&ensp;<code>int</code>, default <code>100</code></dt>
<dd>the maximum number of residues to mask</dd>
<dt><strong><code>mask_frac</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>if given, the <code>lower_limit</code> and <code>upper_limit</code> are ignored and the number of residues to mask is <code>mask_frac</code> times the length of the chain</dd>
<dt><strong><code>mask_whole_chains</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>if <code>True</code>, <code>upper_limit</code>, <code>force_binding_sites</code> and <code>lower_limit</code> are ignored and the whole chain is masked instead</dd>
<dt><strong><code>force_binding_sites_frac</code></strong> :&ensp;<code>float</code>, default <code>0</code></dt>
<dd>if &gt; 0, in the fraction of cases where a chain from a polymer is sampled, the center of the masked region will be
forced to be in a binding site</dd>
<dt><strong><code>shuffle_clusters</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>if <code>True</code>, a new representative is randomly selected for each cluster at each epoch (if <code>clustering_dict_path</code> is given)</dd>
<dt><strong><code>shuffle_batches</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>if <code>True</code>, the batches are shuffled at each epoch</dd>
<dt><strong><code>mask_all_cdrs</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>if <code>True</code>, all CDRs are masked instead of just the sampled one</dd>
<dt><strong><code>collate_func</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>a function that takes a list of samples and returns a batch and inherits from _PadCollate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProteinLoader(DataLoader):
    &#34;&#34;&#34;
    A subclass of `torch.data.utils.DataLoader` tuned for the `proteinflow` dataset

    Creates and iterates over an instance of `ProteinDataset`, omitting the `&#39;chain_dict&#39;` keys.
    See the `ProteinDataset` documentation for more information.

    If batch size is larger than one, all objects are padded with zeros at the ends to reach the length of the
    longest protein in the batch.

    If `mask_residues` is `True`, an additional `&#39;masked_res&#39;` key is added to the output. The value is a binary
    tensor shaped `(B, L)` where 1 denotes the part that needs to be predicted and 0 is everything else. The tensors are generated
    according to the following rulesd:
    - if the dataset is generated from SAbDab files, the sampled CDR is masked,
    - if `mask_whole_chains` is `True`, the whole chain is masked,
    - if `mask_frac` is given, the number of residues to mask is `mask_frac` times the length of the chain,
    - otherwise, the number of residues to mask is sampled uniformly from the range [`lower_limit`, `upper_limit`].

    If `force_binding_sites_frac` &gt; 0 and `mask_whole_chains` is `False`, in the fraction of cases where a chain
    from a polymer is sampled, the center of the masked region will be forced to be in a binding site (in PDB datasets).
    &#34;&#34;&#34;

    def __init__(
        self,
        dataset,
        lower_limit=15,
        upper_limit=100,
        mask_residues=True,
        mask_whole_chains=False,
        mask_frac=None,
        collate_func=_PadCollate,
        force_binding_sites_frac=0,
        shuffle_batches=True,
        mask_all_cdrs=False,
        *args,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        dataset : ProteinDataset
            a ProteinDataset instance
        lower_limit : int, default 15
            the minimum number of residues to mask
        upper_limit : int, default 100
            the maximum number of residues to mask
        mask_frac : float, optional
            if given, the `lower_limit` and `upper_limit` are ignored and the number of residues to mask is `mask_frac` times the length of the chain
        mask_whole_chains : bool, default False
            if `True`, `upper_limit`, `force_binding_sites` and `lower_limit` are ignored and the whole chain is masked instead
        force_binding_sites_frac : float, default 0
            if &gt; 0, in the fraction of cases where a chain from a polymer is sampled, the center of the masked region will be
            forced to be in a binding site
        shuffle_clusters : bool, default True
            if `True`, a new representative is randomly selected for each cluster at each epoch (if `clustering_dict_path` is given)
        shuffle_batches : bool, default True
            if `True`, the batches are shuffled at each epoch
        mask_all_cdrs : bool, default False
            if `True`, all CDRs are masked instead of just the sampled one
        collate_func : callable, optional
            a function that takes a list of samples and returns a batch and inherits from _PadCollate
        &#34;&#34;&#34;

        super().__init__(
            dataset,
            collate_fn=collate_func(
                mask_residues=mask_residues,
                mask_whole_chains=mask_whole_chains,
                mask_frac=mask_frac,
                lower_limit=lower_limit,
                upper_limit=upper_limit,
                force_binding_sites_frac=force_binding_sites_frac,
                mask_all_cdrs=mask_all_cdrs,
            ),
            shuffle=shuffle_batches,
            *args,
            **kwargs,
        )

    @staticmethod
    def from_args(
        dataset_folder,
        features_folder=&#34;./data/tmp/&#34;,
        clustering_dict_path=None,
        max_length=None,
        rewrite=False,
        use_fraction=1,
        load_to_ram=False,
        debug=False,
        interpolate=&#34;none&#34;,
        node_features_type=None,
        entry_type=&#34;biounit&#34;,  # biounit, chain, pair
        classes_to_exclude=None,
        lower_limit=15,
        upper_limit=100,
        mask_residues=True,
        mask_whole_chains=False,
        mask_frac=None,
        force_binding_sites_frac=0,
        shuffle_clusters=True,
        shuffle_batches=True,
        mask_all_cdrs=False,
        *args,
        **kwargs,
    ) -&gt; None:
        &#34;&#34;&#34;
        Creates a `ProteinLoader` instance with a `ProteinDataset` from the given arguments

        Parameters
        ----------
        dataset_folder : str
            the path to the folder with proteinflow format input files (assumes that files are named {biounit_id}.pickle)
        features_folder : str
            the path to the folder where the ProteinMPNN features will be saved
        clustering_dict_path : str, optional
            path to the pickled clustering dictionary (keys are cluster ids, values are (biounit id, chain id) tuples)
        max_length : int, optional
            entries with total length of chains larger than `max_length` will be disregarded
        rewrite : bool, default False
            if `False`, existing feature files are not overwritten
        use_fraction : float, default 1
            the fraction of the clusters to use (first N in alphabetic order)
        load_to_ram : bool, default False
            if `True`, the data will be stored in RAM (use with caution! if RAM isn&#39;t big enough the machine might crash)
        debug : bool, default False
            only process 1000 files
        interpolate : {&#34;none&#34;, &#34;only_middle&#34;, &#34;all&#34;}
            `&#34;none&#34;` for no interpolation, `&#34;only_middle&#34;` for only linear interpolation in the middle, `&#34;all&#34;` for linear interpolation + ends generation
        node_features_type : {&#34;dihedral&#34;, &#34;sidechain_orientation&#34;, &#34;chemical&#34;, &#34;secondary_structure&#34;, &#34;sidechain_coords&#34;, or combinations with &#34;+&#34;}, optional
            the type of node features, e.g. `&#34;dihedral&#34;` or `&#34;sidechain_orientation+chemical&#34;`
        entry_type : {&#34;biounit&#34;, &#34;chain&#34;, &#34;pair&#34;}
            the type of entries to generate (`&#34;biounit&#34;` for biounit-level, `&#34;chain&#34;` for chain-level, `&#34;pair&#34;` for chain-chain pairs)
        classes_to_exclude : list of str, optional
            a list of classes to exclude from the dataset (select from `&#34;single_chains&#34;`, `&#34;heteromers&#34;`, `&#34;homomers&#34;`)
        lower_limit : int, default 15
            the minimum number of residues to mask
        upper_limit : int, default 100
            the maximum number of residues to mask
        mask_frac : float, optional
            if given, the `lower_limit` and `upper_limit` are ignored and the number of residues to mask is `mask_frac` times the length of the chain
        mask_whole_chains : bool, default False
            if `True`, `upper_limit`, `force_binding_sites` and `lower_limit` are ignored and the whole chain is masked instead
        force_binding_sites_frac : float, default 0
            if &gt; 0, in the fraction of cases where a chain from a polymer is sampled, the center of the masked region will be
            forced to be in a binding site
        shuffle_clusters : bool, default True
            if `True`, a new representative is randomly selected for each cluster at each epoch (if `clustering_dict_path` is given)
        shuffle_batches : bool, default True
            if `True`, the batches are shuffled at each epoch
        mask_all_cdrs : bool, default False
            if `True`, all CDRs are masked instead of just the sampled one
        &#34;&#34;&#34;

        dataset = ProteinDataset(
            dataset_folder=dataset_folder,
            features_folder=features_folder,
            clustering_dict_path=clustering_dict_path,
            max_length=max_length,
            rewrite=rewrite,
            use_fraction=use_fraction,
            load_to_ram=load_to_ram,
            debug=debug,
            interpolate=interpolate,
            node_features_type=node_features_type,
            entry_type=entry_type,
            classes_to_exclude=classes_to_exclude,
            shuffle_clusters=shuffle_clusters,
        )
        return ProteinLoader(
            dataset=dataset,
            lower_limit=lower_limit,
            upper_limit=upper_limit,
            mask_residues=mask_residues,
            mask_whole_chains=mask_whole_chains,
            mask_frac=mask_frac,
            force_binding_sites_frac=force_binding_sites_frac,
            shuffle_batches=shuffle_batches,
            mask_all_cdrs=mask_all_cdrs,
            *args,
            **kwargs,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.utils.data.dataloader.DataLoader</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="proteinflow.protein_loader.ProteinLoader.batch_size"><code class="name">var <span class="ident">batch_size</span> : Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="proteinflow.protein_loader.ProteinLoader.dataset"><code class="name">var <span class="ident">dataset</span> : torch.utils.data.dataset.Dataset[+T_co]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="proteinflow.protein_loader.ProteinLoader.drop_last"><code class="name">var <span class="ident">drop_last</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="proteinflow.protein_loader.ProteinLoader.num_workers"><code class="name">var <span class="ident">num_workers</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="proteinflow.protein_loader.ProteinLoader.pin_memory"><code class="name">var <span class="ident">pin_memory</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="proteinflow.protein_loader.ProteinLoader.pin_memory_device"><code class="name">var <span class="ident">pin_memory_device</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="proteinflow.protein_loader.ProteinLoader.prefetch_factor"><code class="name">var <span class="ident">prefetch_factor</span> : Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="proteinflow.protein_loader.ProteinLoader.sampler"><code class="name">var <span class="ident">sampler</span> : Union[torch.utils.data.sampler.Sampler, Iterable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="proteinflow.protein_loader.ProteinLoader.timeout"><code class="name">var <span class="ident">timeout</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="proteinflow.protein_loader.ProteinLoader.from_args"><code class="name flex">
<span>def <span class="ident">from_args</span></span>(<span>dataset_folder, features_folder='./data/tmp/', clustering_dict_path=None, max_length=None, rewrite=False, use_fraction=1, load_to_ram=False, debug=False, interpolate='none', node_features_type=None, entry_type='biounit', classes_to_exclude=None, lower_limit=15, upper_limit=100, mask_residues=True, mask_whole_chains=False, mask_frac=None, force_binding_sites_frac=0, shuffle_clusters=True, shuffle_batches=True, mask_all_cdrs=False, *args, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a <code><a title="proteinflow.protein_loader.ProteinLoader" href="#proteinflow.protein_loader.ProteinLoader">ProteinLoader</a></code> instance with a <code>ProteinDataset</code> from the given arguments</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dataset_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>the path to the folder with proteinflow format input files (assumes that files are named {biounit_id}.pickle)</dd>
<dt><strong><code>features_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>the path to the folder where the ProteinMPNN features will be saved</dd>
<dt><strong><code>clustering_dict_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>path to the pickled clustering dictionary (keys are cluster ids, values are (biounit id, chain id) tuples)</dd>
<dt><strong><code>max_length</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>entries with total length of chains larger than <code>max_length</code> will be disregarded</dd>
<dt><strong><code>rewrite</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>if <code>False</code>, existing feature files are not overwritten</dd>
<dt><strong><code>use_fraction</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>the fraction of the clusters to use (first N in alphabetic order)</dd>
<dt><strong><code>load_to_ram</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>if <code>True</code>, the data will be stored in RAM (use with caution! if RAM isn't big enough the machine might crash)</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>only process 1000 files</dd>
<dt><strong><code>interpolate</code></strong> :&ensp;<code>{"none", "only_middle", "all"}</code></dt>
<dd><code>"none"</code> for no interpolation, <code>"only_middle"</code> for only linear interpolation in the middle, <code>"all"</code> for linear interpolation + ends generation</dd>
<dt><strong><code>node_features_type</code></strong> :&ensp;<code>{"dihedral", "sidechain_orientation", "chemical", "secondary_structure", "sidechain_coords",</code> or <code>combinations with "+"}</code>, optional</dt>
<dd>the type of node features, e.g. <code>"dihedral"</code> or <code>"sidechain_orientation+chemical"</code></dd>
<dt><strong><code>entry_type</code></strong> :&ensp;<code>{"biounit", "chain", "pair"}</code></dt>
<dd>the type of entries to generate (<code>"biounit"</code> for biounit-level, <code>"chain"</code> for chain-level, <code>"pair"</code> for chain-chain pairs)</dd>
<dt><strong><code>classes_to_exclude</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>a list of classes to exclude from the dataset (select from <code>"single_chains"</code>, <code>"heteromers"</code>, <code>"homomers"</code>)</dd>
<dt><strong><code>lower_limit</code></strong> :&ensp;<code>int</code>, default <code>15</code></dt>
<dd>the minimum number of residues to mask</dd>
<dt><strong><code>upper_limit</code></strong> :&ensp;<code>int</code>, default <code>100</code></dt>
<dd>the maximum number of residues to mask</dd>
<dt><strong><code>mask_frac</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>if given, the <code>lower_limit</code> and <code>upper_limit</code> are ignored and the number of residues to mask is <code>mask_frac</code> times the length of the chain</dd>
<dt><strong><code>mask_whole_chains</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>if <code>True</code>, <code>upper_limit</code>, <code>force_binding_sites</code> and <code>lower_limit</code> are ignored and the whole chain is masked instead</dd>
<dt><strong><code>force_binding_sites_frac</code></strong> :&ensp;<code>float</code>, default <code>0</code></dt>
<dd>if &gt; 0, in the fraction of cases where a chain from a polymer is sampled, the center of the masked region will be
forced to be in a binding site</dd>
<dt><strong><code>shuffle_clusters</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>if <code>True</code>, a new representative is randomly selected for each cluster at each epoch (if <code>clustering_dict_path</code> is given)</dd>
<dt><strong><code>shuffle_batches</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>if <code>True</code>, the batches are shuffled at each epoch</dd>
<dt><strong><code>mask_all_cdrs</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>if <code>True</code>, all CDRs are masked instead of just the sampled one</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_args(
    dataset_folder,
    features_folder=&#34;./data/tmp/&#34;,
    clustering_dict_path=None,
    max_length=None,
    rewrite=False,
    use_fraction=1,
    load_to_ram=False,
    debug=False,
    interpolate=&#34;none&#34;,
    node_features_type=None,
    entry_type=&#34;biounit&#34;,  # biounit, chain, pair
    classes_to_exclude=None,
    lower_limit=15,
    upper_limit=100,
    mask_residues=True,
    mask_whole_chains=False,
    mask_frac=None,
    force_binding_sites_frac=0,
    shuffle_clusters=True,
    shuffle_batches=True,
    mask_all_cdrs=False,
    *args,
    **kwargs,
) -&gt; None:
    &#34;&#34;&#34;
    Creates a `ProteinLoader` instance with a `ProteinDataset` from the given arguments

    Parameters
    ----------
    dataset_folder : str
        the path to the folder with proteinflow format input files (assumes that files are named {biounit_id}.pickle)
    features_folder : str
        the path to the folder where the ProteinMPNN features will be saved
    clustering_dict_path : str, optional
        path to the pickled clustering dictionary (keys are cluster ids, values are (biounit id, chain id) tuples)
    max_length : int, optional
        entries with total length of chains larger than `max_length` will be disregarded
    rewrite : bool, default False
        if `False`, existing feature files are not overwritten
    use_fraction : float, default 1
        the fraction of the clusters to use (first N in alphabetic order)
    load_to_ram : bool, default False
        if `True`, the data will be stored in RAM (use with caution! if RAM isn&#39;t big enough the machine might crash)
    debug : bool, default False
        only process 1000 files
    interpolate : {&#34;none&#34;, &#34;only_middle&#34;, &#34;all&#34;}
        `&#34;none&#34;` for no interpolation, `&#34;only_middle&#34;` for only linear interpolation in the middle, `&#34;all&#34;` for linear interpolation + ends generation
    node_features_type : {&#34;dihedral&#34;, &#34;sidechain_orientation&#34;, &#34;chemical&#34;, &#34;secondary_structure&#34;, &#34;sidechain_coords&#34;, or combinations with &#34;+&#34;}, optional
        the type of node features, e.g. `&#34;dihedral&#34;` or `&#34;sidechain_orientation+chemical&#34;`
    entry_type : {&#34;biounit&#34;, &#34;chain&#34;, &#34;pair&#34;}
        the type of entries to generate (`&#34;biounit&#34;` for biounit-level, `&#34;chain&#34;` for chain-level, `&#34;pair&#34;` for chain-chain pairs)
    classes_to_exclude : list of str, optional
        a list of classes to exclude from the dataset (select from `&#34;single_chains&#34;`, `&#34;heteromers&#34;`, `&#34;homomers&#34;`)
    lower_limit : int, default 15
        the minimum number of residues to mask
    upper_limit : int, default 100
        the maximum number of residues to mask
    mask_frac : float, optional
        if given, the `lower_limit` and `upper_limit` are ignored and the number of residues to mask is `mask_frac` times the length of the chain
    mask_whole_chains : bool, default False
        if `True`, `upper_limit`, `force_binding_sites` and `lower_limit` are ignored and the whole chain is masked instead
    force_binding_sites_frac : float, default 0
        if &gt; 0, in the fraction of cases where a chain from a polymer is sampled, the center of the masked region will be
        forced to be in a binding site
    shuffle_clusters : bool, default True
        if `True`, a new representative is randomly selected for each cluster at each epoch (if `clustering_dict_path` is given)
    shuffle_batches : bool, default True
        if `True`, the batches are shuffled at each epoch
    mask_all_cdrs : bool, default False
        if `True`, all CDRs are masked instead of just the sampled one
    &#34;&#34;&#34;

    dataset = ProteinDataset(
        dataset_folder=dataset_folder,
        features_folder=features_folder,
        clustering_dict_path=clustering_dict_path,
        max_length=max_length,
        rewrite=rewrite,
        use_fraction=use_fraction,
        load_to_ram=load_to_ram,
        debug=debug,
        interpolate=interpolate,
        node_features_type=node_features_type,
        entry_type=entry_type,
        classes_to_exclude=classes_to_exclude,
        shuffle_clusters=shuffle_clusters,
    )
    return ProteinLoader(
        dataset=dataset,
        lower_limit=lower_limit,
        upper_limit=upper_limit,
        mask_residues=mask_residues,
        mask_whole_chains=mask_whole_chains,
        mask_frac=mask_frac,
        force_binding_sites_frac=force_binding_sites_frac,
        shuffle_batches=shuffle_batches,
        mask_all_cdrs=mask_all_cdrs,
        *args,
        **kwargs,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="proteinflow" href="index.html">proteinflow</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="proteinflow.protein_loader.ProteinLoader" href="#proteinflow.protein_loader.ProteinLoader">ProteinLoader</a></code></h4>
<ul class="two-column">
<li><code><a title="proteinflow.protein_loader.ProteinLoader.batch_size" href="#proteinflow.protein_loader.ProteinLoader.batch_size">batch_size</a></code></li>
<li><code><a title="proteinflow.protein_loader.ProteinLoader.dataset" href="#proteinflow.protein_loader.ProteinLoader.dataset">dataset</a></code></li>
<li><code><a title="proteinflow.protein_loader.ProteinLoader.drop_last" href="#proteinflow.protein_loader.ProteinLoader.drop_last">drop_last</a></code></li>
<li><code><a title="proteinflow.protein_loader.ProteinLoader.from_args" href="#proteinflow.protein_loader.ProteinLoader.from_args">from_args</a></code></li>
<li><code><a title="proteinflow.protein_loader.ProteinLoader.num_workers" href="#proteinflow.protein_loader.ProteinLoader.num_workers">num_workers</a></code></li>
<li><code><a title="proteinflow.protein_loader.ProteinLoader.pin_memory" href="#proteinflow.protein_loader.ProteinLoader.pin_memory">pin_memory</a></code></li>
<li><code><a title="proteinflow.protein_loader.ProteinLoader.pin_memory_device" href="#proteinflow.protein_loader.ProteinLoader.pin_memory_device">pin_memory_device</a></code></li>
<li><code><a title="proteinflow.protein_loader.ProteinLoader.prefetch_factor" href="#proteinflow.protein_loader.ProteinLoader.prefetch_factor">prefetch_factor</a></code></li>
<li><code><a title="proteinflow.protein_loader.ProteinLoader.sampler" href="#proteinflow.protein_loader.ProteinLoader.sampler">sampler</a></code></li>
<li><code><a title="proteinflow.protein_loader.ProteinLoader.timeout" href="#proteinflow.protein_loader.ProteinLoader.timeout">timeout</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>