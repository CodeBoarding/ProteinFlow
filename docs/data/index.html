<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>proteinflow.data API documentation</title>
<meta name="description" content="Classes for downloading and manipulating protein data â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="shortcut icon" type="image/x-icon" href="adaptyv_logo.png?">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>proteinflow.data</code></h1>
</header>
<section id="section-intro">
<p>Classes for downloading and manipulating protein data.</p>
<ul>
<li><code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code>: a class for manipulating proteinflow pickle files,</li>
<li><code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code>: a class for manipulating raw PDB files,</li>
<li><code><a title="proteinflow.data.SAbDabEntry" href="#proteinflow.data.SAbDabEntry">SAbDabEntry</a></code>: a class for manipulating SAbDab files with specific methods for antibody data.</li>
</ul>
<p>A <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object can be created from a proteinflow pickle file, a PDB file or a SAbDab file directly
and can be used to process the data and extract additional features. The processed data can be saved as a
proteinflow pickle file or a PDB file.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Classes for downloading and manipulating protein data.

- `ProteinEntry`: a class for manipulating proteinflow pickle files,
- `PDBEntry`: a class for manipulating raw PDB files,
- `SAbDabEntry`: a class for manipulating SAbDab files with specific methods for antibody data.

A `ProteinEntry` object can be created from a proteinflow pickle file, a PDB file or a SAbDab file directly
and can be used to process the data and extract additional features. The processed data can be saved as a
proteinflow pickle file or a PDB file.

&#34;&#34;&#34;
import os
import pickle
import string
import tempfile
import warnings
from collections import defaultdict

import Bio.PDB
import numpy as np
import pandas as pd
from Bio import pairwise2
from biopandas.pdb import PandasPdb
from torch import Tensor, from_numpy

try:
    import MDAnalysis as mda
except ImportError:
    pass
try:
    from methodtools import lru_cache
except ImportError:

    def lru_cache():
        &#34;&#34;&#34;Make a dummy decorator.&#34;&#34;&#34;

        def wrapper(func):
            return func

        return wrapper


from proteinflow.constants import (
    _PMAP,
    ALPHABET,
    ALPHABET_REVERSE,
    ATOM_MASKS,
    BACKBONE_ORDER,
    CDR_ALPHABET,
    CDR_REVERSE,
    CDR_VALUES,
    COLORS,
    D3TO1,
    MAIN_ATOM_DICT,
    SIDECHAIN_ORDER,
)
from proteinflow.data.utils import (
    CustomMmcif,
    PDBBuilder,
    PDBError,
    _annotate_sse,
    _Atom,
    _dihedral_angle,
    _retrieve_chain_names,
)
from proteinflow.download import download_fasta, download_pdb
from proteinflow.extra import _get_view, requires_extra
from proteinflow.ligand import _get_ligands
from proteinflow.metrics import (
    ablang_pll,
    blosum62_score,
    ca_rmsd,
    confidence_from_file,
    esm_pll,
    esmfold_generate,
    igfold_generate,
    immunebuilder_generate,
    long_repeat_num,
    tm_score,
)


def interpolate_coords(crd, mask, fill_ends=True):
    &#34;&#34;&#34;Fill in missing values in a coordinates array with linear interpolation.

    Parameters
    ----------
    crd : np.ndarray
        Coordinates array of shape `(L, 4, 3)`
    mask : np.ndarray
        Mask array of shape `(L,)` where 1 indicates residues with known coordinates and 0
        indicates missing values
    fill_ends : bool, default True
        If `True`, fill in missing values at the ends of the protein sequence with the edge values;
        otherwise fill them in with zeros

    Returns
    -------
    crd : np.ndarray
        Interpolated coordinates array of shape `(L, 4, 3)`
    mask : np.ndarray
        Interpolated mask array of shape `(L,)` where 1 indicates residues with known or interpolated
        coordinates and 0 indicates missing values

    &#34;&#34;&#34;
    crd[(1 - mask).astype(bool)] = np.nan
    df = pd.DataFrame(crd.reshape((crd.shape[0], -1)))
    crd = df.interpolate(limit_area=&#34;inside&#34; if not fill_ends else None).values.reshape(
        crd.shape
    )
    if not fill_ends:
        nan_mask = np.isnan(crd)  # in the middle the nans have been interpolated
        interpolated_mask = np.zeros_like(mask)
        interpolated_mask[~np.isnan(crd[:, 0, 0])] = 1
        crd[nan_mask] = 0
    else:
        interpolated_mask = np.ones_like(crd[:, :, 0])
    return crd, mask


class ProteinEntry:
    &#34;&#34;&#34;A class to interact with proteinflow data files.&#34;&#34;&#34;

    ATOM_ORDER = {k: BACKBONE_ORDER + v for k, v in SIDECHAIN_ORDER.items()}
    &#34;&#34;&#34;A dictionary mapping 3-letter residue names to the order of atoms in the coordinates array.&#34;&#34;&#34;

    def __init__(
        self,
        seqs,
        crds,
        masks,
        chain_ids,
        predict_masks=None,
        cdrs=None,
        protein_id=None,
    ):
        &#34;&#34;&#34;Initialize a `ProteinEntry` object.

        Parameters
        ----------
        seqs : list of str
            Amino acid sequences of the protein (one-letter code)
        crds : list of np.ndarray
            Coordinates of the protein, `numpy` arrays of shape `(L, 14, 3)`,
            in the order of `N, C, CA, O`
        masks : list of np.ndarray
            Mask arrays where 1 indicates residues with known coordinates and 0
            indicates missing values
        cdrs : list of np.ndarray
            `&#39;numpy&#39;` arrays of shape `(L,)` where CDR residues are marked with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...)
            and non-CDR residues are marked with `&#39;-&#39;`
        chain_ids : list of str
            Chain IDs of the protein
        predict_masks : list of np.ndarray, optional
            Mask arrays where 1 indicates residues that were generated by a model and 0
            indicates residues with known coordinates
        cdrs : list of np.ndarray, optional
            `&#39;numpy&#39;` arrays of shape `(L,)` where CDR residues are marked with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...)
        protein_id : str, optional
            ID of the protein

        &#34;&#34;&#34;
        if crds[0].shape[1] != 14:
            raise ValueError(
                &#34;Coordinates array must have 14 atoms in the order of N, C, CA, O, sidechain atoms&#34;
            )
        self.seq = {x: seq for x, seq in zip(chain_ids, seqs)}
        self.crd = {x: crd for x, crd in zip(chain_ids, crds)}
        self.mask = {x: mask for x, mask in zip(chain_ids, masks)}
        self.mask_original = {x: mask for x, mask in zip(chain_ids, masks)}
        if cdrs is None:
            cdrs = [None for _ in chain_ids]
        self.cdr = {x: cdr for x, cdr in zip(chain_ids, cdrs)}
        if predict_masks is None:
            predict_masks = [None for _ in chain_ids]
        self.predict_mask = {x: mask for x, mask in zip(chain_ids, predict_masks)}
        self.id = protein_id

    def get_id(self):
        &#34;&#34;&#34;Return the ID of the protein.&#34;&#34;&#34;
        return self.id

    def interpolate_coords(self, fill_ends=True):
        &#34;&#34;&#34;Fill in missing values in the coordinates arrays with linear interpolation.

        Parameters
        ----------
        fill_ends : bool, default True
            If `True`, fill in missing values at the ends of the protein sequence with the edge values;
            otherwise fill them in with zeros

        &#34;&#34;&#34;
        for chain in self.get_chains():
            self.crd[chain], self.mask[chain] = interpolate_coords(
                self.crd[chain], self.mask[chain], fill_ends=fill_ends
            )

    def cut_missing_edges(self):
        &#34;&#34;&#34;Cut off the ends of the protein sequence that have missing coordinates.&#34;&#34;&#34;
        for chain in self.get_chains():
            mask = self.mask[chain]
            known_ind = np.where(mask == 1)[0]
            start, end = known_ind[0], known_ind[-1] + 1
            self.seq[chain] = self.seq[chain][start:end]
            self.crd[chain] = self.crd[chain][start:end]
            self.mask[chain] = self.mask[chain][start:end]
            if self.cdr[chain] is not None:
                self.cdr[chain] = self.cdr[chain][start:end]

    def get_chains(self):
        &#34;&#34;&#34;Get the chain IDs of the protein.

        Returns
        -------
        chains : list of str
            Chain IDs of the protein

        &#34;&#34;&#34;
        return sorted(self.seq.keys())

    def _get_chains_list(self, chains):
        &#34;&#34;&#34;Get a list of chains to iterate over.&#34;&#34;&#34;
        if chains is None:
            chains = self.get_chains()
        return chains

    def get_chain_type_dict(self, chains=None):
        &#34;&#34;&#34;Get the chain types of the protein.

        If the CDRs are not annotated, this function will return `None`.
        If there is no light or heavy chain, the corresponding key will be missing.
        If there is no antigen chain, the `&#39;antigen&#39;` key will map to an empty list.

        Parameters
        ----------
        chains : list of str, default None
            Chain IDs to consider

        Returns
        -------
        chain_type_dict : dict
            A dictionary with keys `&#39;heavy&#39;`, `&#39;light&#39;` and `&#39;antigen&#39;` and values
            the corresponding chain IDs

        &#34;&#34;&#34;
        if not self.has_cdr():
            return None
        chain_type_dict = {&#34;antigen&#34;: []}
        chains = self._get_chains_list(chains)
        for chain, cdr in self.cdr.items():
            if chain not in chains:
                continue
            u = np.unique(cdr)
            if &#34;H1&#34; in u:
                chain_type_dict[&#34;heavy&#34;] = chain
            elif &#34;L1&#34; in u:
                chain_type_dict[&#34;light&#34;] = chain
            else:
                chain_type_dict[&#34;antigen&#34;].append(chain)
        return chain_type_dict

    def get_length(self, chains=None):
        &#34;&#34;&#34;Get the total length of a set of chains.

        Parameters
        ----------
        chain : str, optional
            Chain ID; if `None`, the length of the whole protein is returned

        Returns
        -------
        length : int
            Length of the chain

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        return sum([len(self.seq[x]) for x in chains])

    def get_cdr_length(self, chains):
        &#34;&#34;&#34;Get the length of the CDR regions of a set of chains.

        Parameters
        ----------
        chain : str
            Chain ID

        Returns
        -------
        length : int
            Length of the CDR regions of the chain

        &#34;&#34;&#34;
        if not self.has_cdr():
            return {x: None for x in [&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;]}
        return {
            x: len(self.get_sequence(chains=chains, cdr=x))
            for x in [&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;]
        }

    def has_cdr(self):
        &#34;&#34;&#34;Check if the protein is from the SAbDab database.

        Returns
        -------
        is_sabdab : bool
            True if the protein is from the SAbDab database

        &#34;&#34;&#34;
        return list(self.cdr.values())[0] is not None

    def has_predict_mask(self):
        &#34;&#34;&#34;Check if the protein has a predicted mask.

        Returns
        -------
        has_predict_mask : bool
            True if the protein has a predicted mask

        &#34;&#34;&#34;
        return list(self.predict_mask.values())[0] is not None

    def __len__(self):
        &#34;&#34;&#34;Get the total length of the protein chains.&#34;&#34;&#34;
        return self.get_length(self.get_chains())

    def get_sequence(self, chains=None, encode=False, cdr=None, only_known=False):
        &#34;&#34;&#34;Get the amino acid sequence of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the sequences of the specified chains is returned (in the same order);
            otherwise, all sequences are concatenated in alphabetical order of the chain IDs
        encode : bool, default False
            If `True`, the sequence is encoded as a `&#39;numpy&#39;` array of integers
            where each integer corresponds to the index of the amino acid in
            `proteinflow.constants.ALPHABET`
        cdr : {&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;}, optional
            If specified, only the CDR region of the specified type is returned
        only_known : bool, default False
            If `True`, only the residues with known coordinates are returned

        Returns
        -------
        seq : str or np.ndarray
            Amino acid sequence of the protein (one-letter code) or an encoded
            sequence as a `&#39;numpy&#39;` array of integers

        &#34;&#34;&#34;
        if cdr is not None and self.cdr is None:
            raise ValueError(&#34;CDR information not available&#34;)
        if cdr is not None:
            assert cdr in CDR_REVERSE, f&#34;CDR must be one of {list(CDR_REVERSE.keys())}&#34;
        chains = self._get_chains_list(chains)
        seq = &#34;&#34;.join([self.seq[c] for c in chains]).replace(&#34;B&#34;, &#34;&#34;)
        if encode:
            seq = np.array([ALPHABET_REVERSE[aa] for aa in seq])
        elif cdr is not None or only_known:
            seq = np.array(list(seq))
        if cdr is not None:
            cdr_arr = self.get_cdr(chains=chains)
            seq = seq[cdr_arr == cdr]
        if only_known:
            seq = seq[self.get_mask(chains=chains, cdr=cdr).astype(bool)]
        if not encode and not isinstance(seq, str):
            seq = &#34;&#34;.join(seq)
        return seq

    def get_coordinates(self, chains=None, bb_only=False, cdr=None, only_known=False):
        &#34;&#34;&#34;Get the coordinates of the protein.

        Backbone atoms are in the order of `N, C, CA, O`; for the full-atom
        order see `ProteinEntry.ATOM_ORDER` (sidechain atoms come after the
        backbone atoms).

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the coordinates of the specified chains are returned (in the same order);
            otherwise, all coordinates are concatenated in alphabetical order of the chain IDs
        bb_only : bool, default False
            If `True`, only the backbone atoms are returned
        cdr : {&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;}, optional
            If specified, only the CDR region of the specified type is returned
        only_known : bool, default False
            If `True`, only return the coordinates of residues with known coordinates

        Returns
        -------
        crd : np.ndarray
            Coordinates of the protein, `&#39;numpy&#39;` array of shape `(L, 14, 3)`
            or `(L, 4, 3)` if `bb_only=True`

        &#34;&#34;&#34;
        if cdr is not None and self.cdr is None:
            raise ValueError(&#34;CDR information not available&#34;)
        if cdr is not None:
            assert cdr in CDR_REVERSE, f&#34;CDR must be one of {list(CDR_REVERSE.keys())}&#34;
        chains = self._get_chains_list(chains)
        crd = np.concatenate([self.crd[c] for c in chains], axis=0)
        if cdr is not None:
            crd = crd[self.cdr == cdr]
        if bb_only:
            crd = crd[:, :4, :]
        if only_known:
            crd = crd[self.get_mask(chains=chains, cdr=cdr).astype(bool)]
        return crd

    def get_mask(self, chains=None, cdr=None, original=False):
        &#34;&#34;&#34;Get the mask of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the masks of the specified chains are returned (in the same order);
            otherwise, all masks are concatenated in alphabetical order of the chain IDs
        cdr : {&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;}, optional
            If specified, only the CDR region of the specified type is returned
        original : bool, default False
            If `True`, return the original mask (before interpolation)

        Returns
        -------
        mask : np.ndarray
            Mask array where 1 indicates residues with known coordinates and 0
            indicates missing values

        &#34;&#34;&#34;
        if cdr is not None and self.cdr is None:
            raise ValueError(&#34;CDR information not available&#34;)
        if cdr is not None:
            assert cdr in CDR_REVERSE, f&#34;CDR must be one of {list(CDR_REVERSE.keys())}&#34;
        chains = self._get_chains_list(chains)
        mask = np.concatenate(
            [self.mask_original[c] if original else self.mask[c] for c in chains],
            axis=0,
        )
        if cdr is not None:
            mask = mask[self.cdr == cdr]
        return mask

    def get_cdr(self, chains=None, encode=False):
        &#34;&#34;&#34;Get the CDR information of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the CDR information of the specified chains is
            returned (in the same order); otherwise, all CDR information is concatenated in
            alphabetical order of the chain IDs
        encode : bool, default False
            If `True`, the CDR information is encoded as a `&#39;numpy&#39;` array of
            integers where each integer corresponds to the index of the CDR
            type in `proteinflow.constants.CDR_ALPHABET`

        Returns
        -------
        cdr : np.ndarray or None
            A `&#39;numpy&#39;` array of shape `(L,)` where CDR residues are marked
            with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...) and non-CDR
            residues are marked with `&#39;-&#39;` or an encoded array of integers
            ir `encode=True`; `None` if CDR information is not available
        chains : list of str, optional
            If specified, only the CDR information of the specified chains is
            returned (in the same order); otherwise, all CDR information is concatenated in
            alphabetical order of the chain IDs

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        if self.cdr is None:
            return None
        cdr = np.concatenate([self.cdr[c] for c in chains], axis=0)
        if encode:
            cdr = np.array([CDR_REVERSE[aa] for aa in cdr])
        return cdr

    def get_atom_mask(self, chains=None, cdr=None):
        &#34;&#34;&#34;Get the atom mask of the protein.

        Parameters
        ----------
        chains : str, optional
            If specified, only the atom masks of the specified chains are returned (in the same order);
            otherwise, all atom masks are concatenated in alphabetical order of the chain IDs
        cdr : {&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;}, optional
            If specified, only the CDR region of the specified type is returned

        Returns
        -------
        atom_mask : np.ndarray
            Atom mask array where 1 indicates atoms with known coordinates and 0
            indicates missing or non-existing values, shaped `(L, 14, 3)`

        &#34;&#34;&#34;
        if cdr is not None and self.cdr is None:
            raise ValueError(&#34;CDR information not available&#34;)
        if cdr is not None:
            assert cdr in CDR_REVERSE, f&#34;CDR must be one of {list(CDR_REVERSE.keys())}&#34;
        chains = self._get_chains_list(chains)
        seq = &#34;&#34;.join([self.seq[c] for c in chains])
        atom_mask = np.concatenate([ATOM_MASKS[aa] for aa in seq])
        atom_mask[self.mask == 0] = 0
        if cdr is not None:
            atom_mask = atom_mask[self.cdr == cdr]
        return atom_mask

    @staticmethod
    def decode_cdr(cdr):
        &#34;&#34;&#34;Decode the CDR information.

        Parameters
        ----------
        cdr : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L,)` encoded as integers where each
            integer corresponds to the index of the CDR type in
            `proteinflow.constants.CDR_ALPHABET`

        Returns
        -------
        cdr : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L,)` where CDR residues are marked
            with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...) and non-CDR
            residues are marked with `&#39;-&#39;`

        &#34;&#34;&#34;
        cdr = ProteinEntry._to_numpy(cdr)
        return np.array([CDR_ALPHABET[x] for x in cdr.astype(int)])

    @staticmethod
    def _to_numpy(arr):
        if isinstance(arr, Tensor):
            arr = arr.detach().cpu().numpy()
        if isinstance(arr, list):
            arr = np.array(arr)
        return arr

    @staticmethod
    def decode_sequence(seq):
        &#34;&#34;&#34;Decode the amino acid sequence.

        Parameters
        ----------
        seq : np.ndarray
            A `&#39;numpy&#39;` array of integers where each integer corresponds to the
            index of the amino acid in `proteinflow.constants.ALPHABET`

        Returns
        -------
        seq : str
            Amino acid sequence of the protein (one-letter code)

        &#34;&#34;&#34;
        seq = ProteinEntry._to_numpy(seq)
        return &#34;&#34;.join([ALPHABET[x] for x in seq.astype(int)])

    def _rename_chains(self, chain_dict):
        &#34;&#34;&#34;Rename the chains of the protein (with no safeguards).&#34;&#34;&#34;
        for old_chain, new_chain in chain_dict.items():
            self.seq[new_chain] = self.seq.pop(old_chain)
            self.crd[new_chain] = self.crd.pop(old_chain)
            self.mask[new_chain] = self.mask.pop(old_chain)
            self.mask_original[new_chain] = self.mask_original.pop(old_chain)
            self.cdr[new_chain] = self.cdr.pop(old_chain)
            self.predict_mask[new_chain] = self.predict_mask.pop(old_chain)

    def rename_chains(self, chain_dict):
        &#34;&#34;&#34;Rename the chains of the protein.

        Parameters
        ----------
        chain_dict : dict
            A dictionary mapping old chain IDs to new chain IDs

        &#34;&#34;&#34;
        self._rename_chains({k: k * 5 for k in self.get_chains()})
        self._rename_chains({k * 5: v for k, v in chain_dict.items()})

    def get_predicted_entry(self):
        &#34;&#34;&#34;Return a `ProteinEntry` object that only contains predicted residues.

        Returns
        -------
        entry : ProteinEntry
            The truncated `ProteinEntry` object

        &#34;&#34;&#34;
        if self.predict_mask is None:
            raise ValueError(&#34;Predicted mask not available&#34;)
        entry_dict = self.to_dict()
        for chain in self.get_chains():
            mask_ = self.predict_mask[chain].astype(bool)
            if mask_.sum() == 0:
                entry_dict.pop(chain)
                continue
            if mask_.sum() == len(mask_):
                continue
            seq_arr = np.array(list(entry_dict[chain][&#34;seq&#34;]))
            entry_dict[chain][&#34;seq&#34;] = &#34;&#34;.join(seq_arr[mask_])
            entry_dict[chain][&#34;crd_bb&#34;] = entry_dict[chain][&#34;crd_bb&#34;][mask_]
            entry_dict[chain][&#34;crd_sc&#34;] = entry_dict[chain][&#34;crd_sc&#34;][mask_]
            entry_dict[chain][&#34;msk&#34;] = entry_dict[chain][&#34;msk&#34;][mask_]
            entry_dict[chain][&#34;predict_msk&#34;] = entry_dict[chain][&#34;predict_msk&#34;][mask_]
            if &#34;cdr&#34; in entry_dict[chain]:
                entry_dict[chain][&#34;cdr&#34;] = entry_dict[chain][&#34;cdr&#34;][mask_]
        return ProteinEntry.from_dict(entry_dict)

    def get_predicted_chains(self):
        &#34;&#34;&#34;Return a list of chain IDs that contain predicted residues.

        Returns
        -------
        chains : list of str
            Chain IDs

        &#34;&#34;&#34;
        if not self.has_predict_mask():
            raise ValueError(&#34;Predicted mask not available&#34;)
        return [k for k, v in self.predict_mask.items() if v.sum() != 0]

    def merge(self, entry):
        &#34;&#34;&#34;Merge another `ProteinEntry` object into this one.

        Parameters
        ----------
        entry : ProteinEntry
            The merged `ProteinEntry` object

        &#34;&#34;&#34;
        for chain in entry.get_chains():
            if chain.split(&#34;_&#34;)[0] in {x.split(&#34;_&#34;)[0] for x in self.get_chains()}:
                raise ValueError(&#34;Chain IDs must be unique&#34;)
            self.seq[chain] = entry.seq[chain]
            self.crd[chain] = entry.crd[chain]
            self.mask[chain] = entry.mask[chain]
            self.mask_original[chain] = entry.mask_original[chain]
            self.cdr[chain] = entry.cdr[chain]
            self.predict_mask[chain] = entry.predict_mask[chain]
        if not all([x is None for x in self.predict_mask.values()]):
            for k, v in self.predict_mask.items():
                if v is None:
                    self.predict_mask[k] = np.zeros(len(self.get_sequence(k)))

    @staticmethod
    def from_arrays(
        seqs,
        crds,
        masks,
        chain_id_dict,
        chain_id_array,
        predict_masks=None,
        cdrs=None,
        protein_id=None,
    ):
        &#34;&#34;&#34;Load a protein entry from arrays.

        Parameters
        ----------
        seqs : np.ndarray
            Amino acid sequences of the protein (encoded as integers, see `proteinflow.constants.ALPHABET`), `&#39;numpy&#39;` array of shape `(L,)`
        crds : np.ndarray
            Coordinates of the protein, `&#39;numpy&#39;` array of shape `(L, 14, 3)` or `(L, 4, 3)`
        masks : np.ndarray
            Mask array where 1 indicates residues with known coordinates and 0
            indicates missing values, `&#39;numpy&#39;` array of shape `(L,)`
        chain_id_dict : dict
            A dictionary mapping chain IDs to indices in `chain_id_array`
        chain_id_array : np.ndarray
            A `&#39;numpy&#39;` array of chain IDs encoded as integers
        predict_masks : np.ndarray, optional
            Mask array where 1 indicates residues that were generated by a model and 0
            indicates residues with known coordinates, `&#39;numpy&#39;` array of shape `(L,)`
        cdrs : np.ndarray, optional
            A `&#39;numpy&#39;` array of shape `(L,)` where residues are marked
            with the corresponding CDR type (encoded as integers, see `proteinflow.constants.CDR_ALPHABET`)
        protein_id : str, optional
            Protein ID

        Returns
        -------
        entry : ProteinEntry
            A `ProteinEntry` object

        &#34;&#34;&#34;
        seqs_list = []
        crds_list = []
        masks_list = []
        chain_ids_list = []
        predict_masks_list = None if predict_masks is None else []
        cdrs_list = None if cdrs is None else []
        for chain_id, ind in chain_id_dict.items():
            chain_ids_list.append(chain_id)
            chain_mask = chain_id_array == ind
            seqs_list.append(ProteinEntry.decode_sequence(seqs[chain_mask]))
            if crds.shape[1] != 14:
                crds_ = np.zeros((crds[chain_mask].shape[0], 14, 3))
                crds_[:, :4, :] = ProteinEntry._to_numpy(crds[chain_mask])
            else:
                crds_ = ProteinEntry._to_numpy(crds[chain_mask])
            crds_list.append(crds_)
            masks_list.append(ProteinEntry._to_numpy(masks[chain_mask]))
            if predict_masks is not None:
                predict_masks_list.append(
                    ProteinEntry._to_numpy(predict_masks[chain_mask])
                )
            if cdrs is not None:
                cdrs_list.append(ProteinEntry.decode_cdr(cdrs[chain_mask]))
        return ProteinEntry(
            seqs_list,
            crds_list,
            masks_list,
            chain_ids_list,
            predict_masks_list,
            cdrs_list,
            protein_id,
        )

    @staticmethod
    def from_dict(dictionary):
        &#34;&#34;&#34;Load a protein entry from a dictionary.

        Parameters
        ----------
        dictionary : dict
            A nested dictionary where first-level keys are chain IDs and
            second-level keys are the following:
            - `&#39;seq&#39;` : amino acid sequence (one-letter code)
            - `&#39;crd_bb&#39;` : backbone coordinates, shaped `(L, 4, 3)`
            - `&#39;crd_sc&#39;` : sidechain coordinates, shaped `(L, 10, 3)`
            - `&#39;msk&#39;` : mask array where 1 indicates residues with known coordinates and 0
                indicates missing values, shaped `(L,)`
            - `&#39;cdr&#39;` (optional): CDR information, shaped `(L,)` where CDR residues are marked
                with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...) and non-CDR residues are marked with `&#39;-&#39;`
            - `&#39;predict_msk&#39;` (optional): mask array where 1 indicates residues that were generated by a model and 0
                indicates residues with known coordinates, shaped `(L,)`
            It can also contain a `&#39;protein_id&#39;` first-level key.

        Returns
        -------
        entry : ProteinEntry
            A `ProteinEntry` object

        &#34;&#34;&#34;
        chains = sorted([x for x in dictionary.keys() if x != &#34;protein_id&#34;])
        seq = [dictionary[k][&#34;seq&#34;] for k in chains]
        crd = [
            np.concatenate([dictionary[k][&#34;crd_bb&#34;], dictionary[k][&#34;crd_sc&#34;]], axis=1)
            for k in chains
        ]
        mask = [dictionary[k][&#34;msk&#34;] for k in chains]
        cdr = [dictionary[k].get(&#34;cdr&#34;, None) for k in chains]
        predict_mask = [dictionary[k].get(&#34;predict_msk&#34;, None) for k in chains]
        return ProteinEntry(
            seqs=seq,
            crds=crd,
            masks=mask,
            cdrs=cdr,
            chain_ids=chains,
            predict_masks=predict_mask,
            protein_id=dictionary.get(&#34;protein_id&#34;),
        )

    @staticmethod
    def from_pdb_entry(pdb_entry):
        &#34;&#34;&#34;Load a protein entry from a `PDBEntry` object.

        Parameters
        ----------
        pdb_entry : PDBEntry
            A `PDBEntry` object

        Returns
        -------
        entry : ProteinEntry
            A `ProteinEntry` object

        &#34;&#34;&#34;
        pdb_dict = {}
        fasta_dict = pdb_entry.get_fasta()
        for (chain,) in pdb_entry.get_chains():
            pdb_dict[chain] = {}
            fasta_seq = fasta_dict[chain]

            # align fasta and pdb and check criteria)
            mask = pdb_entry.get_mask([chain])[chain]
            if isinstance(pdb_entry, SAbDabEntry):
                pdb_dict[chain][&#34;cdr&#34;] = pdb_entry.get_cdr([chain])[chain]
            pdb_dict[chain][&#34;seq&#34;] = fasta_seq
            pdb_dict[chain][&#34;msk&#34;] = mask

            # go over rows of coordinates
            crd_arr = pdb_entry.get_coordinates_array(chain)

            pdb_dict[chain][&#34;crd_bb&#34;] = crd_arr[:, :4, :]
            pdb_dict[chain][&#34;crd_sc&#34;] = crd_arr[:, 4:, :]
            pdb_dict[chain][&#34;msk&#34;][
                (pdb_dict[chain][&#34;crd_bb&#34;] == 0).sum(-1).sum(-1) == 4
            ] = 0
        pdb_dict[&#34;protein_id&#34;] = pdb_entry.pdb_id
        return ProteinEntry.from_dict(pdb_dict)

    @staticmethod
    def from_pdb(
        pdb_path,
        fasta_path=None,
        heavy_chain=None,
        light_chain=None,
        antigen_chains=None,
    ):
        &#34;&#34;&#34;Load a protein entry from a PDB file.

        Parameters
        ----------
        pdb_path : str
            Path to the PDB file
        fasta_path : str, optional
            Path to the FASTA file; if not specified, the sequence is extracted
            from the PDB file
        heavy_chain : str, optional
            Chain ID of the heavy chain (to load a SAbDab entry)
        light_chain : str, optional
            Chain ID of the light chain (to load a SAbDab entry)
        antigen_chains : list of str, optional
            Chain IDs of the antigen chains (to load a SAbDab entry)

        Returns
        -------
        entry : ProteinEntry
            A `ProteinEntry` object

        &#34;&#34;&#34;
        if heavy_chain is not None or light_chain is not None:
            pdb_entry = SAbDabEntry(
                pdb_path=pdb_path,
                fasta_path=fasta_path,
                heavy_chain=heavy_chain,
                light_chain=light_chain,
                antigen_chains=antigen_chains,
            )
        else:
            pdb_entry = PDBEntry(pdb_path=pdb_path, fasta_path=fasta_path)
        return ProteinEntry.from_pdb_entry(pdb_entry)

    @staticmethod
    def from_id(
        pdb_id,
        local_folder=&#34;.&#34;,
        heavy_chain=None,
        light_chain=None,
        antigen_chains=None,
    ):
        &#34;&#34;&#34;Load a protein entry from a PDB file.

        Parameters
        ----------
        pdb_id : str
            PDB ID of the protein
        local_folder : str, default &#34;.&#34;
            Path to the local folder where the PDB file is saved
        heavy_chain : str, optional
            Chain ID of the heavy chain (to load a SAbDab entry)
        light_chain : str, optional
            Chain ID of the light chain (to load a SAbDab entry)
        antigen_chains : list of str, optional
            Chain IDs of the antigen chains (to load a SAbDab entry)

        Returns
        -------
        entry : ProteinEntry
            A `ProteinEntry` object

        &#34;&#34;&#34;
        if heavy_chain is not None or light_chain is not None:
            pdb_entry = SAbDabEntry.from_id(
                pdb_id=pdb_id,
                local_folder=local_folder,
                heavy_chain=heavy_chain,
                light_chain=light_chain,
                antigen_chains=antigen_chains,
            )
        else:
            pdb_entry = PDBEntry.from_id(pdb_id=pdb_id)
        return ProteinEntry.from_pdb_entry(pdb_entry)

    @staticmethod
    def from_pickle(path):
        &#34;&#34;&#34;Load a protein entry from a pickle file.

        Parameters
        ----------
        path : str
            Path to the pickle file

        Returns
        -------
        entry : ProteinEntry
            A `ProteinEntry` object

        &#34;&#34;&#34;
        with open(path, &#34;rb&#34;) as f:
            data = pickle.load(f)
        return ProteinEntry.from_dict(data)

    @staticmethod
    def retrieve_ligands_from_pickle(path):
        &#34;&#34;&#34;Retrieve ligands from a pickle file.

        Parameters
        ----------
        path : str
            Path to the pickle file

        Returns
        -------
        chain2ligand : dict
            A dictionary where keys are chain IDs and values are ligand names

        &#34;&#34;&#34;
        with open(path, &#34;rb&#34;) as f:
            data = pickle.load(f)
        chain2ligand = {}
        for chain in data:
            if &#34;ligand&#34; not in data[chain]:
                continue
            chain2ligand[chain] = data[chain][&#34;ligand&#34;]
        return chain2ligand

    def to_dict(self):
        &#34;&#34;&#34;Convert a protein entry into a dictionary.

        Returns
        -------
        dictionary : dict
            A nested dictionary where first-level keys are chain IDs and
            second-level keys are the following:
            - `&#39;seq&#39;` : amino acid sequence (one-letter code)
            - `&#39;crd_bb&#39;` : backbone coordinates, shaped `(L, 4, 3)`
            - `&#39;crd_sc&#39;` : sidechain coordinates, shaped `(L, 10, 3)`
            - `&#39;msk&#39;` : mask array where 1 indicates residues with known coordinates and 0
                indicates missing values, shaped `(L,)`
            - `&#39;cdr&#39;` (optional): CDR information, shaped `(L,)` encoded as integers where each
                integer corresponds to the index of the CDR type in
                `proteinflow.constants.CDR_ALPHABET`
            - `&#39;predict_msk&#39;` (optional): mask array where 1 indicates residues that were generated by a model and 0
                indicates residues with known coordinates, shaped `(L,)`
            It can optionally also contain `protein_id` as a first-level key.

        &#34;&#34;&#34;
        data = {}
        for chain in self.get_chains():
            data[chain] = {
                &#34;seq&#34;: self.seq[chain],
                &#34;crd_bb&#34;: self.crd[chain][:, :4],
                &#34;crd_sc&#34;: self.crd[chain][:, 4:],
                &#34;msk&#34;: self.mask[chain],
            }
            if self.cdr[chain] is not None:
                data[chain][&#34;cdr&#34;] = self.cdr[chain]
            if self.predict_mask[chain] is not None:
                data[chain][&#34;predict_msk&#34;] = self.predict_mask[chain]
        if self.id is not None:
            data[&#34;protein_id&#34;] = self.id
        return data

    def to_pdb(
        self,
        path,
        only_ca=False,
        skip_oxygens=False,
        only_backbone=False,
        title=None,
    ):
        &#34;&#34;&#34;Save the protein entry to a PDB file.

        Parameters
        ----------
        path : str
            Path to the output PDB file
        only_ca : bool, default False
            If `True`, only backbone atoms are saved
        skip_oxygens : bool, default False
            If `True`, oxygen atoms are not saved
        only_backbone : bool, default False
            If `True`, only backbone atoms are saved
        title : str, optional
            Title of the PDB file (by default either the protein id or &#34;Untitled&#34;)

        &#34;&#34;&#34;
        pdb_builder = PDBBuilder(
            self,
            only_ca=only_ca,
            skip_oxygens=skip_oxygens,
            only_backbone=only_backbone,
        )
        if title is None:
            if self.id is not None:
                title = self.id
            else:
                title = &#34;Untitled&#34;
        pdb_builder.save_pdb(path, title=title)

    def to_pickle(self, path):
        &#34;&#34;&#34;Save a protein entry to a pickle file.

        The output files are pickled nested dictionaries where first-level keys are chain Ids and second-level keys are the following:
        - `&#39;crd_bb&#39;`: a `numpy` array of shape `(L, 4, 3)` with backbone atom coordinates (N, C, CA, O),
        - `&#39;crd_sc&#39;`: a `numpy` array of shape `(L, 10, 3)` with sidechain atom coordinates (check `proteinflow.sidechain_order()` for the order of atoms),
        - `&#39;msk&#39;`: a `numpy` array of shape `(L,)` where ones correspond to residues with known coordinates and
            zeros to missing values,
        - `&#39;seq&#39;`: a string of length `L` with residue types.

        In a SAbDab datasets, an additional key is added to the dictionary:
        - `&#39;cdr&#39;`: a `&#39;numpy&#39;` array of shape `(L,)` where CDR residues are marked with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...)
            and non-CDR residues are marked with `&#39;-&#39;`.

        If a prediction mask is available, another additional key is added to the dictionary:
        - `&#39;predict_msk&#39;`: a `numpy` array of shape `(L,)` where ones correspond to residues that were generated by a model and
            zeros to residues with known coordinates.

        Parameters
        ----------
        path : str
            Path to the pickle file

        &#34;&#34;&#34;
        data = self.to_dict()
        with open(path, &#34;wb&#34;) as f:
            pickle.dump(data, f)

    def dihedral_angles(self, chains=None):
        &#34;&#34;&#34;Calculate the backbone dihedral angles (phi, psi) of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the dihedral angles of the specified chains are returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        Returns
        -------
        angles : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L, 2)` with backbone dihedral angles
            (phi, psi) in degrees; missing values are marked with zeros
        chains : list of str, optional
            If specified, only the dihedral angles of the specified chains are returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        &#34;&#34;&#34;
        angles = []
        chains = self._get_chains_list(chains)
        # N, C, Ca, O
        # psi
        for chain in chains:
            chain_angles = []
            crd = self.get_coordinates([chain])
            mask = self.get_mask([chain])
            p = crd[:-1, [0, 2, 1], :]
            p = np.concatenate([p, crd[1:, [0], :]], 1)
            p = np.pad(p, ((0, 1), (0, 0), (0, 0)))
            chain_angles.append(_dihedral_angle(p, mask))
            # phi
            p = crd[:-1, [1], :]
            p = np.concatenate([p, crd[1:, [0, 2, 1]]], 1)
            p = np.pad(p, ((1, 0), (0, 0), (0, 0)))
            chain_angles.append(_dihedral_angle(p, mask))
            angles.append(np.stack(chain_angles, -1))
        angles = np.concatenate(angles, 0)
        return angles

    def secondary_structure(self, chains=None):
        &#34;&#34;&#34;Calculate the secondary structure of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the secondary structure of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        Returns
        -------
        sse : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L, 3)` with secondary structure
            elements encoded as one-hot vectors (alpha-helix, beta-sheet, loop);
            missing values are marked with zeros
        chains : list of str, optional
            If specified, only the secondary structure of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        out = []
        for chain in chains:
            crd = self.get_coordinates([chain])
            sse_map = {&#34;c&#34;: [0, 0, 1], &#34;b&#34;: [0, 1, 0], &#34;a&#34;: [1, 0, 0], &#34;&#34;: [0, 0, 0]}
            sse = _annotate_sse(crd[:, :4])
            out += [sse_map[x] for x in sse]
        sse = np.array(out)
        return sse

    def sidechain_coordinates(self, chains=None):
        &#34;&#34;&#34;Get the sidechain coordinates of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the sidechain coordinates of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        Returns
        -------
        crd : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L, 10, 3)` with sidechain atom
            coordinates (check `proteinflow.sidechain_order()` for the order of
            atoms); missing values are marked with zeros
        chains : list of str, optional
            If specified, only the sidechain coordinates of the specified chains are returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        return self.get_coordinates(chains)[:, 4:, :]

    def chemical_features(self, chains=None):
        &#34;&#34;&#34;Calculate chemical features of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the chemical features of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        Returns
        -------
        features : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L, 4)` with chemical features of the
            protein (hydropathy, volume, charge, polarity, acceptor/donor); missing
            values are marked with zeros
        chains : list of str, optional
            If specified, only the chemical features of the specified chains are returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        seq = &#34;&#34;.join([self.seq[chain] for chain in chains])
        features = np.array([_PMAP(x) for x in seq])
        return features

    def sidechain_orientation(self, chains=None):
        &#34;&#34;&#34;Calculate the (global) sidechain orientation of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the sidechain orientation of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        Returns
        -------
        orientation : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L, 3)` with sidechain orientation
            vectors; missing values are marked with zeros
        chains : list of str, optional
            If specified, only the sidechain orientation of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        crd = self.get_coordinates(chains=chains)
        crd_bb, crd_sc = crd[:, :4, :], crd[:, 4:, :]
        seq = self.get_sequence(chains=chains, encode=True)
        orientation = np.zeros((crd_sc.shape[0], 3))
        for i in range(1, 21):
            if MAIN_ATOM_DICT[i] is not None:
                orientation[seq == i] = (
                    crd_sc[seq == i, MAIN_ATOM_DICT[i], :] - crd_bb[seq == i, 2, :]
                )
            else:
                S_mask = self.seq == i
                orientation[S_mask] = np.random.rand(*orientation[S_mask].shape)
        orientation /= np.expand_dims(np.linalg.norm(orientation, axis=-1), -1) + 1e-7
        return orientation

    @lru_cache()
    def is_valid_pair(self, chain1, chain2, cutoff=10):
        &#34;&#34;&#34;Check if two chains are a valid pair based on the distance between them.

        We consider two chains to be a valid pair if the distance between them is
        smaller than `cutoff` Angstroms. The distance is calculated as the minimum
        distance between any two atoms of the two chains.

        Parameters
        ----------
        chain1 : str
            Chain ID of the first chain
        chain2 : str
            Chain ID of the second chain
        cutoff : int, optional
            Minimum distance between the two chains (in Angstroms)

        Returns
        -------
        valid : bool
            `True` if the two chains are a valid pair, `False` otherwise

        &#34;&#34;&#34;
        margin = cutoff * 3
        assert chain1 in self.get_chains(), f&#34;Chain {chain1} not found&#34;
        assert chain2 in self.get_chains(), f&#34;Chain {chain2} not found&#34;
        X1 = self.get_coordinates(chains=[chain1], only_known=True)
        X2 = self.get_coordinates(chains=[chain2], only_known=True)
        intersect_dim_X1 = []
        intersect_dim_X2 = []
        intersect_X1 = np.zeros(len(X1))
        intersect_X2 = np.zeros(len(X2))
        for dim in range(3):
            min_dim_1 = X1[:, 2, dim].min()
            max_dim_1 = X1[:, 2, dim].max()
            min_dim_2 = X2[:, 2, dim].min()
            max_dim_2 = X2[:, 2, dim].max()
            intersect_dim_X1.append(
                np.where(
                    np.logical_and(
                        X1[:, 2, dim] &gt;= min_dim_2 - margin,
                        X1[:, 2, dim] &lt;= max_dim_2 + margin,
                    )
                )[0]
            )
            intersect_dim_X2.append(
                np.where(
                    np.logical_and(
                        X2[:, 2, dim] &gt;= min_dim_1 - margin,
                        X2[:, 2, dim] &lt;= max_dim_1 + margin,
                    )
                )[0]
            )

        intersect_X1 = np.intersect1d(
            np.intersect1d(intersect_dim_X1[0], intersect_dim_X1[1]),
            intersect_dim_X1[2],
        )
        intersect_X2 = np.intersect1d(
            np.intersect1d(intersect_dim_X2[0], intersect_dim_X2[1]),
            intersect_dim_X2[2],
        )

        not_end_mask1 = np.where((X1[:, 2, :] == 0).sum(-1) != 3)[0]
        not_end_mask2 = np.where((X2[:, 2, :] == 0).sum(-1) != 3)[0]

        intersect_X1 = np.intersect1d(intersect_X1, not_end_mask1)
        intersect_X2 = np.intersect1d(intersect_X2, not_end_mask2)

        diff = X1[intersect_X1, 2, np.newaxis, :] - X2[intersect_X2, 2, :]
        distances = np.sqrt(np.sum(diff**2, axis=2))

        if np.sum(distances &lt; cutoff) &lt; 3:
            return False
        else:
            return True

    def get_index_array(self, chains=None, index_bump=100):
        &#34;&#34;&#34;Get the index array of the protein.

        The index array is a `&#39;numpy&#39;` array of shape `(L,)` with the index of each residue along the chain.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the index array of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs
        index_bump : int, default 0
            If specified, the index is bumped by this number between chains

        Returns
        -------
        index_array : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L,)` with the index of each residue along the chain; if multiple chains
            are specified, the index is bumped by `index_bump` at the beginning of each chain

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        start_value = 0
        start_index = 0
        index_array = np.zeros(self.get_length(chains))
        for chain in chains:
            chain_length = self.get_length([chain])
            index_array[start_index : start_index + chain_length] = np.arange(
                start_value, start_value + chain_length
            )
            start_value += chain_length + index_bump
            start_index += chain_length
        return index_array.astype(int)

    def get_chain_id_dict(self, chains=None):
        &#34;&#34;&#34;Get the dictionary mapping from chain indices to chain IDs.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the chain IDs of the specified chains are returned

        Returns
        -------
        chain_id_dict : dict
            A dictionary mapping from chain indices to chain IDs

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        chain_id_dict = {x: i for i, x in enumerate(self.get_chains()) if x in chains}
        return chain_id_dict

    def get_chain_id_array(self, chains=None, encode=True):
        &#34;&#34;&#34;Get the chain ID array of the protein.

        The chain ID array is a `&#39;numpy&#39;` array of shape `(L,)` with the chain ID of each residue.
        The chain ID is the index of the chain in the alphabetical order of the chain IDs. To get a
        mapping from the index to the chain ID, use `get_chain_id_dict()`.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the chain ID array of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs
        encode : bool, default True
            If True, the chain ID is encoded as an integer; otherwise, the chain ID is the chain ID string

        Returns
        -------
        chain_id_array : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L,)` with the chain ID of each residue

        &#34;&#34;&#34;
        id_dict = self.get_chain_id_dict()
        if encode:
            index_array = np.zeros(self.get_length(chains))
        else:
            index_array = np.empty(self.get_length(chains), dtype=object)
        start_index = 0
        for chain in self._get_chains_list(chains):
            chain_length = self.get_length([chain])
            index_array[start_index : start_index + chain_length] = (
                id_dict[chain] if encode else chain
            )
            start_index += chain_length
        return index_array

    def get_ligand_features(self, ligands, chains=None):
        &#34;&#34;&#34;Get ligand coordinates, smiles, and chain mapping.

        Parameters
        ----------
        ligands : dict
            A dictionary mapping from chain IDs to a list of ligands, where each ligand is a dictionary
        chains : list of str, optional
            If specified, only the ligands of the specified chains are returned (in the same order);
            otherwise, all ligands are concatenated in alphabetical order of the chain IDs

        Returns
        -------
        X_ligands : torch.Tensor
            A `&#39;torch&#39;` tensor of shape `(N, 3)` with the ligand coordinates
        ligand_smiles : str
            A string with the ligand smiles separated by a dot
        ligand_chains : torch.Tensor
            A `&#39;torch&#39;` tensor of shape `(N, 1)` with the chain index of each atom
        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        X_ligands = []
        ligand_smiles = []
        ligand_chains = []
        for chain_i, chain in enumerate(chains):
            all_smiles = &#34;.&#34;.join([x[&#34;smiles&#34;] for x in ligands[chain]])
            ligand_smiles.append(all_smiles)
            x_lig = np.concatenate([x[&#34;X&#34;] for x in ligands[chain]])
            X_ligands.append(x_lig)
            ligand_chains += [[chain_i]] * len(x_lig)
        ligand_smiles = &#34;.&#34;.join(ligand_smiles)
        X_ligands = from_numpy(np.concatenate(X_ligands, 0))
        ligand_chains = Tensor(ligand_chains)
        return (
            X_ligands,
            ligand_smiles,
            ligand_chains,
        )

    def _get_highlight_mask_dict(self, highlight_mask=None):
        &#34;&#34;&#34;Turn mask array into a dictionary.&#34;&#34;&#34;
        chain_arr = self.get_chain_id_array(encode=False)
        mask_arr = self.get_mask().astype(bool)
        highlight_mask_dict = {}
        if highlight_mask is not None:
            chains = self.get_chains()
            for chain in chains:
                chain_mask = chain_arr == chain
                pdb_highlight = highlight_mask[mask_arr &amp; chain_mask]
                highlight_mask_dict[chain] = pdb_highlight
        return highlight_mask_dict

    def _get_atom_dicts(
        self,
        highlight_mask=None,
        style=&#34;cartoon&#34;,
        opacity=1,
        colors=None,
        accent_color=&#34;#D96181&#34;,
    ):
        &#34;&#34;&#34;Get the atom dictionaries of the protein.&#34;&#34;&#34;
        highlight_mask_dict = self._get_highlight_mask_dict(highlight_mask)
        pdb_entry = PDBEntry(self._temp_pdb_file())
        return pdb_entry._get_atom_dicts(
            highlight_mask_dict=highlight_mask_dict,
            style=style,
            opacity=opacity,
            colors=colors,
            accent_color=accent_color,
        )

    def get_predict_mask(self, chains=None, only_known=False):
        &#34;&#34;&#34;Get the prediction mask of the protein.

        The prediction mask is a `&#39;numpy&#39;` array of shape `(L,)` with ones
        corresponding to residues that were generated by a model and zeros to
        residues with known coordinates. If the prediction mask is not available,
        `None` is returned.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the prediction mask of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs
        only_known : bool, default False
            If `True`, only residues with known coordinates are returned

        Returns
        -------
        predict_mask : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L,)` with ones corresponding to residues that were generated by a model and
            zeros to residues with known coordinates

        &#34;&#34;&#34;
        if list(self.predict_mask.values())[0] is None:
            return None
        chains = self._get_chains_list(chains)
        predict_mask = np.concatenate([self.predict_mask[chain] for chain in chains])
        if only_known:
            mask = self.get_mask(chains=chains)
            predict_mask = predict_mask[mask.astype(bool)]
        return predict_mask

    def visualize(
        self,
        highlight_mask=None,
        style=&#34;cartoon&#34;,
        highlight_style=None,
        opacity=1,
        canvas_size=(400, 300),
    ):
        &#34;&#34;&#34;Visualize the protein in a notebook.

        Parameters
        ----------
        highlight_mask : np.ndarray, optional
            A `&#39;numpy&#39;` array of shape `(L,)` with the residues to highlight
            marked with 1 and the rest marked with 0; if not given and
            `self.predict_mask` is not `None`, the predicted residues are highlighted
        style : str, default &#39;cartoon&#39;
            The style of the visualization; one of &#39;cartoon&#39;, &#39;sphere&#39;, &#39;stick&#39;, &#39;line&#39;, &#39;cross&#39;
        highlight_style : str, optional
            The style of the highlighted atoms; one of &#39;cartoon&#39;, &#39;sphere&#39;, &#39;stick&#39;, &#39;line&#39;, &#39;cross&#39;
            (defaults to the same as `style`)
        opacity : float or dict, default 1
            Opacity of the visualization (can be a dictionary mapping from chain IDs to opacity values)
        canvas_size : tuple, default (400, 300)
            Shape of the canvas

        &#34;&#34;&#34;
        if highlight_mask is not None:
            highlight_mask_dict = self._get_highlight_mask_dict(highlight_mask)
        elif list(self.predict_mask.values())[0] is not None:
            highlight_mask_dict = {
                chain: self.predict_mask[chain][self.get_mask([chain]).astype(bool)]
                for chain in self.get_chains()
            }
        else:
            highlight_mask_dict = None
        with tempfile.NamedTemporaryFile(suffix=&#34;.pdb&#34;) as tmp:
            self.to_pdb(tmp.name)
            pdb_entry = PDBEntry(tmp.name)
        pdb_entry.visualize(
            highlight_mask_dict=highlight_mask_dict,
            style=style,
            highlight_style=highlight_style,
            opacity=opacity,
            canvas_size=canvas_size,
        )

    def blosum62_score(self, seq_before, average=True, only_predicted=True):
        &#34;&#34;&#34;Calculate the BLOSUM62 score of the protein.

        Parameters
        ----------
        seq_before : str
            A string with the sequence before the mutation
        average : bool, default True
            If `True`, the score is averaged over the residues; otherwise, the score is summed
        only_predicted : bool, default True
            If `True` and prediction masks are available, only predicted residues are considered

        Returns
        -------
        score : float
            The BLOSUM62 score of the protein

        &#34;&#34;&#34;
        seq_after = self.get_sequence(encode=False)
        if self.predict_mask is not None and only_predicted:
            predict_mask = self.get_predict_mask()
            seq_before = np.array(list(seq_before))[predict_mask.astype(bool)]
            seq_after = np.array(list(seq_after))[predict_mask.astype(bool)]
        score = blosum62_score(seq_before, seq_after)
        if average:
            score /= len(seq_before)
        return score

    def long_repeat_num(self, thr=5):
        &#34;&#34;&#34;Calculate the number of long repeats in the protein.

        Parameters
        ----------
        thr : int, default 5
            The threshold for the minimum length of the repeat

        Returns
        -------
        num : int
            The number of long repeats in the protein

        &#34;&#34;&#34;
        seq = self.get_sequence(encode=False)
        if self.predict_mask is not None:
            predict_mask = self.get_predict_mask()
            seq = np.array(list(seq))[predict_mask.astype(bool)]
        return long_repeat_num(seq, thr=thr)

    def esm_pll(
        self,
        esm_model_name=&#34;esm2_t30_150M_UR50D&#34;,
        esm_model_objects=None,
        average=False,
    ):
        &#34;&#34;&#34;Calculate the ESM PLL score of the protein.

        Parameters
        ----------
        esm_model_name : str, default &#34;esm2_t30_150M_UR50D&#34;
            Name of the ESM-2 model to use
        esm_model_objects : tuple, optional
            Tuple of ESM-2 model, batch converter and tok_to_idx dictionary (if not None, `esm_model_name` will be ignored)
        average : bool, default False
            If `True`, the score is averaged over the residues; otherwise, the score is summed

        Returns
        -------
        score : float
            The ESM PLL score of the protein

        &#34;&#34;&#34;
        chains = self.get_chains()
        chain_sequences = [self.get_sequence(chains=[chain]) for chain in chains]
        if self.predict_mask is not None:
            predict_masks = [
                (self.get_predict_mask(chains=[chain])).astype(float)
                for chain in chains
            ]
        else:
            predict_masks = [np.ones(len(x)) for x in chain_sequences]
        return esm_pll(
            chain_sequences,
            predict_masks,
            esm_model_name=esm_model_name,
            esm_model_objects=esm_model_objects,
            average=average,
        )

    def ablang_pll(self, ablang_model_name=&#34;heavy&#34;, average=False):
        &#34;&#34;&#34;Calculate the AbLang PLL score of the protein.

        Parameters
        ----------
        ablang_model_name : str, default &#34;heavy&#34;
            Name of the AbLang model to use
        average : bool, default False
            If `True`, the score is averaged over the residues; otherwise, the score is summed

        Returns
        -------
        score : float
            The AbLang PLL score of the protein

        &#34;&#34;&#34;
        chains = self.get_predicted_chains()
        chain_sequences = [self.get_sequence(chains=[chain]) for chain in chains]
        if self.predict_mask is not None:
            predict_masks = [
                (self.get_predict_mask(chains=[chain])).astype(float)
                for chain in chains
            ]
        else:
            predict_masks = [np.ones(len(x)) for x in chain_sequences]
        out = sum(
            [
                ablang_pll(
                    sequence,
                    predict_mask,
                    ablang_model_name=ablang_model_name,
                    average=False,
                )
                for sequence, predict_mask in zip(chain_sequences, predict_masks)
            ]
        )
        if average:
            out /= self.get_predict_mask(chains=chains).sum()
        return out

    def accuracy(self, seq_before):
        &#34;&#34;&#34;Calculate the accuracy of the protein.

        Parameters
        ----------
        seq_before : str
            A string with the sequence before the mutation

        Returns
        -------
        score : float
            The accuracy of the protein

        &#34;&#34;&#34;
        seq_after = self.get_sequence(encode=False)
        seq_before = np.array(list(seq_before))
        seq_after = np.array(list(seq_after))
        if self.predict_mask is not None:
            predict_mask = self.get_predict_mask()
            seq_before = seq_before[predict_mask.astype(bool)]
            seq_after = seq_after[predict_mask.astype(bool)]
        return np.mean(seq_before == seq_after)

    def ca_rmsd(self, entry, only_predicted=True):
        &#34;&#34;&#34;Calculate CA RMSD between two proteins.

        Parameters
        ----------
        entry : ProteinEntry
            A `ProteinEntry` object
        only_predicted : bool, default True
            If `True` and prediction masks are available, only predicted residues are considered

        Returns
        -------
        rmsd : float
            The CA RMSD between the two proteins

        &#34;&#34;&#34;
        if only_predicted and not self.has_predict_mask():
            only_predicted = False
        chains = [x for x in self.get_chains() if x in entry.get_chains()]
        structure1 = self.get_coordinates(only_known=True, chains=chains)[:, 2]
        structure2 = entry.get_coordinates(only_known=True, chains=chains)[:, 2]
        if only_predicted:
            mask = self.get_predict_mask(only_known=True, chains=chains).astype(bool)
            structure1 = structure1[mask]
            structure2 = structure2[mask]
        return ca_rmsd(structure1, structure2)

    def tm_score(self, entry, chains=None):
        &#34;&#34;&#34;Calculate TM score between two proteins.

        Parameters
        ----------
        entry : ProteinEntry
            A `ProteinEntry` object
        chains : list of str, optional
            A list of chain IDs to consider

        Returns
        -------
        tm_score : float
            The TM score between the two proteins

        &#34;&#34;&#34;
        structure1 = self.get_coordinates(only_known=True, chains=chains)[:, 2]
        structure2 = entry.get_coordinates(only_known=True, chains=chains)[:, 2]
        sequence1 = self.get_sequence(only_known=True, chains=chains)
        sequence2 = entry.get_sequence(only_known=True, chains=chains)
        return tm_score(structure1, structure2, sequence1, sequence2)

    def _temp_pdb_file(self):
        &#34;&#34;&#34;Save a protein entry to a temporary PDB file.&#34;&#34;&#34;
        with tempfile.NamedTemporaryFile(suffix=&#34;.pdb&#34;, delete=False) as tmp:
            self.to_pdb(tmp.name)
        return tmp.name

    @staticmethod
    def esmfold_metrics(entries, only_antibody=False):
        &#34;&#34;&#34;Calculate ESMFold metrics for a list of entries.

        Parameters
        ----------
        entries : list of ProteinEntry
            A list of `ProteinEntry` objects
        only_antibody : bool, default False
            If `True`, only antibody chains are considered

        Returns
        -------
        plddts_full : list of float
            A list of PLDDT scores averaged over all residues
        plddts_predicted : list of float
            A list of PLDDT scores averaged over predicted residues
        rmsd : list of float
            A list of RMSD values of aligned structures (predicted residues only)
        tm_score : list of float, optional
            A list of TM scores of aligned structures

        &#34;&#34;&#34;
        sequences = []
        chains_list = [
            [
                x
                for x in entry.get_chains()
                if not entry.has_cdr()
                or not only_antibody
                or x not in entry.get_chain_type_dict()[&#34;antigen&#34;]
            ]
            for entry in entries
        ]
        for chains, entry in zip(chains_list, entries):
            sequences.append(
                &#34;:&#34;.join(
                    [
                        entry.get_sequence(chains=[chain], only_known=True)
                        for chain in chains
                    ]
                )
            )
        esmfold_generate(sequences)
        esmfold_paths = [
            os.path.join(&#34;esmfold_output&#34;, f&#34;seq_{i}.pdb&#34;)
            for i in range(len(sequences))
        ]
        plddts_predicted = [
            confidence_from_file(
                path, entry.get_predict_mask(only_known=True, chains=chains)
            )
            for path, entry, chains in zip(esmfold_paths, entries, chains_list)
        ]
        plddts_full = [confidence_from_file(path) for path in esmfold_paths]
        rmsds = []
        tm_scores = []
        for entry, path in zip(entries, esmfold_paths):
            chains = [
                x
                for x in entry.get_chains()
                if not entry.has_cdr()
                or not only_antibody
                or x not in entry.get_chain_type_dict()[&#34;antigen&#34;]
            ]
            esm_entry = ProteinEntry.from_pdb(path)
            chain_rename_dict = {k: v for k, v in zip(string.ascii_uppercase, chains)}
            esm_entry.rename_chains(chain_rename_dict)
            temp_file = entry._temp_pdb_file()
            esm_entry.align_structure(
                reference_pdb_path=temp_file,
                save_pdb_path=path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;,
                chain_ids=entry.get_predicted_chains()
                if entry.has_predict_mask()
                else chains,
            )
            rmsds.append(
                entry.ca_rmsd(
                    ProteinEntry.from_pdb(path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;)
                )
            )
            tm_scores.append(
                entry.tm_score(
                    esm_entry,
                    chains=chains,
                )
            )
        return plddts_full, plddts_predicted, rmsds, tm_scores

    @staticmethod
    def igfold_metrics(entries, use_openmm=False):
        &#34;&#34;&#34;Calculate IgFold metrics for a list of entries.

        Parameters
        ----------
        entries : list of ProteinEntry
            A list of `ProteinEntry` objects
        use_openmm : bool, default False
            Whether to use refinement with OpenMM

        Returns
        -------
        plddts_full : list of float
            A list of PLDDT scores averaged over all residues
        plddts_predicted : list of float
            A list of PLDDT scores averaged over predicted residues
        rmsds : list of float
            A list of RMSD values of aligned structures (predicted residues only)
        tm_scores : list of float
            A list of TM scores of individual chains (self-consistency)

        &#34;&#34;&#34;
        chains_list = [
            [
                x
                for x in entry.get_chains()
                if x not in entry.get_chain_type_dict()[&#34;antigen&#34;]
            ]
            for entry in entries
        ]
        sequences = [
            {
                chain: entry.get_sequence(chains=[chain], only_known=True)
                for chain in chains
            }
            for entry, chains in zip(entries, chains_list)
        ]
        igfold_generate(sequences, use_openmm=use_openmm)
        folder = &#34;igfold_refine_output&#34; if use_openmm else &#34;igfold_output&#34;
        igfold_paths = [
            os.path.join(folder, f&#34;seq_{i}.pdb&#34;) for i in range(len(sequences))
        ]
        prmsds_predicted = [
            confidence_from_file(
                path, entry.get_predict_mask(only_known=True, chains=chains)
            )
            for path, entry, chains in zip(igfold_paths, entries, chains_list)
        ]
        prmsds_full = [confidence_from_file(path) for path in igfold_paths]
        rmsds = []
        tm_scores = []
        for entry, path in zip(entries, igfold_paths):
            igfold_entry = ProteinEntry.from_pdb(path)
            temp_file = entry._temp_pdb_file()
            igfold_entry.align_structure(
                reference_pdb_path=temp_file,
                save_pdb_path=path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;,
                chain_ids=entry.get_predicted_chains(),
            )
            rmsds.append(
                entry.ca_rmsd(
                    ProteinEntry.from_pdb(path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;)
                )
            )
            tm_scores.append(
                entry.tm_score(
                    igfold_entry,
                )
            )
        return prmsds_full, prmsds_predicted, rmsds, tm_scores

    @staticmethod
    def immunebuilder_metrics(entries, protein_type=&#34;antibody&#34;):
        &#34;&#34;&#34;Calculate ImmuneBuilder metrics for a list of entries.

        Parameters
        ----------
        entries : list of ProteinEntry
            A list of `ProteinEntry` objects
        protein_type : {&#34;antibody&#34;, &#34;nanobody&#34;, &#34;tcr&#34;}, default &#34;antibody&#34;
            The type of the protein

        Returns
        -------
        prmsds_full : list of float
            A list of PRMSD scores averaged over all residues
        prmsds_predicted : list of float
            A list of PRMSD scores averaged over predicted residues
        rmsds : list of float
            A list of RMSD values of aligned structures (predicted residues only)
        tm_scores : list of float
            A list of TM scores of aligned structures

        &#34;&#34;&#34;
        sequences = []
        chains_list = [
            [
                x
                for x in entry.get_chains()
                if x not in entry.get_chain_type_dict()[&#34;antigen&#34;]
            ]
            for entry in entries
        ]
        for chains, entry in zip(chains_list, entries):
            chain_type_dict = entry.get_chain_type_dict()
            sequences.append(
                {
                    key[0].upper(): entry.get_sequence(
                        chains=[chain_type_dict[key]], only_known=True
                    )
                    for key in [&#34;heavy&#34;, &#34;light&#34;]
                    if key in chain_type_dict
                }
            )
        immunebuilder_generate(sequences, protein_type=protein_type)
        generated_paths = [
            os.path.join(&#34;immunebuilder_output&#34;, f&#34;seq_{i}.pdb&#34;)
            for i in range(len(sequences))
        ]
        prmsds_predicted = [
            confidence_from_file(
                path, entry.get_predict_mask(only_known=True, chains=chains)
            )
            for path, entry, chains in zip(generated_paths, entries, chains_list)
        ]
        prmsds_full = [confidence_from_file(path) for path in generated_paths]
        rmsds = []
        tm_scores = []
        for entry, path, chains in zip(entries, generated_paths, chains_list):
            generated_entry = ProteinEntry.from_pdb(path)
            chain_type_dict = entry.get_chain_type_dict()
            chain_rename_dict = {}
            if &#34;light&#34; in chain_type_dict:
                chain_rename_dict[&#34;L&#34;] = chain_type_dict[&#34;light&#34;]
            if &#34;heavy&#34; in chain_type_dict:
                chain_rename_dict[&#34;H&#34;] = chain_type_dict[&#34;heavy&#34;]
            generated_entry.rename_chains(chain_rename_dict)
            temp_file = entry._temp_pdb_file()
            generated_entry.align_structure(
                reference_pdb_path=temp_file,
                save_pdb_path=path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;,
                chain_ids=entry.get_predicted_chains(),
            )
            rmsds.append(
                entry.ca_rmsd(
                    ProteinEntry.from_pdb(path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;)
                )
            )
            tm_scores.append(
                entry.tm_score(
                    generated_entry,
                    chains=chains,
                )
            )
        return prmsds_full, prmsds_predicted, rmsds, tm_scores

    def align_structure(self, reference_pdb_path, save_pdb_path, chain_ids=None):
        &#34;&#34;&#34;Aligns the structure to a reference structure using the CA atoms.

        Parameters
        ----------
        reference_pdb_path : str
            Path to the reference structure (in .pdb format)
        save_pdb_path : str
            Path where the aligned structure should be saved (in .pdb format)
        chain_ids : list of str, optional
            If specified, only the chains with the specified IDs are aligned

        &#34;&#34;&#34;
        pdb_parser = Bio.PDB.PDBParser(QUIET=True)

        temp_file = self._temp_pdb_file()
        ref_structure = pdb_parser.get_structure(&#34;reference&#34;, reference_pdb_path)
        sample_structure = pdb_parser.get_structure(&#34;sample&#34;, temp_file)

        ref_model = ref_structure[0]
        sample_model = sample_structure[0]

        ref_atoms = []
        sample_atoms = []

        for ref_chain in ref_model:
            if chain_ids is not None and ref_chain.id not in chain_ids:
                continue
            for ref_res in ref_chain:
                if &#34;CA&#34; in ref_res:
                    ref_atoms.append(ref_res[&#34;CA&#34;])
                elif &#34;C&#34; in ref_res:
                    ref_atoms.append(ref_res[&#34;C&#34;])
                    warnings.warn(
                        &#34;Using a C atom instead of CA for alignment in the reference structure&#34;
                    )

        for sample_chain in sample_model:
            if chain_ids is not None and sample_chain.id not in chain_ids:
                continue
            for sample_res in sample_chain:
                if &#34;CA&#34; in sample_res:
                    sample_atoms.append(sample_res[&#34;CA&#34;])
                elif &#34;C&#34; in sample_res:
                    sample_atoms.append(sample_res[&#34;C&#34;])
                    warnings.warn(
                        &#34;Using a C atom instead of CA for alignment in the sample structure&#34;
                    )

        super_imposer = Bio.PDB.Superimposer()
        super_imposer.set_atoms(ref_atoms, sample_atoms)
        super_imposer.apply(sample_model.get_atoms())

        io = Bio.PDB.PDBIO()
        io.set_structure(sample_structure)
        io.save(save_pdb_path)

    @staticmethod
    @requires_extra(&#34;MDAnalysis&#34;)
    def combine_multiple_frames(files, output_path=&#34;combined.pdb&#34;):
        &#34;&#34;&#34;Combine multiple PDB files into a single multiframe PDB file.

        Parameters
        ----------
        files : list of str
            A list of PDB or proteinflow pickle files
        output_path : str, default &#39;combined.pdb&#39;
            Path to the .pdb output file

        &#34;&#34;&#34;
        with mda.Writer(output_path, multiframe=True) as writer:
            for file in files:
                if file.endswith(&#34;.pickle&#34;):
                    file_ = ProteinEntry.from_pickle(file)._temp_pdb_file()
                else:
                    file_ = file
                u = mda.Universe(file_)
                writer.write(u)

    def set_predict_mask(self, mask_dict):
        &#34;&#34;&#34;Set the predicted mask.

        Parameters
        ----------
        mask_dict : dict
            A dictionary mapping from chain IDs to a `np.ndarray` mask of 0s and 1s of the same length as the chain sequence

        &#34;&#34;&#34;
        for chain in mask_dict:
            if chain not in self.get_chains():
                raise PDBError(&#34;Chain not found&#34;)
            if len(mask_dict[chain]) != self.get_length([chain]):
                raise PDBError(&#34;Mask length does not match sequence length&#34;)
        self.predict_mask = mask_dict

    def apply_mask(self, mask):
        &#34;&#34;&#34;Apply a mask to the protein.

        Parameters
        ----------
        mask : np.ndarray
            A boolean mask of shape `(L,)` where `L` is the length of the protein (the chains are concatenated in alphabetical order)

        Returns
        -------
        entry : ProteinEntry
            A new `ProteinEntry` object

        &#34;&#34;&#34;
        start = 0
        out_dict = {}
        for chain in self.get_chains():
            out_dict[chain] = {}
            chain_mask = mask[start : start + self.get_length([chain])]
            start += self.get_length([chain])
            out_dict[chain][&#34;seq&#34;] = self.decode_sequence(
                self.get_sequence(chains=[chain], encode=True)[chain_mask]
            )
            out_dict[chain][&#34;crd_bb&#34;] = self.get_coordinates(
                chains=[chain], bb_only=True
            )[chain_mask]
            out_dict[chain][&#34;crd_sc&#34;] = self.get_coordinates(chains=[chain])[:, 4:][
                chain_mask
            ]
            out_dict[chain][&#34;msk&#34;] = self.get_mask(chains=[chain])[chain_mask]
            if self.has_cdr():
                out_dict[chain][&#34;cdr&#34;] = self.decode_cdr(
                    self.get_cdr([chain], encode=True)[chain_mask]
                )
            if self.has_predict_mask():
                out_dict[chain][&#34;predict_msk&#34;] = self.predict_mask[chain][chain_mask]
        if self.id is not None:
            out_dict[&#34;protein_id&#34;] = self.id
        return ProteinEntry.from_dict(out_dict)


class PDBEntry:
    &#34;&#34;&#34;A class for parsing PDB entries.&#34;&#34;&#34;

    def __init__(self, pdb_path, fasta_path=None, load_ligand=False):
        &#34;&#34;&#34;Initialize a PDBEntry object.

        If no FASTA path is provided, the sequences will be fully inferred
        from the PDB file.

        Parameters
        ----------
        pdb_path : str
            Path to the PDB file
        fasta_path : str, optional
            Path to the FASTA file

        &#34;&#34;&#34;
        self.pdb_path = pdb_path
        self.fasta_path = fasta_path
        self.pdb_id = os.path.basename(pdb_path).split(&#34;.&#34;)[0].split(&#34;-&#34;)[0]
        self.load_ligand = load_ligand
        if load_ligand:
            self.crd_df, self.seq_df, self.ligands = self._parse_structure()
        else:
            self.crd_df, self.seq_df = self._parse_structure()
        try:
            self.fasta_dict = self._parse_fasta()
        except FileNotFoundError:
            raise PDBError(&#34;FASTA file not found&#34;)

    @staticmethod
    def from_id(pdb_id, local_folder=&#34;.&#34;):
        &#34;&#34;&#34;Initialize a `PDBEntry` object from a PDB Id.

        Downloads the PDB and FASTA files to the local folder.

        Parameters
        ----------
        pdb_id : str
            PDB Id of the protein
        local_folder : str, default &#39;.&#39;
            Folder where the downloaded files will be stored

        Returns
        -------
        entry : PDBEntry
            A `PDBEntry` object

        &#34;&#34;&#34;
        pdb_path = download_pdb(pdb_id, local_folder)
        fasta_path = download_fasta(pdb_id, local_folder)
        return PDBEntry(pdb_path=pdb_path, fasta_path=fasta_path)

    def rename_chains(self, chain_dict):
        &#34;&#34;&#34;Rename chains in the PDB entry.

        Parameters
        ----------
        chain_dict : dict
            A dictionary mapping from old chain IDs to new chain IDs

        Returns
        -------
        entry : PDBEntry
            A `PDBEntry` object

        &#34;&#34;&#34;
        _chain_dict = {chain: chain * 5 for chain in self.get_chains()}
        self.crd_df[&#34;chain_id&#34;] = self.crd_df[&#34;chain_id&#34;].replace(_chain_dict)
        self.seq_df[&#34;chain_id&#34;] = self.seq_df[&#34;chain_id&#34;].replace(_chain_dict)
        self.fasta_dict = {_chain_dict[k]: v for k, v in self.fasta_dict.items()}
        chain_dict = {k * 5: v for k, v in chain_dict.items()}
        self.crd_df[&#34;chain_id&#34;] = self.crd_df[&#34;chain_id&#34;].replace(chain_dict)
        self.seq_df[&#34;chain_id&#34;] = self.seq_df[&#34;chain_id&#34;].replace(chain_dict)
        self.fasta_dict = {chain_dict[k]: v for k, v in self.fasta_dict.items()}
        return self

    def merge(self, entry):
        &#34;&#34;&#34;Merge two PDB entries.

        Parameters
        ----------
        entry : PDBEntry
            A `PDBEntry` object

        Returns
        -------
        entry : PDBEntry
            A `PDBEntry` object

        &#34;&#34;&#34;
        if entry.pdb_id != self.pdb_id:
            self.pdb_id = f&#34;{self.pdb_id}+{entry.pdb_id}&#34;
        for chain in entry.get_chains():
            if chain.split(&#34;_&#34;)[0] in {x.split(&#34;_&#34;)[0] for x in self.get_chains()}:
                raise ValueError(&#34;Chain IDs must be unique&#34;)
        self.crd_df = pd.concat([self.crd_df, entry.crd_df], ignore_index=True)
        self.seq_df = pd.concat([self.seq_df, entry.seq_df], ignore_index=True)
        self.crd_df.loc[:, &#34;atom_number&#34;] = np.arange(len(self.crd_df))
        self.fasta_dict.update(entry.fasta_dict)
        return self

    def _get_relevant_chains(self):
        &#34;&#34;&#34;Get the chains that are included in the entry.&#34;&#34;&#34;
        return list(self.seq_df[&#34;chain_id&#34;].unique())

    @staticmethod
    def parse_fasta(fasta_path):
        &#34;&#34;&#34;Read a fasta file.

        Parameters
        ----------
        fasta_path : str
            Path to the fasta file

        Returns
        -------
        out_dict : dict
            A dictionary containing all the (author) chains in a fasta file (keys)
            and their corresponding sequence (values)

        &#34;&#34;&#34;
        with open(fasta_path) as f:
            lines = np.array(f.readlines())

        indexes = np.array([k for k, l in enumerate(lines) if l[0] == &#34;&gt;&#34;])
        starts = indexes + 1
        ends = list(indexes[1:]) + [len(lines)]
        names = lines[indexes]
        seqs = [&#34;&#34;.join(lines[s:e]).replace(&#34;\n&#34;, &#34;&#34;) for s, e in zip(starts, ends)]

        out_dict = {}
        for name, seq in zip(names, seqs):
            for chain in _retrieve_chain_names(name):
                out_dict[chain] = seq

        return out_dict

    def _parse_fasta(self):
        &#34;&#34;&#34;Parse the fasta file.&#34;&#34;&#34;
        # download fasta and check if it contains only proteins
        chains = self._get_relevant_chains()
        if self.fasta_path is None:
            seqs_dict = {k: self._pdb_sequence(k, suppress_check=True) for k in chains}
        else:
            seqs_dict = self.parse_fasta(self.fasta_path)
        # retrieve sequences that are relevant for this PDB from the fasta file
        seqs_dict = {k.upper(): v for k, v in seqs_dict.items()}
        if all([len(x) == 3 and len(set(list(x))) == 1 for x in seqs_dict.keys()]):
            seqs_dict = {k[0]: v for k, v in seqs_dict.items()}

        if not {x.split(&#34;-&#34;)[0].upper() for x in chains}.issubset(
            set(list(seqs_dict.keys()))
        ):
            raise PDBError(&#34;Some chains in the PDB do not appear in the fasta file&#34;)

        fasta_dict = {k: seqs_dict[k.split(&#34;-&#34;)[0].upper()] for k in chains}
        return fasta_dict

    def _parse_structure(self):
        &#34;&#34;&#34;Parse the structure of the protein.&#34;&#34;&#34;
        cif = self.pdb_path.endswith(&#34;cif.gz&#34;)
        # load coordinates in a nice format
        try:
            with warnings.catch_warnings():
                warnings.simplefilter(&#34;ignore&#34;)
                if cif:
                    p = CustomMmcif().read_mmcif(self.pdb_path).get_model(1)
                else:
                    p = PandasPdb().read_pdb(self.pdb_path).get_model(1)
        except FileNotFoundError:
            raise PDBError(&#34;PDB / mmCIF file downloaded but not found&#34;)
        crd_df = p.df[&#34;ATOM&#34;]
        crd_df = crd_df[crd_df[&#34;record_name&#34;] == &#34;ATOM&#34;].reset_index()
        if &#34;insertion&#34; in crd_df.columns:
            crd_df[&#34;unique_residue_number&#34;] = crd_df.apply(
                lambda row: f&#34;{row[&#39;residue_number&#39;]}_{row[&#39;insertion&#39;]}&#34;, axis=1
            )
        seq_df = p.amino3to1()

        if self.load_ligand:
            chain2ligands = None
            try:
                chain2ligands = _get_ligands(
                    self.pdb_id,
                    p,
                    self.pdb_path,
                )
            except Exception:
                raise PDBError(&#34;Failed to retrieve ligands&#34;)
            return crd_df, seq_df, chain2ligands

        return crd_df, seq_df

    def _get_chain(self, chain):
        &#34;&#34;&#34;Check the chain ID.&#34;&#34;&#34;
        if chain is None:
            return chain
        if chain not in self.get_chains():
            raise PDBError(&#34;Chain not found&#34;)
        return chain

    def get_pdb_df(self, chain=None):
        &#34;&#34;&#34;Return the PDB dataframe.

        If `chain` is provided, only information for this chain is returned.

        Parameters
        ----------
        chain : str, optional
            Chain identifier

        Returns
        -------
        df : pd.DataFrame
            A `BioPandas` style dataframe containing the PDB information

        &#34;&#34;&#34;
        chain = self._get_chain(chain)
        if chain is None:
            return self.crd_df
        else:
            return self.crd_df[self.crd_df[&#34;chain_id&#34;] == chain]

    def get_sequence_df(self, chain=None, suppress_check=False):
        &#34;&#34;&#34;Return the sequence dataframe.

        If `chain` is provided, only information for this chain is returned.

        Parameters
        ----------
        chain : str, optional
            Chain identifier
        suppress_check : bool, default False
            If True, do not check if the chain is in the PDB

        Returns
        -------
        df : pd.DataFrame
            A dataframe containing the sequence and chain information
            (analogous to the `BioPandas.pdb.PandasPdb.amino3to1` method output)

        &#34;&#34;&#34;
        if not suppress_check:
            chain = self._get_chain(chain)
        if chain is None:
            return self.seq_df
        else:
            return self.seq_df[self.seq_df[&#34;chain_id&#34;] == chain]

    def get_fasta(self):
        &#34;&#34;&#34;Return the fasta dictionary.

        Returns
        -------
        fasta_dict : dict
            A dictionary containing all the (author) chains in a fasta file (keys)
            and their corresponding sequence (values)

        &#34;&#34;&#34;
        return self.fasta_dict

    def get_ligands(self):
        &#34;&#34;&#34;Return the ligands dictionary.

        Returns
        -------
        ligands : dict
            A dictionary containing all the chains in a pdb file (keys)
            and their corresponding processed ligands (values)

        &#34;&#34;&#34;
        return self.ligands

    def get_chains(self):
        &#34;&#34;&#34;Return the chains in the PDB.

        Returns
        -------
        chains : list
            A list of chain identifiers

        &#34;&#34;&#34;
        return list(self.fasta_dict.keys())

    @lru_cache()
    def _pdb_sequence(self, chain, suppress_check=False):
        &#34;&#34;&#34;Return the PDB sequence for a given chain ID.&#34;&#34;&#34;
        return &#34;&#34;.join(
            self.get_sequence_df(chain, suppress_check=suppress_check)[&#34;residue_name&#34;]
        )

    @lru_cache()
    def _align_chain(self, chain):
        &#34;&#34;&#34;Align the PDB sequence to the FASTA sequence for a given chain ID.&#34;&#34;&#34;
        chain = self._get_chain(chain)
        pdb_seq = self._pdb_sequence(chain)
        # aligner = PairwiseAligner()
        # aligner.match_score = 2
        # aligner.mismatch_score = -10
        # aligner.open_gap_score = -0.5
        # aligner.extend_gap_score = -0.1
        # aligned_seq, fasta_seq = aligner.align(pdb_seq, fasta[chain])[0]
        aligned_seq, fasta_seq, *_ = pairwise2.align.globalms(
            pdb_seq, self.fasta_dict[chain], 2, -10, -0.5, -0.1
        )[0]
        if &#34;-&#34; in fasta_seq or &#34;&#34;.join([x for x in aligned_seq if x != &#34;-&#34;]) != pdb_seq:
            raise PDBError(&#34;Incorrect alignment&#34;)
        return aligned_seq, fasta_seq

    def get_alignment(self, chains=None):
        &#34;&#34;&#34;Return the alignment between the PDB and the FASTA sequence.

        Parameters
        ----------
        chains : list, optional
            A list of chain identifiers (if not provided, all chains are aligned)

        Returns
        -------
        alignment : dict
            A dictionary containing the aligned sequences for each chain

        &#34;&#34;&#34;
        if chains is None:
            chains = self.chains()
        return {chain: self._align_chain(chain)[0] for chain in chains}

    def get_mask(self, chains=None):
        &#34;&#34;&#34;Return the mask of the alignment between the PDB and the FASTA sequence.

        Parameters
        ----------
        chains : list, optional
            A list of chain identifiers (if not provided, all chains are aligned)

        Returns
        -------
        mask : dict
            A dictionary containing the `np.ndarray` mask for each chain (0 where the
            aligned sequence has gaps and 1 where it does not)

        &#34;&#34;&#34;
        alignment = self.get_alignment(chains)
        return {
            chain: (np.array(list(seq)) != &#34;-&#34;).astype(int)
            for chain, seq in alignment.items()
        }

    def has_unnatural_amino_acids(self, chains=None):
        &#34;&#34;&#34;Check if the PDB contains unnatural amino acids.

        Parameters
        ----------
        chains : list, optional
            A list of chain identifiers (if not provided, all chains are checked)

        Returns
        -------
        bool
            True if the PDB contains unnatural amino acids, False otherwise

        &#34;&#34;&#34;
        if chains is None:
            chains = [None]
        for chain in chains:
            crd = self.get_pdb_df(chain)
            if not crd[&#34;residue_name&#34;].isin(D3TO1.keys()).all():
                return True
        return False

    def get_coordinates_array(self, chain):
        &#34;&#34;&#34;Return the coordinates of the PDB as a numpy array.

        The atom order is the same as in the `ProteinEntry.ATOM_ORDER` dictionary.
        The array has zeros where the mask has zeros and that is where the sequence
        alignment to the FASTA has gaps (unknown coordinates).

        Parameters
        ----------
        chain : str
            Chain identifier

        Returns
        -------
        crd_arr : np.ndarray
            A numpy array of shape (n_residues, 14, 3) containing the coordinates
            of the PDB (zeros where the coordinates are unknown)

        &#34;&#34;&#34;
        chain_crd = self.get_pdb_df(chain)

        # align fasta and pdb and check criteria)
        mask = self.get_mask([chain])[chain]

        # go over rows of coordinates
        crd_arr = np.zeros((len(mask), 14, 3))

        def arr_index(row):
            atom = row[&#34;atom_name&#34;]
            if atom.startswith(&#34;H&#34;) or atom == &#34;OXT&#34;:
                return -1  # ignore hydrogens and OXT
            order = ProteinEntry.ATOM_ORDER[row[&#34;residue_name&#34;]]
            try:
                return order.index(atom)
            except ValueError:
                raise PDBError(f&#34;Unexpected atoms ({atom})&#34;)

        indices = chain_crd.apply(arr_index, axis=1)
        indices = indices.astype(int)
        informative_mask = indices != -1
        res_indices = np.where(mask == 1)[0]
        unique_numbers = self.get_unique_residue_numbers(chain)
        pdb_seq = self._pdb_sequence(chain)
        if len(unique_numbers) != len(pdb_seq):
            raise PDBError(&#34;Inconsistencies in the biopandas dataframe&#34;)
        replace_dict = {x: y for x, y in zip(unique_numbers, res_indices)}
        chain_crd.loc[:, &#34;unique_residue_number&#34;] = chain_crd[
            &#34;unique_residue_number&#34;
        ].replace(replace_dict)
        crd_arr[
            chain_crd[informative_mask][&#34;unique_residue_number&#34;].astype(int),
            indices[informative_mask],
        ] = chain_crd[informative_mask][[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
        return crd_arr

    def get_unique_residue_numbers(self, chain):
        &#34;&#34;&#34;Return the unique residue numbers (residue number + insertion code).

        Parameters
        ----------
        chain : str
            Chain identifier

        Returns
        -------
        unique_numbers : list
            A list of unique residue numbers

        &#34;&#34;&#34;
        return self.get_pdb_df(chain)[&#34;unique_residue_number&#34;].unique().tolist()

    def _get_atom_dicts(
        self,
        highlight_mask_dict=None,
        style=&#34;cartoon&#34;,
        highlight_style=None,
        opacity=1,
        colors=None,
        accent_color=&#34;#D96181&#34;,
    ):
        &#34;&#34;&#34;Get the atom dictionaries for visualization.&#34;&#34;&#34;
        assert style in [&#34;cartoon&#34;, &#34;sphere&#34;, &#34;stick&#34;, &#34;line&#34;, &#34;cross&#34;]
        if highlight_style is None:
            highlight_style = style
        assert highlight_style in [&#34;cartoon&#34;, &#34;sphere&#34;, &#34;stick&#34;, &#34;line&#34;, &#34;cross&#34;]
        outstr = []
        df_ = self.crd_df.sort_values([&#34;chain_id&#34;, &#34;residue_number&#34;], inplace=False)
        for _, row in df_.iterrows():
            outstr.append(_Atom(row))
        chains = self.get_chains()
        if colors is None:
            colors = COLORS
        colors = {ch: colors[i % len(colors)] for i, ch in enumerate(chains)}
        chain_counters = defaultdict(int)
        chain_last_res = defaultdict(lambda: None)
        if highlight_mask_dict is not None:
            for chain, mask in highlight_mask_dict.items():
                if chain in self.get_chains():
                    assert len(mask) == len(
                        self._pdb_sequence(chain)
                    ), &#34;Mask length does not match sequence length&#34;
        for at in outstr:
            if isinstance(opacity, dict):
                op_ = opacity[at[&#34;chain&#34;]]
            else:
                op_ = opacity
            if at[&#34;resid&#34;] != chain_last_res[at[&#34;chain&#34;]]:
                chain_last_res[at[&#34;chain&#34;]] = at[&#34;resid&#34;]
                chain_counters[at[&#34;chain&#34;]] += 1
            at[&#34;pymol&#34;] = {style: {&#34;color&#34;: colors[at[&#34;chain&#34;]], &#34;opacity&#34;: op_}}
            if highlight_mask_dict is not None and at[&#34;chain&#34;] in highlight_mask_dict:
                num = chain_counters[at[&#34;chain&#34;]]
                if (
                    highlight_mask_dict[at[&#34;chain&#34;]][num - 1] == 1
                    and accent_color is not None
                ):
                    at[&#34;pymol&#34;] = {
                        highlight_style: {&#34;color&#34;: accent_color, &#34;opacity&#34;: op_}
                    }
        return outstr

    def visualize(
        self,
        highlight_mask_dict=None,
        style=&#34;cartoon&#34;,
        highlight_style=None,
        opacity=1,
        colors=None,
        accent_color=&#34;#D96181&#34;,
        canvas_size=(400, 300),
    ):
        &#34;&#34;&#34;Visualize the protein in a notebook.

        Parameters
        ----------
        highlight_mask_dict : dict, optional
            A dictionary mapping from chain IDs to a mask of 0s and 1s of the same length as the chain sequence;
            the atoms corresponding to 1s will be highlighted in red
        style : str, default &#39;cartoon&#39;
            The style of the visualization; one of &#39;cartoon&#39;, &#39;sphere&#39;, &#39;stick&#39;, &#39;line&#39;, &#39;cross&#39;
        highlight_style : str, optional
            The style of the highlighted atoms; one of &#39;cartoon&#39;, &#39;sphere&#39;, &#39;stick&#39;, &#39;line&#39;, &#39;cross&#39;
            (defaults to the same as `style`)
        opacity : float or dict, default 1
            Opacity of the visualization (can be a dictionary mapping from chain IDs to opacity values)
        colors : list, optional
            A list of colors to use for different chains
        accent_color : str, optional
            The color of the highlighted atoms (use `None` to disable highlighting)
        canvas_size : tuple, default (400, 300)
            The shape of the canvas

        &#34;&#34;&#34;
        outstr = self._get_atom_dicts(
            highlight_mask_dict,
            style=style,
            highlight_style=highlight_style,
            opacity=opacity,
            colors=colors,
            accent_color=accent_color,
        )
        vis_string = &#34;&#34;.join([str(x) for x in outstr])
        view = _get_view(canvas_size)
        view.addModelsAsFrames(vis_string)
        for i, at in enumerate(outstr):
            view.setStyle(
                {&#34;model&#34;: -1, &#34;serial&#34;: i + 1},
                at[&#34;pymol&#34;],
            )
        view.zoomTo()
        view.show()


class SAbDabEntry(PDBEntry):
    &#34;&#34;&#34;A class for parsing SAbDab entries.&#34;&#34;&#34;

    def __init__(
        self,
        pdb_path,
        fasta_path,
        heavy_chain=None,
        light_chain=None,
        antigen_chains=None,
    ):
        &#34;&#34;&#34;Initialize the SAbDabEntry.

        Parameters
        ----------
        pdb_path : str
            Path to the PDB file
        fasta_path : str
            Path to the FASTA file
        heavy_chain : str, optional
            Heavy chain identifier (author chain name)
        light_chain : str, optional
            Light chain identifier (author chain name)
        antigen_chains : list, optional
            List of antigen chain identifiers (author chain names)

        &#34;&#34;&#34;
        if heavy_chain is None and light_chain is None:
            raise PDBError(&#34;At least one chain must be provided&#34;)
        self.chain_dict = {
            &#34;heavy&#34;: heavy_chain,
            &#34;light&#34;: light_chain,
        }
        if antigen_chains is None:
            antigen_chains = []
        self.chain_dict[&#34;antigen&#34;] = antigen_chains
        self.reverse_chain_dict = {
            heavy_chain: &#34;heavy&#34;,
            light_chain: &#34;light&#34;,
        }
        for antigen_chain in antigen_chains:
            self.reverse_chain_dict[antigen_chain] = &#34;antigen&#34;
        super().__init__(pdb_path, fasta_path)

    def _get_relevant_chains(self):
        &#34;&#34;&#34;Get the chains that are included in the entry.&#34;&#34;&#34;
        chains = []
        if self.chain_dict[&#34;heavy&#34;] is not None:
            chains.append(self.chain_dict[&#34;heavy&#34;])
        if self.chain_dict[&#34;light&#34;] is not None:
            chains.append(self.chain_dict[&#34;light&#34;])
        chains.extend(self.chain_dict[&#34;antigen&#34;])
        return chains

    @staticmethod
    def from_id(
        pdb_id,
        local_folder=&#34;.&#34;,
        light_chain=None,
        heavy_chain=None,
        antigen_chains=None,
    ):
        &#34;&#34;&#34;Create a SAbDabEntry from a PDB ID.

        Either the light or the heavy chain must be provided.

        Parameters
        ----------
        pdb_id : str
            PDB ID
        local_folder : str, optional
            Local folder to download the PDB and FASTA files
        light_chain : str, optional
            Light chain identifier (author chain name)
        heavy_chain : str, optional
            Heavy chain identifier (author chain name)
        antigen_chains : list, optional
            List of antigen chain identifiers (author chain names)

        Returns
        -------
        entry : SAbDabEntry
            A SAbDabEntry object

        &#34;&#34;&#34;
        pdb_path = download_pdb(pdb_id, local_folder, sabdab=True)
        fasta_path = download_fasta(pdb_id, local_folder)
        return SAbDabEntry(
            pdb_path=pdb_path,
            fasta_path=fasta_path,
            light_chain=light_chain,
            heavy_chain=heavy_chain,
            antigen_chains=antigen_chains,
        )

    def _get_chain(self, chain):
        &#34;&#34;&#34;Return the chain identifier.&#34;&#34;&#34;
        if chain in [&#34;heavy&#34;, &#34;light&#34;]:
            chain = self.chain_dict[chain]
        return super()._get_chain(chain)

    def heavy_chain(self):
        &#34;&#34;&#34;Return the heavy chain identifier.

        Returns
        -------
        chain : str
            The heavy chain identifier

        &#34;&#34;&#34;
        return self.chain_dict[&#34;heavy&#34;]

    def light_chain(self):
        &#34;&#34;&#34;Return the light chain identifier.

        Returns
        -------
        chain : str
            The light chain identifier

        &#34;&#34;&#34;
        return self.chain_dict[&#34;light&#34;]

    def antigen_chains(self):
        &#34;&#34;&#34;Return the antigen chain identifiers.

        Returns
        -------
        chains : list
            The antigen chain identifiers

        &#34;&#34;&#34;
        return self.chain_dict[&#34;antigen&#34;]

    def chains(self):
        &#34;&#34;&#34;Return the chains in the PDB.

        Returns
        -------
        chains : list
            A list of chain identifiers

        &#34;&#34;&#34;
        return [self.heavy_chain(), self.light_chain()] + self.antigen_chains()

    def chain_type(self, chain):
        &#34;&#34;&#34;Return the type of a chain.

        Parameters
        ----------
        chain : str
            Chain identifier

        Returns
        -------
        chain_type : str
            The type of the chain (heavy, light or antigen)

        &#34;&#34;&#34;
        if chain in self.reverse_chain_dict:
            return self.reverse_chain_dict[chain]
        raise PDBError(&#34;Chain not found&#34;)

    @lru_cache()
    def _get_chain_cdr(self, chain, align_to_fasta=True):
        &#34;&#34;&#34;Return the CDRs for a given chain ID.&#34;&#34;&#34;
        chain = self._get_chain(chain)
        chain_crd = self.get_pdb_df(chain)
        chain_type = self.chain_type(chain)[0].upper()
        pdb_seq = self._pdb_sequence(chain)
        unique_numbers = chain_crd[&#34;unique_residue_number&#34;].unique()
        if len(unique_numbers) != len(pdb_seq):
            raise PDBError(&#34;Inconsistencies in the biopandas dataframe&#34;)
        if chain_type in [&#34;H&#34;, &#34;L&#34;]:
            cdr_arr = [
                CDR_VALUES[chain_type][int(x.split(&#34;_&#34;)[0])] for x in unique_numbers
            ]
            cdr_arr = np.array(cdr_arr)
        else:
            cdr_arr = np.array([&#34;-&#34;] * len(unique_numbers), dtype=object)
        if align_to_fasta:
            aligned_seq, _ = self._align_chain(chain)
            aligned_seq_arr = np.array(list(aligned_seq))
            cdr_arr_aligned = np.array([&#34;-&#34;] * len(aligned_seq), dtype=object)
            cdr_arr_aligned[aligned_seq_arr != &#34;-&#34;] = cdr_arr
            cdr_arr = cdr_arr_aligned
        return cdr_arr

    def get_cdr(self, chains=None):
        &#34;&#34;&#34;Return CDR arrays.

        Parameters
        ----------
        chains : list, optional
            A list of chain identifiers (if not provided, all chains are processed)

        Returns
        -------
        cdrs : dict
            A dictionary containing the CDR arrays for each of the chains

        &#34;&#34;&#34;
        if chains is None:
            chains = self.chains()
        return {chain: self._get_chain_cdr(chain) for chain in chains}</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="proteinflow.data.torch" href="torch.html">proteinflow.data.torch</a></code></dt>
<dd>
<div class="desc"><p>Subclasses of <code>torch.utils.data.Dataset</code> and <code>torch.utils.data.DataLoader</code> that are tuned for loading proteinflow data.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="proteinflow.data.interpolate_coords"><code class="name flex">
<span>def <span class="ident">interpolate_coords</span></span>(<span>crd, mask, fill_ends=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill in missing values in a coordinates array with linear interpolation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>crd</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Coordinates array of shape <code>(L, 4, 3)</code></dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Mask array of shape <code>(L,)</code> where 1 indicates residues with known coordinates and 0
indicates missing values</dd>
<dt><strong><code>fill_ends</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If <code>True</code>, fill in missing values at the ends of the protein sequence with the edge values;
otherwise fill them in with zeros</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>crd</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Interpolated coordinates array of shape <code>(L, 4, 3)</code></dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Interpolated mask array of shape <code>(L,)</code> where 1 indicates residues with known or interpolated
coordinates and 0 indicates missing values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_coords(crd, mask, fill_ends=True):
    &#34;&#34;&#34;Fill in missing values in a coordinates array with linear interpolation.

    Parameters
    ----------
    crd : np.ndarray
        Coordinates array of shape `(L, 4, 3)`
    mask : np.ndarray
        Mask array of shape `(L,)` where 1 indicates residues with known coordinates and 0
        indicates missing values
    fill_ends : bool, default True
        If `True`, fill in missing values at the ends of the protein sequence with the edge values;
        otherwise fill them in with zeros

    Returns
    -------
    crd : np.ndarray
        Interpolated coordinates array of shape `(L, 4, 3)`
    mask : np.ndarray
        Interpolated mask array of shape `(L,)` where 1 indicates residues with known or interpolated
        coordinates and 0 indicates missing values

    &#34;&#34;&#34;
    crd[(1 - mask).astype(bool)] = np.nan
    df = pd.DataFrame(crd.reshape((crd.shape[0], -1)))
    crd = df.interpolate(limit_area=&#34;inside&#34; if not fill_ends else None).values.reshape(
        crd.shape
    )
    if not fill_ends:
        nan_mask = np.isnan(crd)  # in the middle the nans have been interpolated
        interpolated_mask = np.zeros_like(mask)
        interpolated_mask[~np.isnan(crd[:, 0, 0])] = 1
        crd[nan_mask] = 0
    else:
        interpolated_mask = np.ones_like(crd[:, :, 0])
    return crd, mask</code></pre>
</details>
</dd>
<dt id="proteinflow.data.lru_cache"><code class="name flex">
<span>def <span class="ident">lru_cache</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a dummy decorator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lru_cache():
    &#34;&#34;&#34;Make a dummy decorator.&#34;&#34;&#34;

    def wrapper(func):
        return func

    return wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="proteinflow.data.PDBEntry"><code class="flex name class">
<span>class <span class="ident">PDBEntry</span></span>
<span>(</span><span>pdb_path, fasta_path=None, load_ligand=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for parsing PDB entries.</p>
<p>Initialize a PDBEntry object.</p>
<p>If no FASTA path is provided, the sequences will be fully inferred
from the PDB file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pdb_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the PDB file</dd>
<dt><strong><code>fasta_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path to the FASTA file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PDBEntry:
    &#34;&#34;&#34;A class for parsing PDB entries.&#34;&#34;&#34;

    def __init__(self, pdb_path, fasta_path=None, load_ligand=False):
        &#34;&#34;&#34;Initialize a PDBEntry object.

        If no FASTA path is provided, the sequences will be fully inferred
        from the PDB file.

        Parameters
        ----------
        pdb_path : str
            Path to the PDB file
        fasta_path : str, optional
            Path to the FASTA file

        &#34;&#34;&#34;
        self.pdb_path = pdb_path
        self.fasta_path = fasta_path
        self.pdb_id = os.path.basename(pdb_path).split(&#34;.&#34;)[0].split(&#34;-&#34;)[0]
        self.load_ligand = load_ligand
        if load_ligand:
            self.crd_df, self.seq_df, self.ligands = self._parse_structure()
        else:
            self.crd_df, self.seq_df = self._parse_structure()
        try:
            self.fasta_dict = self._parse_fasta()
        except FileNotFoundError:
            raise PDBError(&#34;FASTA file not found&#34;)

    @staticmethod
    def from_id(pdb_id, local_folder=&#34;.&#34;):
        &#34;&#34;&#34;Initialize a `PDBEntry` object from a PDB Id.

        Downloads the PDB and FASTA files to the local folder.

        Parameters
        ----------
        pdb_id : str
            PDB Id of the protein
        local_folder : str, default &#39;.&#39;
            Folder where the downloaded files will be stored

        Returns
        -------
        entry : PDBEntry
            A `PDBEntry` object

        &#34;&#34;&#34;
        pdb_path = download_pdb(pdb_id, local_folder)
        fasta_path = download_fasta(pdb_id, local_folder)
        return PDBEntry(pdb_path=pdb_path, fasta_path=fasta_path)

    def rename_chains(self, chain_dict):
        &#34;&#34;&#34;Rename chains in the PDB entry.

        Parameters
        ----------
        chain_dict : dict
            A dictionary mapping from old chain IDs to new chain IDs

        Returns
        -------
        entry : PDBEntry
            A `PDBEntry` object

        &#34;&#34;&#34;
        _chain_dict = {chain: chain * 5 for chain in self.get_chains()}
        self.crd_df[&#34;chain_id&#34;] = self.crd_df[&#34;chain_id&#34;].replace(_chain_dict)
        self.seq_df[&#34;chain_id&#34;] = self.seq_df[&#34;chain_id&#34;].replace(_chain_dict)
        self.fasta_dict = {_chain_dict[k]: v for k, v in self.fasta_dict.items()}
        chain_dict = {k * 5: v for k, v in chain_dict.items()}
        self.crd_df[&#34;chain_id&#34;] = self.crd_df[&#34;chain_id&#34;].replace(chain_dict)
        self.seq_df[&#34;chain_id&#34;] = self.seq_df[&#34;chain_id&#34;].replace(chain_dict)
        self.fasta_dict = {chain_dict[k]: v for k, v in self.fasta_dict.items()}
        return self

    def merge(self, entry):
        &#34;&#34;&#34;Merge two PDB entries.

        Parameters
        ----------
        entry : PDBEntry
            A `PDBEntry` object

        Returns
        -------
        entry : PDBEntry
            A `PDBEntry` object

        &#34;&#34;&#34;
        if entry.pdb_id != self.pdb_id:
            self.pdb_id = f&#34;{self.pdb_id}+{entry.pdb_id}&#34;
        for chain in entry.get_chains():
            if chain.split(&#34;_&#34;)[0] in {x.split(&#34;_&#34;)[0] for x in self.get_chains()}:
                raise ValueError(&#34;Chain IDs must be unique&#34;)
        self.crd_df = pd.concat([self.crd_df, entry.crd_df], ignore_index=True)
        self.seq_df = pd.concat([self.seq_df, entry.seq_df], ignore_index=True)
        self.crd_df.loc[:, &#34;atom_number&#34;] = np.arange(len(self.crd_df))
        self.fasta_dict.update(entry.fasta_dict)
        return self

    def _get_relevant_chains(self):
        &#34;&#34;&#34;Get the chains that are included in the entry.&#34;&#34;&#34;
        return list(self.seq_df[&#34;chain_id&#34;].unique())

    @staticmethod
    def parse_fasta(fasta_path):
        &#34;&#34;&#34;Read a fasta file.

        Parameters
        ----------
        fasta_path : str
            Path to the fasta file

        Returns
        -------
        out_dict : dict
            A dictionary containing all the (author) chains in a fasta file (keys)
            and their corresponding sequence (values)

        &#34;&#34;&#34;
        with open(fasta_path) as f:
            lines = np.array(f.readlines())

        indexes = np.array([k for k, l in enumerate(lines) if l[0] == &#34;&gt;&#34;])
        starts = indexes + 1
        ends = list(indexes[1:]) + [len(lines)]
        names = lines[indexes]
        seqs = [&#34;&#34;.join(lines[s:e]).replace(&#34;\n&#34;, &#34;&#34;) for s, e in zip(starts, ends)]

        out_dict = {}
        for name, seq in zip(names, seqs):
            for chain in _retrieve_chain_names(name):
                out_dict[chain] = seq

        return out_dict

    def _parse_fasta(self):
        &#34;&#34;&#34;Parse the fasta file.&#34;&#34;&#34;
        # download fasta and check if it contains only proteins
        chains = self._get_relevant_chains()
        if self.fasta_path is None:
            seqs_dict = {k: self._pdb_sequence(k, suppress_check=True) for k in chains}
        else:
            seqs_dict = self.parse_fasta(self.fasta_path)
        # retrieve sequences that are relevant for this PDB from the fasta file
        seqs_dict = {k.upper(): v for k, v in seqs_dict.items()}
        if all([len(x) == 3 and len(set(list(x))) == 1 for x in seqs_dict.keys()]):
            seqs_dict = {k[0]: v for k, v in seqs_dict.items()}

        if not {x.split(&#34;-&#34;)[0].upper() for x in chains}.issubset(
            set(list(seqs_dict.keys()))
        ):
            raise PDBError(&#34;Some chains in the PDB do not appear in the fasta file&#34;)

        fasta_dict = {k: seqs_dict[k.split(&#34;-&#34;)[0].upper()] for k in chains}
        return fasta_dict

    def _parse_structure(self):
        &#34;&#34;&#34;Parse the structure of the protein.&#34;&#34;&#34;
        cif = self.pdb_path.endswith(&#34;cif.gz&#34;)
        # load coordinates in a nice format
        try:
            with warnings.catch_warnings():
                warnings.simplefilter(&#34;ignore&#34;)
                if cif:
                    p = CustomMmcif().read_mmcif(self.pdb_path).get_model(1)
                else:
                    p = PandasPdb().read_pdb(self.pdb_path).get_model(1)
        except FileNotFoundError:
            raise PDBError(&#34;PDB / mmCIF file downloaded but not found&#34;)
        crd_df = p.df[&#34;ATOM&#34;]
        crd_df = crd_df[crd_df[&#34;record_name&#34;] == &#34;ATOM&#34;].reset_index()
        if &#34;insertion&#34; in crd_df.columns:
            crd_df[&#34;unique_residue_number&#34;] = crd_df.apply(
                lambda row: f&#34;{row[&#39;residue_number&#39;]}_{row[&#39;insertion&#39;]}&#34;, axis=1
            )
        seq_df = p.amino3to1()

        if self.load_ligand:
            chain2ligands = None
            try:
                chain2ligands = _get_ligands(
                    self.pdb_id,
                    p,
                    self.pdb_path,
                )
            except Exception:
                raise PDBError(&#34;Failed to retrieve ligands&#34;)
            return crd_df, seq_df, chain2ligands

        return crd_df, seq_df

    def _get_chain(self, chain):
        &#34;&#34;&#34;Check the chain ID.&#34;&#34;&#34;
        if chain is None:
            return chain
        if chain not in self.get_chains():
            raise PDBError(&#34;Chain not found&#34;)
        return chain

    def get_pdb_df(self, chain=None):
        &#34;&#34;&#34;Return the PDB dataframe.

        If `chain` is provided, only information for this chain is returned.

        Parameters
        ----------
        chain : str, optional
            Chain identifier

        Returns
        -------
        df : pd.DataFrame
            A `BioPandas` style dataframe containing the PDB information

        &#34;&#34;&#34;
        chain = self._get_chain(chain)
        if chain is None:
            return self.crd_df
        else:
            return self.crd_df[self.crd_df[&#34;chain_id&#34;] == chain]

    def get_sequence_df(self, chain=None, suppress_check=False):
        &#34;&#34;&#34;Return the sequence dataframe.

        If `chain` is provided, only information for this chain is returned.

        Parameters
        ----------
        chain : str, optional
            Chain identifier
        suppress_check : bool, default False
            If True, do not check if the chain is in the PDB

        Returns
        -------
        df : pd.DataFrame
            A dataframe containing the sequence and chain information
            (analogous to the `BioPandas.pdb.PandasPdb.amino3to1` method output)

        &#34;&#34;&#34;
        if not suppress_check:
            chain = self._get_chain(chain)
        if chain is None:
            return self.seq_df
        else:
            return self.seq_df[self.seq_df[&#34;chain_id&#34;] == chain]

    def get_fasta(self):
        &#34;&#34;&#34;Return the fasta dictionary.

        Returns
        -------
        fasta_dict : dict
            A dictionary containing all the (author) chains in a fasta file (keys)
            and their corresponding sequence (values)

        &#34;&#34;&#34;
        return self.fasta_dict

    def get_ligands(self):
        &#34;&#34;&#34;Return the ligands dictionary.

        Returns
        -------
        ligands : dict
            A dictionary containing all the chains in a pdb file (keys)
            and their corresponding processed ligands (values)

        &#34;&#34;&#34;
        return self.ligands

    def get_chains(self):
        &#34;&#34;&#34;Return the chains in the PDB.

        Returns
        -------
        chains : list
            A list of chain identifiers

        &#34;&#34;&#34;
        return list(self.fasta_dict.keys())

    @lru_cache()
    def _pdb_sequence(self, chain, suppress_check=False):
        &#34;&#34;&#34;Return the PDB sequence for a given chain ID.&#34;&#34;&#34;
        return &#34;&#34;.join(
            self.get_sequence_df(chain, suppress_check=suppress_check)[&#34;residue_name&#34;]
        )

    @lru_cache()
    def _align_chain(self, chain):
        &#34;&#34;&#34;Align the PDB sequence to the FASTA sequence for a given chain ID.&#34;&#34;&#34;
        chain = self._get_chain(chain)
        pdb_seq = self._pdb_sequence(chain)
        # aligner = PairwiseAligner()
        # aligner.match_score = 2
        # aligner.mismatch_score = -10
        # aligner.open_gap_score = -0.5
        # aligner.extend_gap_score = -0.1
        # aligned_seq, fasta_seq = aligner.align(pdb_seq, fasta[chain])[0]
        aligned_seq, fasta_seq, *_ = pairwise2.align.globalms(
            pdb_seq, self.fasta_dict[chain], 2, -10, -0.5, -0.1
        )[0]
        if &#34;-&#34; in fasta_seq or &#34;&#34;.join([x for x in aligned_seq if x != &#34;-&#34;]) != pdb_seq:
            raise PDBError(&#34;Incorrect alignment&#34;)
        return aligned_seq, fasta_seq

    def get_alignment(self, chains=None):
        &#34;&#34;&#34;Return the alignment between the PDB and the FASTA sequence.

        Parameters
        ----------
        chains : list, optional
            A list of chain identifiers (if not provided, all chains are aligned)

        Returns
        -------
        alignment : dict
            A dictionary containing the aligned sequences for each chain

        &#34;&#34;&#34;
        if chains is None:
            chains = self.chains()
        return {chain: self._align_chain(chain)[0] for chain in chains}

    def get_mask(self, chains=None):
        &#34;&#34;&#34;Return the mask of the alignment between the PDB and the FASTA sequence.

        Parameters
        ----------
        chains : list, optional
            A list of chain identifiers (if not provided, all chains are aligned)

        Returns
        -------
        mask : dict
            A dictionary containing the `np.ndarray` mask for each chain (0 where the
            aligned sequence has gaps and 1 where it does not)

        &#34;&#34;&#34;
        alignment = self.get_alignment(chains)
        return {
            chain: (np.array(list(seq)) != &#34;-&#34;).astype(int)
            for chain, seq in alignment.items()
        }

    def has_unnatural_amino_acids(self, chains=None):
        &#34;&#34;&#34;Check if the PDB contains unnatural amino acids.

        Parameters
        ----------
        chains : list, optional
            A list of chain identifiers (if not provided, all chains are checked)

        Returns
        -------
        bool
            True if the PDB contains unnatural amino acids, False otherwise

        &#34;&#34;&#34;
        if chains is None:
            chains = [None]
        for chain in chains:
            crd = self.get_pdb_df(chain)
            if not crd[&#34;residue_name&#34;].isin(D3TO1.keys()).all():
                return True
        return False

    def get_coordinates_array(self, chain):
        &#34;&#34;&#34;Return the coordinates of the PDB as a numpy array.

        The atom order is the same as in the `ProteinEntry.ATOM_ORDER` dictionary.
        The array has zeros where the mask has zeros and that is where the sequence
        alignment to the FASTA has gaps (unknown coordinates).

        Parameters
        ----------
        chain : str
            Chain identifier

        Returns
        -------
        crd_arr : np.ndarray
            A numpy array of shape (n_residues, 14, 3) containing the coordinates
            of the PDB (zeros where the coordinates are unknown)

        &#34;&#34;&#34;
        chain_crd = self.get_pdb_df(chain)

        # align fasta and pdb and check criteria)
        mask = self.get_mask([chain])[chain]

        # go over rows of coordinates
        crd_arr = np.zeros((len(mask), 14, 3))

        def arr_index(row):
            atom = row[&#34;atom_name&#34;]
            if atom.startswith(&#34;H&#34;) or atom == &#34;OXT&#34;:
                return -1  # ignore hydrogens and OXT
            order = ProteinEntry.ATOM_ORDER[row[&#34;residue_name&#34;]]
            try:
                return order.index(atom)
            except ValueError:
                raise PDBError(f&#34;Unexpected atoms ({atom})&#34;)

        indices = chain_crd.apply(arr_index, axis=1)
        indices = indices.astype(int)
        informative_mask = indices != -1
        res_indices = np.where(mask == 1)[0]
        unique_numbers = self.get_unique_residue_numbers(chain)
        pdb_seq = self._pdb_sequence(chain)
        if len(unique_numbers) != len(pdb_seq):
            raise PDBError(&#34;Inconsistencies in the biopandas dataframe&#34;)
        replace_dict = {x: y for x, y in zip(unique_numbers, res_indices)}
        chain_crd.loc[:, &#34;unique_residue_number&#34;] = chain_crd[
            &#34;unique_residue_number&#34;
        ].replace(replace_dict)
        crd_arr[
            chain_crd[informative_mask][&#34;unique_residue_number&#34;].astype(int),
            indices[informative_mask],
        ] = chain_crd[informative_mask][[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
        return crd_arr

    def get_unique_residue_numbers(self, chain):
        &#34;&#34;&#34;Return the unique residue numbers (residue number + insertion code).

        Parameters
        ----------
        chain : str
            Chain identifier

        Returns
        -------
        unique_numbers : list
            A list of unique residue numbers

        &#34;&#34;&#34;
        return self.get_pdb_df(chain)[&#34;unique_residue_number&#34;].unique().tolist()

    def _get_atom_dicts(
        self,
        highlight_mask_dict=None,
        style=&#34;cartoon&#34;,
        highlight_style=None,
        opacity=1,
        colors=None,
        accent_color=&#34;#D96181&#34;,
    ):
        &#34;&#34;&#34;Get the atom dictionaries for visualization.&#34;&#34;&#34;
        assert style in [&#34;cartoon&#34;, &#34;sphere&#34;, &#34;stick&#34;, &#34;line&#34;, &#34;cross&#34;]
        if highlight_style is None:
            highlight_style = style
        assert highlight_style in [&#34;cartoon&#34;, &#34;sphere&#34;, &#34;stick&#34;, &#34;line&#34;, &#34;cross&#34;]
        outstr = []
        df_ = self.crd_df.sort_values([&#34;chain_id&#34;, &#34;residue_number&#34;], inplace=False)
        for _, row in df_.iterrows():
            outstr.append(_Atom(row))
        chains = self.get_chains()
        if colors is None:
            colors = COLORS
        colors = {ch: colors[i % len(colors)] for i, ch in enumerate(chains)}
        chain_counters = defaultdict(int)
        chain_last_res = defaultdict(lambda: None)
        if highlight_mask_dict is not None:
            for chain, mask in highlight_mask_dict.items():
                if chain in self.get_chains():
                    assert len(mask) == len(
                        self._pdb_sequence(chain)
                    ), &#34;Mask length does not match sequence length&#34;
        for at in outstr:
            if isinstance(opacity, dict):
                op_ = opacity[at[&#34;chain&#34;]]
            else:
                op_ = opacity
            if at[&#34;resid&#34;] != chain_last_res[at[&#34;chain&#34;]]:
                chain_last_res[at[&#34;chain&#34;]] = at[&#34;resid&#34;]
                chain_counters[at[&#34;chain&#34;]] += 1
            at[&#34;pymol&#34;] = {style: {&#34;color&#34;: colors[at[&#34;chain&#34;]], &#34;opacity&#34;: op_}}
            if highlight_mask_dict is not None and at[&#34;chain&#34;] in highlight_mask_dict:
                num = chain_counters[at[&#34;chain&#34;]]
                if (
                    highlight_mask_dict[at[&#34;chain&#34;]][num - 1] == 1
                    and accent_color is not None
                ):
                    at[&#34;pymol&#34;] = {
                        highlight_style: {&#34;color&#34;: accent_color, &#34;opacity&#34;: op_}
                    }
        return outstr

    def visualize(
        self,
        highlight_mask_dict=None,
        style=&#34;cartoon&#34;,
        highlight_style=None,
        opacity=1,
        colors=None,
        accent_color=&#34;#D96181&#34;,
        canvas_size=(400, 300),
    ):
        &#34;&#34;&#34;Visualize the protein in a notebook.

        Parameters
        ----------
        highlight_mask_dict : dict, optional
            A dictionary mapping from chain IDs to a mask of 0s and 1s of the same length as the chain sequence;
            the atoms corresponding to 1s will be highlighted in red
        style : str, default &#39;cartoon&#39;
            The style of the visualization; one of &#39;cartoon&#39;, &#39;sphere&#39;, &#39;stick&#39;, &#39;line&#39;, &#39;cross&#39;
        highlight_style : str, optional
            The style of the highlighted atoms; one of &#39;cartoon&#39;, &#39;sphere&#39;, &#39;stick&#39;, &#39;line&#39;, &#39;cross&#39;
            (defaults to the same as `style`)
        opacity : float or dict, default 1
            Opacity of the visualization (can be a dictionary mapping from chain IDs to opacity values)
        colors : list, optional
            A list of colors to use for different chains
        accent_color : str, optional
            The color of the highlighted atoms (use `None` to disable highlighting)
        canvas_size : tuple, default (400, 300)
            The shape of the canvas

        &#34;&#34;&#34;
        outstr = self._get_atom_dicts(
            highlight_mask_dict,
            style=style,
            highlight_style=highlight_style,
            opacity=opacity,
            colors=colors,
            accent_color=accent_color,
        )
        vis_string = &#34;&#34;.join([str(x) for x in outstr])
        view = _get_view(canvas_size)
        view.addModelsAsFrames(vis_string)
        for i, at in enumerate(outstr):
            view.setStyle(
                {&#34;model&#34;: -1, &#34;serial&#34;: i + 1},
                at[&#34;pymol&#34;],
            )
        view.zoomTo()
        view.show()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="proteinflow.data.SAbDabEntry" href="#proteinflow.data.SAbDabEntry">SAbDabEntry</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="proteinflow.data.PDBEntry.from_id"><code class="name flex">
<span>def <span class="ident">from_id</span></span>(<span>pdb_id, local_folder='.')</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a <code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code> object from a PDB Id.</p>
<p>Downloads the PDB and FASTA files to the local folder.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pdb_id</code></strong> :&ensp;<code>str</code></dt>
<dd>PDB Id of the protein</dd>
<dt><strong><code>local_folder</code></strong> :&ensp;<code>str</code>, default <code>'.'</code></dt>
<dd>Folder where the downloaded files will be stored</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code></dt>
<dd>A <code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_id(pdb_id, local_folder=&#34;.&#34;):
    &#34;&#34;&#34;Initialize a `PDBEntry` object from a PDB Id.

    Downloads the PDB and FASTA files to the local folder.

    Parameters
    ----------
    pdb_id : str
        PDB Id of the protein
    local_folder : str, default &#39;.&#39;
        Folder where the downloaded files will be stored

    Returns
    -------
    entry : PDBEntry
        A `PDBEntry` object

    &#34;&#34;&#34;
    pdb_path = download_pdb(pdb_id, local_folder)
    fasta_path = download_fasta(pdb_id, local_folder)
    return PDBEntry(pdb_path=pdb_path, fasta_path=fasta_path)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.PDBEntry.parse_fasta"><code class="name flex">
<span>def <span class="ident">parse_fasta</span></span>(<span>fasta_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a fasta file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fasta_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the fasta file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing all the (author) chains in a fasta file (keys)
and their corresponding sequence (values)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_fasta(fasta_path):
    &#34;&#34;&#34;Read a fasta file.

    Parameters
    ----------
    fasta_path : str
        Path to the fasta file

    Returns
    -------
    out_dict : dict
        A dictionary containing all the (author) chains in a fasta file (keys)
        and their corresponding sequence (values)

    &#34;&#34;&#34;
    with open(fasta_path) as f:
        lines = np.array(f.readlines())

    indexes = np.array([k for k, l in enumerate(lines) if l[0] == &#34;&gt;&#34;])
    starts = indexes + 1
    ends = list(indexes[1:]) + [len(lines)]
    names = lines[indexes]
    seqs = [&#34;&#34;.join(lines[s:e]).replace(&#34;\n&#34;, &#34;&#34;) for s, e in zip(starts, ends)]

    out_dict = {}
    for name, seq in zip(names, seqs):
        for chain in _retrieve_chain_names(name):
            out_dict[chain] = seq

    return out_dict</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="proteinflow.data.PDBEntry.get_alignment"><code class="name flex">
<span>def <span class="ident">get_alignment</span></span>(<span>self, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the alignment between the PDB and the FASTA sequence.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>A list of chain identifiers (if not provided, all chains are aligned)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>alignment</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing the aligned sequences for each chain</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_alignment(self, chains=None):
    &#34;&#34;&#34;Return the alignment between the PDB and the FASTA sequence.

    Parameters
    ----------
    chains : list, optional
        A list of chain identifiers (if not provided, all chains are aligned)

    Returns
    -------
    alignment : dict
        A dictionary containing the aligned sequences for each chain

    &#34;&#34;&#34;
    if chains is None:
        chains = self.chains()
    return {chain: self._align_chain(chain)[0] for chain in chains}</code></pre>
</details>
</dd>
<dt id="proteinflow.data.PDBEntry.get_chains"><code class="name flex">
<span>def <span class="ident">get_chains</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the chains in the PDB.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of chain identifiers</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chains(self):
    &#34;&#34;&#34;Return the chains in the PDB.

    Returns
    -------
    chains : list
        A list of chain identifiers

    &#34;&#34;&#34;
    return list(self.fasta_dict.keys())</code></pre>
</details>
</dd>
<dt id="proteinflow.data.PDBEntry.get_coordinates_array"><code class="name flex">
<span>def <span class="ident">get_coordinates_array</span></span>(<span>self, chain)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the coordinates of the PDB as a numpy array.</p>
<p>The atom order is the same as in the <code><a title="proteinflow.data.ProteinEntry.ATOM_ORDER" href="#proteinflow.data.ProteinEntry.ATOM_ORDER">ProteinEntry.ATOM_ORDER</a></code> dictionary.
The array has zeros where the mask has zeros and that is where the sequence
alignment to the FASTA has gaps (unknown coordinates).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chain</code></strong> :&ensp;<code>str</code></dt>
<dd>Chain identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>crd_arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A numpy array of shape (n_residues, 14, 3) containing the coordinates
of the PDB (zeros where the coordinates are unknown)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coordinates_array(self, chain):
    &#34;&#34;&#34;Return the coordinates of the PDB as a numpy array.

    The atom order is the same as in the `ProteinEntry.ATOM_ORDER` dictionary.
    The array has zeros where the mask has zeros and that is where the sequence
    alignment to the FASTA has gaps (unknown coordinates).

    Parameters
    ----------
    chain : str
        Chain identifier

    Returns
    -------
    crd_arr : np.ndarray
        A numpy array of shape (n_residues, 14, 3) containing the coordinates
        of the PDB (zeros where the coordinates are unknown)

    &#34;&#34;&#34;
    chain_crd = self.get_pdb_df(chain)

    # align fasta and pdb and check criteria)
    mask = self.get_mask([chain])[chain]

    # go over rows of coordinates
    crd_arr = np.zeros((len(mask), 14, 3))

    def arr_index(row):
        atom = row[&#34;atom_name&#34;]
        if atom.startswith(&#34;H&#34;) or atom == &#34;OXT&#34;:
            return -1  # ignore hydrogens and OXT
        order = ProteinEntry.ATOM_ORDER[row[&#34;residue_name&#34;]]
        try:
            return order.index(atom)
        except ValueError:
            raise PDBError(f&#34;Unexpected atoms ({atom})&#34;)

    indices = chain_crd.apply(arr_index, axis=1)
    indices = indices.astype(int)
    informative_mask = indices != -1
    res_indices = np.where(mask == 1)[0]
    unique_numbers = self.get_unique_residue_numbers(chain)
    pdb_seq = self._pdb_sequence(chain)
    if len(unique_numbers) != len(pdb_seq):
        raise PDBError(&#34;Inconsistencies in the biopandas dataframe&#34;)
    replace_dict = {x: y for x, y in zip(unique_numbers, res_indices)}
    chain_crd.loc[:, &#34;unique_residue_number&#34;] = chain_crd[
        &#34;unique_residue_number&#34;
    ].replace(replace_dict)
    crd_arr[
        chain_crd[informative_mask][&#34;unique_residue_number&#34;].astype(int),
        indices[informative_mask],
    ] = chain_crd[informative_mask][[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
    return crd_arr</code></pre>
</details>
</dd>
<dt id="proteinflow.data.PDBEntry.get_fasta"><code class="name flex">
<span>def <span class="ident">get_fasta</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the fasta dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fasta_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing all the (author) chains in a fasta file (keys)
and their corresponding sequence (values)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fasta(self):
    &#34;&#34;&#34;Return the fasta dictionary.

    Returns
    -------
    fasta_dict : dict
        A dictionary containing all the (author) chains in a fasta file (keys)
        and their corresponding sequence (values)

    &#34;&#34;&#34;
    return self.fasta_dict</code></pre>
</details>
</dd>
<dt id="proteinflow.data.PDBEntry.get_ligands"><code class="name flex">
<span>def <span class="ident">get_ligands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the ligands dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ligands</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing all the chains in a pdb file (keys)
and their corresponding processed ligands (values)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ligands(self):
    &#34;&#34;&#34;Return the ligands dictionary.

    Returns
    -------
    ligands : dict
        A dictionary containing all the chains in a pdb file (keys)
        and their corresponding processed ligands (values)

    &#34;&#34;&#34;
    return self.ligands</code></pre>
</details>
</dd>
<dt id="proteinflow.data.PDBEntry.get_mask"><code class="name flex">
<span>def <span class="ident">get_mask</span></span>(<span>self, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the mask of the alignment between the PDB and the FASTA sequence.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>A list of chain identifiers (if not provided, all chains are aligned)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mask</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing the <code>np.ndarray</code> mask for each chain (0 where the
aligned sequence has gaps and 1 where it does not)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mask(self, chains=None):
    &#34;&#34;&#34;Return the mask of the alignment between the PDB and the FASTA sequence.

    Parameters
    ----------
    chains : list, optional
        A list of chain identifiers (if not provided, all chains are aligned)

    Returns
    -------
    mask : dict
        A dictionary containing the `np.ndarray` mask for each chain (0 where the
        aligned sequence has gaps and 1 where it does not)

    &#34;&#34;&#34;
    alignment = self.get_alignment(chains)
    return {
        chain: (np.array(list(seq)) != &#34;-&#34;).astype(int)
        for chain, seq in alignment.items()
    }</code></pre>
</details>
</dd>
<dt id="proteinflow.data.PDBEntry.get_pdb_df"><code class="name flex">
<span>def <span class="ident">get_pdb_df</span></span>(<span>self, chain=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the PDB dataframe.</p>
<p>If <code>chain</code> is provided, only information for this chain is returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chain</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Chain identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A <code>BioPandas</code> style dataframe containing the PDB information</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pdb_df(self, chain=None):
    &#34;&#34;&#34;Return the PDB dataframe.

    If `chain` is provided, only information for this chain is returned.

    Parameters
    ----------
    chain : str, optional
        Chain identifier

    Returns
    -------
    df : pd.DataFrame
        A `BioPandas` style dataframe containing the PDB information

    &#34;&#34;&#34;
    chain = self._get_chain(chain)
    if chain is None:
        return self.crd_df
    else:
        return self.crd_df[self.crd_df[&#34;chain_id&#34;] == chain]</code></pre>
</details>
</dd>
<dt id="proteinflow.data.PDBEntry.get_sequence_df"><code class="name flex">
<span>def <span class="ident">get_sequence_df</span></span>(<span>self, chain=None, suppress_check=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the sequence dataframe.</p>
<p>If <code>chain</code> is provided, only information for this chain is returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chain</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Chain identifier</dd>
<dt><strong><code>suppress_check</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, do not check if the chain is in the PDB</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A dataframe containing the sequence and chain information
(analogous to the <code>BioPandas.pdb.PandasPdb.amino3to1</code> method output)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sequence_df(self, chain=None, suppress_check=False):
    &#34;&#34;&#34;Return the sequence dataframe.

    If `chain` is provided, only information for this chain is returned.

    Parameters
    ----------
    chain : str, optional
        Chain identifier
    suppress_check : bool, default False
        If True, do not check if the chain is in the PDB

    Returns
    -------
    df : pd.DataFrame
        A dataframe containing the sequence and chain information
        (analogous to the `BioPandas.pdb.PandasPdb.amino3to1` method output)

    &#34;&#34;&#34;
    if not suppress_check:
        chain = self._get_chain(chain)
    if chain is None:
        return self.seq_df
    else:
        return self.seq_df[self.seq_df[&#34;chain_id&#34;] == chain]</code></pre>
</details>
</dd>
<dt id="proteinflow.data.PDBEntry.get_unique_residue_numbers"><code class="name flex">
<span>def <span class="ident">get_unique_residue_numbers</span></span>(<span>self, chain)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the unique residue numbers (residue number + insertion code).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chain</code></strong> :&ensp;<code>str</code></dt>
<dd>Chain identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>unique_numbers</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of unique residue numbers</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unique_residue_numbers(self, chain):
    &#34;&#34;&#34;Return the unique residue numbers (residue number + insertion code).

    Parameters
    ----------
    chain : str
        Chain identifier

    Returns
    -------
    unique_numbers : list
        A list of unique residue numbers

    &#34;&#34;&#34;
    return self.get_pdb_df(chain)[&#34;unique_residue_number&#34;].unique().tolist()</code></pre>
</details>
</dd>
<dt id="proteinflow.data.PDBEntry.has_unnatural_amino_acids"><code class="name flex">
<span>def <span class="ident">has_unnatural_amino_acids</span></span>(<span>self, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the PDB contains unnatural amino acids.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>A list of chain identifiers (if not provided, all chains are checked)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the PDB contains unnatural amino acids, False otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_unnatural_amino_acids(self, chains=None):
    &#34;&#34;&#34;Check if the PDB contains unnatural amino acids.

    Parameters
    ----------
    chains : list, optional
        A list of chain identifiers (if not provided, all chains are checked)

    Returns
    -------
    bool
        True if the PDB contains unnatural amino acids, False otherwise

    &#34;&#34;&#34;
    if chains is None:
        chains = [None]
    for chain in chains:
        crd = self.get_pdb_df(chain)
        if not crd[&#34;residue_name&#34;].isin(D3TO1.keys()).all():
            return True
    return False</code></pre>
</details>
</dd>
<dt id="proteinflow.data.PDBEntry.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, entry)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge two PDB entries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code></dt>
<dd>A <code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code> object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code></dt>
<dd>A <code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, entry):
    &#34;&#34;&#34;Merge two PDB entries.

    Parameters
    ----------
    entry : PDBEntry
        A `PDBEntry` object

    Returns
    -------
    entry : PDBEntry
        A `PDBEntry` object

    &#34;&#34;&#34;
    if entry.pdb_id != self.pdb_id:
        self.pdb_id = f&#34;{self.pdb_id}+{entry.pdb_id}&#34;
    for chain in entry.get_chains():
        if chain.split(&#34;_&#34;)[0] in {x.split(&#34;_&#34;)[0] for x in self.get_chains()}:
            raise ValueError(&#34;Chain IDs must be unique&#34;)
    self.crd_df = pd.concat([self.crd_df, entry.crd_df], ignore_index=True)
    self.seq_df = pd.concat([self.seq_df, entry.seq_df], ignore_index=True)
    self.crd_df.loc[:, &#34;atom_number&#34;] = np.arange(len(self.crd_df))
    self.fasta_dict.update(entry.fasta_dict)
    return self</code></pre>
</details>
</dd>
<dt id="proteinflow.data.PDBEntry.rename_chains"><code class="name flex">
<span>def <span class="ident">rename_chains</span></span>(<span>self, chain_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename chains in the PDB entry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chain_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary mapping from old chain IDs to new chain IDs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code></dt>
<dd>A <code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_chains(self, chain_dict):
    &#34;&#34;&#34;Rename chains in the PDB entry.

    Parameters
    ----------
    chain_dict : dict
        A dictionary mapping from old chain IDs to new chain IDs

    Returns
    -------
    entry : PDBEntry
        A `PDBEntry` object

    &#34;&#34;&#34;
    _chain_dict = {chain: chain * 5 for chain in self.get_chains()}
    self.crd_df[&#34;chain_id&#34;] = self.crd_df[&#34;chain_id&#34;].replace(_chain_dict)
    self.seq_df[&#34;chain_id&#34;] = self.seq_df[&#34;chain_id&#34;].replace(_chain_dict)
    self.fasta_dict = {_chain_dict[k]: v for k, v in self.fasta_dict.items()}
    chain_dict = {k * 5: v for k, v in chain_dict.items()}
    self.crd_df[&#34;chain_id&#34;] = self.crd_df[&#34;chain_id&#34;].replace(chain_dict)
    self.seq_df[&#34;chain_id&#34;] = self.seq_df[&#34;chain_id&#34;].replace(chain_dict)
    self.fasta_dict = {chain_dict[k]: v for k, v in self.fasta_dict.items()}
    return self</code></pre>
</details>
</dd>
<dt id="proteinflow.data.PDBEntry.visualize"><code class="name flex">
<span>def <span class="ident">visualize</span></span>(<span>self, highlight_mask_dict=None, style='cartoon', highlight_style=None, opacity=1, colors=None, accent_color='#D96181', canvas_size=(400, 300))</span>
</code></dt>
<dd>
<div class="desc"><p>Visualize the protein in a notebook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>highlight_mask_dict</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>A dictionary mapping from chain IDs to a mask of 0s and 1s of the same length as the chain sequence;
the atoms corresponding to 1s will be highlighted in red</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str</code>, default <code>'cartoon'</code></dt>
<dd>The style of the visualization; one of 'cartoon', 'sphere', 'stick', 'line', 'cross'</dd>
<dt><strong><code>highlight_style</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The style of the highlighted atoms; one of 'cartoon', 'sphere', 'stick', 'line', 'cross'
(defaults to the same as <code>style</code>)</dd>
<dt><strong><code>opacity</code></strong> :&ensp;<code>float</code> or <code>dict</code>, default <code>1</code></dt>
<dd>Opacity of the visualization (can be a dictionary mapping from chain IDs to opacity values)</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>A list of colors to use for different chains</dd>
<dt><strong><code>accent_color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The color of the highlighted atoms (use <code>None</code> to disable highlighting)</dd>
<dt><strong><code>canvas_size</code></strong> :&ensp;<code>tuple</code>, default <code>(400, 300)</code></dt>
<dd>The shape of the canvas</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualize(
    self,
    highlight_mask_dict=None,
    style=&#34;cartoon&#34;,
    highlight_style=None,
    opacity=1,
    colors=None,
    accent_color=&#34;#D96181&#34;,
    canvas_size=(400, 300),
):
    &#34;&#34;&#34;Visualize the protein in a notebook.

    Parameters
    ----------
    highlight_mask_dict : dict, optional
        A dictionary mapping from chain IDs to a mask of 0s and 1s of the same length as the chain sequence;
        the atoms corresponding to 1s will be highlighted in red
    style : str, default &#39;cartoon&#39;
        The style of the visualization; one of &#39;cartoon&#39;, &#39;sphere&#39;, &#39;stick&#39;, &#39;line&#39;, &#39;cross&#39;
    highlight_style : str, optional
        The style of the highlighted atoms; one of &#39;cartoon&#39;, &#39;sphere&#39;, &#39;stick&#39;, &#39;line&#39;, &#39;cross&#39;
        (defaults to the same as `style`)
    opacity : float or dict, default 1
        Opacity of the visualization (can be a dictionary mapping from chain IDs to opacity values)
    colors : list, optional
        A list of colors to use for different chains
    accent_color : str, optional
        The color of the highlighted atoms (use `None` to disable highlighting)
    canvas_size : tuple, default (400, 300)
        The shape of the canvas

    &#34;&#34;&#34;
    outstr = self._get_atom_dicts(
        highlight_mask_dict,
        style=style,
        highlight_style=highlight_style,
        opacity=opacity,
        colors=colors,
        accent_color=accent_color,
    )
    vis_string = &#34;&#34;.join([str(x) for x in outstr])
    view = _get_view(canvas_size)
    view.addModelsAsFrames(vis_string)
    for i, at in enumerate(outstr):
        view.setStyle(
            {&#34;model&#34;: -1, &#34;serial&#34;: i + 1},
            at[&#34;pymol&#34;],
        )
    view.zoomTo()
    view.show()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="proteinflow.data.ProteinEntry"><code class="flex name class">
<span>class <span class="ident">ProteinEntry</span></span>
<span>(</span><span>seqs, crds, masks, chain_ids, predict_masks=None, cdrs=None, protein_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to interact with proteinflow data files.</p>
<p>Initialize a <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>seqs</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Amino acid sequences of the protein (one-letter code)</dd>
<dt><strong><code>crds</code></strong> :&ensp;<code>list</code> of <code>np.ndarray</code></dt>
<dd>Coordinates of the protein, <code>numpy</code> arrays of shape <code>(L, 14, 3)</code>,
in the order of <code>N, C, CA, O</code></dd>
<dt><strong><code>masks</code></strong> :&ensp;<code>list</code> of <code>np.ndarray</code></dt>
<dd>Mask arrays where 1 indicates residues with known coordinates and 0
indicates missing values</dd>
<dt><strong><code>cdrs</code></strong> :&ensp;<code>list</code> of <code>np.ndarray</code></dt>
<dd><code>'numpy'</code> arrays of shape <code>(L,)</code> where CDR residues are marked with the corresponding type (<code>'H1'</code>, <code>'L1'</code>, &hellip;)
and non-CDR residues are marked with <code>'-'</code></dd>
<dt><strong><code>chain_ids</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Chain IDs of the protein</dd>
<dt><strong><code>predict_masks</code></strong> :&ensp;<code>list</code> of <code>np.ndarray</code>, optional</dt>
<dd>Mask arrays where 1 indicates residues that were generated by a model and 0
indicates residues with known coordinates</dd>
<dt><strong><code>cdrs</code></strong> :&ensp;<code>list</code> of <code>np.ndarray</code>, optional</dt>
<dd><code>'numpy'</code> arrays of shape <code>(L,)</code> where CDR residues are marked with the corresponding type (<code>'H1'</code>, <code>'L1'</code>, &hellip;)</dd>
<dt><strong><code>protein_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the protein</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProteinEntry:
    &#34;&#34;&#34;A class to interact with proteinflow data files.&#34;&#34;&#34;

    ATOM_ORDER = {k: BACKBONE_ORDER + v for k, v in SIDECHAIN_ORDER.items()}
    &#34;&#34;&#34;A dictionary mapping 3-letter residue names to the order of atoms in the coordinates array.&#34;&#34;&#34;

    def __init__(
        self,
        seqs,
        crds,
        masks,
        chain_ids,
        predict_masks=None,
        cdrs=None,
        protein_id=None,
    ):
        &#34;&#34;&#34;Initialize a `ProteinEntry` object.

        Parameters
        ----------
        seqs : list of str
            Amino acid sequences of the protein (one-letter code)
        crds : list of np.ndarray
            Coordinates of the protein, `numpy` arrays of shape `(L, 14, 3)`,
            in the order of `N, C, CA, O`
        masks : list of np.ndarray
            Mask arrays where 1 indicates residues with known coordinates and 0
            indicates missing values
        cdrs : list of np.ndarray
            `&#39;numpy&#39;` arrays of shape `(L,)` where CDR residues are marked with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...)
            and non-CDR residues are marked with `&#39;-&#39;`
        chain_ids : list of str
            Chain IDs of the protein
        predict_masks : list of np.ndarray, optional
            Mask arrays where 1 indicates residues that were generated by a model and 0
            indicates residues with known coordinates
        cdrs : list of np.ndarray, optional
            `&#39;numpy&#39;` arrays of shape `(L,)` where CDR residues are marked with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...)
        protein_id : str, optional
            ID of the protein

        &#34;&#34;&#34;
        if crds[0].shape[1] != 14:
            raise ValueError(
                &#34;Coordinates array must have 14 atoms in the order of N, C, CA, O, sidechain atoms&#34;
            )
        self.seq = {x: seq for x, seq in zip(chain_ids, seqs)}
        self.crd = {x: crd for x, crd in zip(chain_ids, crds)}
        self.mask = {x: mask for x, mask in zip(chain_ids, masks)}
        self.mask_original = {x: mask for x, mask in zip(chain_ids, masks)}
        if cdrs is None:
            cdrs = [None for _ in chain_ids]
        self.cdr = {x: cdr for x, cdr in zip(chain_ids, cdrs)}
        if predict_masks is None:
            predict_masks = [None for _ in chain_ids]
        self.predict_mask = {x: mask for x, mask in zip(chain_ids, predict_masks)}
        self.id = protein_id

    def get_id(self):
        &#34;&#34;&#34;Return the ID of the protein.&#34;&#34;&#34;
        return self.id

    def interpolate_coords(self, fill_ends=True):
        &#34;&#34;&#34;Fill in missing values in the coordinates arrays with linear interpolation.

        Parameters
        ----------
        fill_ends : bool, default True
            If `True`, fill in missing values at the ends of the protein sequence with the edge values;
            otherwise fill them in with zeros

        &#34;&#34;&#34;
        for chain in self.get_chains():
            self.crd[chain], self.mask[chain] = interpolate_coords(
                self.crd[chain], self.mask[chain], fill_ends=fill_ends
            )

    def cut_missing_edges(self):
        &#34;&#34;&#34;Cut off the ends of the protein sequence that have missing coordinates.&#34;&#34;&#34;
        for chain in self.get_chains():
            mask = self.mask[chain]
            known_ind = np.where(mask == 1)[0]
            start, end = known_ind[0], known_ind[-1] + 1
            self.seq[chain] = self.seq[chain][start:end]
            self.crd[chain] = self.crd[chain][start:end]
            self.mask[chain] = self.mask[chain][start:end]
            if self.cdr[chain] is not None:
                self.cdr[chain] = self.cdr[chain][start:end]

    def get_chains(self):
        &#34;&#34;&#34;Get the chain IDs of the protein.

        Returns
        -------
        chains : list of str
            Chain IDs of the protein

        &#34;&#34;&#34;
        return sorted(self.seq.keys())

    def _get_chains_list(self, chains):
        &#34;&#34;&#34;Get a list of chains to iterate over.&#34;&#34;&#34;
        if chains is None:
            chains = self.get_chains()
        return chains

    def get_chain_type_dict(self, chains=None):
        &#34;&#34;&#34;Get the chain types of the protein.

        If the CDRs are not annotated, this function will return `None`.
        If there is no light or heavy chain, the corresponding key will be missing.
        If there is no antigen chain, the `&#39;antigen&#39;` key will map to an empty list.

        Parameters
        ----------
        chains : list of str, default None
            Chain IDs to consider

        Returns
        -------
        chain_type_dict : dict
            A dictionary with keys `&#39;heavy&#39;`, `&#39;light&#39;` and `&#39;antigen&#39;` and values
            the corresponding chain IDs

        &#34;&#34;&#34;
        if not self.has_cdr():
            return None
        chain_type_dict = {&#34;antigen&#34;: []}
        chains = self._get_chains_list(chains)
        for chain, cdr in self.cdr.items():
            if chain not in chains:
                continue
            u = np.unique(cdr)
            if &#34;H1&#34; in u:
                chain_type_dict[&#34;heavy&#34;] = chain
            elif &#34;L1&#34; in u:
                chain_type_dict[&#34;light&#34;] = chain
            else:
                chain_type_dict[&#34;antigen&#34;].append(chain)
        return chain_type_dict

    def get_length(self, chains=None):
        &#34;&#34;&#34;Get the total length of a set of chains.

        Parameters
        ----------
        chain : str, optional
            Chain ID; if `None`, the length of the whole protein is returned

        Returns
        -------
        length : int
            Length of the chain

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        return sum([len(self.seq[x]) for x in chains])

    def get_cdr_length(self, chains):
        &#34;&#34;&#34;Get the length of the CDR regions of a set of chains.

        Parameters
        ----------
        chain : str
            Chain ID

        Returns
        -------
        length : int
            Length of the CDR regions of the chain

        &#34;&#34;&#34;
        if not self.has_cdr():
            return {x: None for x in [&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;]}
        return {
            x: len(self.get_sequence(chains=chains, cdr=x))
            for x in [&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;]
        }

    def has_cdr(self):
        &#34;&#34;&#34;Check if the protein is from the SAbDab database.

        Returns
        -------
        is_sabdab : bool
            True if the protein is from the SAbDab database

        &#34;&#34;&#34;
        return list(self.cdr.values())[0] is not None

    def has_predict_mask(self):
        &#34;&#34;&#34;Check if the protein has a predicted mask.

        Returns
        -------
        has_predict_mask : bool
            True if the protein has a predicted mask

        &#34;&#34;&#34;
        return list(self.predict_mask.values())[0] is not None

    def __len__(self):
        &#34;&#34;&#34;Get the total length of the protein chains.&#34;&#34;&#34;
        return self.get_length(self.get_chains())

    def get_sequence(self, chains=None, encode=False, cdr=None, only_known=False):
        &#34;&#34;&#34;Get the amino acid sequence of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the sequences of the specified chains is returned (in the same order);
            otherwise, all sequences are concatenated in alphabetical order of the chain IDs
        encode : bool, default False
            If `True`, the sequence is encoded as a `&#39;numpy&#39;` array of integers
            where each integer corresponds to the index of the amino acid in
            `proteinflow.constants.ALPHABET`
        cdr : {&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;}, optional
            If specified, only the CDR region of the specified type is returned
        only_known : bool, default False
            If `True`, only the residues with known coordinates are returned

        Returns
        -------
        seq : str or np.ndarray
            Amino acid sequence of the protein (one-letter code) or an encoded
            sequence as a `&#39;numpy&#39;` array of integers

        &#34;&#34;&#34;
        if cdr is not None and self.cdr is None:
            raise ValueError(&#34;CDR information not available&#34;)
        if cdr is not None:
            assert cdr in CDR_REVERSE, f&#34;CDR must be one of {list(CDR_REVERSE.keys())}&#34;
        chains = self._get_chains_list(chains)
        seq = &#34;&#34;.join([self.seq[c] for c in chains]).replace(&#34;B&#34;, &#34;&#34;)
        if encode:
            seq = np.array([ALPHABET_REVERSE[aa] for aa in seq])
        elif cdr is not None or only_known:
            seq = np.array(list(seq))
        if cdr is not None:
            cdr_arr = self.get_cdr(chains=chains)
            seq = seq[cdr_arr == cdr]
        if only_known:
            seq = seq[self.get_mask(chains=chains, cdr=cdr).astype(bool)]
        if not encode and not isinstance(seq, str):
            seq = &#34;&#34;.join(seq)
        return seq

    def get_coordinates(self, chains=None, bb_only=False, cdr=None, only_known=False):
        &#34;&#34;&#34;Get the coordinates of the protein.

        Backbone atoms are in the order of `N, C, CA, O`; for the full-atom
        order see `ProteinEntry.ATOM_ORDER` (sidechain atoms come after the
        backbone atoms).

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the coordinates of the specified chains are returned (in the same order);
            otherwise, all coordinates are concatenated in alphabetical order of the chain IDs
        bb_only : bool, default False
            If `True`, only the backbone atoms are returned
        cdr : {&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;}, optional
            If specified, only the CDR region of the specified type is returned
        only_known : bool, default False
            If `True`, only return the coordinates of residues with known coordinates

        Returns
        -------
        crd : np.ndarray
            Coordinates of the protein, `&#39;numpy&#39;` array of shape `(L, 14, 3)`
            or `(L, 4, 3)` if `bb_only=True`

        &#34;&#34;&#34;
        if cdr is not None and self.cdr is None:
            raise ValueError(&#34;CDR information not available&#34;)
        if cdr is not None:
            assert cdr in CDR_REVERSE, f&#34;CDR must be one of {list(CDR_REVERSE.keys())}&#34;
        chains = self._get_chains_list(chains)
        crd = np.concatenate([self.crd[c] for c in chains], axis=0)
        if cdr is not None:
            crd = crd[self.cdr == cdr]
        if bb_only:
            crd = crd[:, :4, :]
        if only_known:
            crd = crd[self.get_mask(chains=chains, cdr=cdr).astype(bool)]
        return crd

    def get_mask(self, chains=None, cdr=None, original=False):
        &#34;&#34;&#34;Get the mask of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the masks of the specified chains are returned (in the same order);
            otherwise, all masks are concatenated in alphabetical order of the chain IDs
        cdr : {&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;}, optional
            If specified, only the CDR region of the specified type is returned
        original : bool, default False
            If `True`, return the original mask (before interpolation)

        Returns
        -------
        mask : np.ndarray
            Mask array where 1 indicates residues with known coordinates and 0
            indicates missing values

        &#34;&#34;&#34;
        if cdr is not None and self.cdr is None:
            raise ValueError(&#34;CDR information not available&#34;)
        if cdr is not None:
            assert cdr in CDR_REVERSE, f&#34;CDR must be one of {list(CDR_REVERSE.keys())}&#34;
        chains = self._get_chains_list(chains)
        mask = np.concatenate(
            [self.mask_original[c] if original else self.mask[c] for c in chains],
            axis=0,
        )
        if cdr is not None:
            mask = mask[self.cdr == cdr]
        return mask

    def get_cdr(self, chains=None, encode=False):
        &#34;&#34;&#34;Get the CDR information of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the CDR information of the specified chains is
            returned (in the same order); otherwise, all CDR information is concatenated in
            alphabetical order of the chain IDs
        encode : bool, default False
            If `True`, the CDR information is encoded as a `&#39;numpy&#39;` array of
            integers where each integer corresponds to the index of the CDR
            type in `proteinflow.constants.CDR_ALPHABET`

        Returns
        -------
        cdr : np.ndarray or None
            A `&#39;numpy&#39;` array of shape `(L,)` where CDR residues are marked
            with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...) and non-CDR
            residues are marked with `&#39;-&#39;` or an encoded array of integers
            ir `encode=True`; `None` if CDR information is not available
        chains : list of str, optional
            If specified, only the CDR information of the specified chains is
            returned (in the same order); otherwise, all CDR information is concatenated in
            alphabetical order of the chain IDs

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        if self.cdr is None:
            return None
        cdr = np.concatenate([self.cdr[c] for c in chains], axis=0)
        if encode:
            cdr = np.array([CDR_REVERSE[aa] for aa in cdr])
        return cdr

    def get_atom_mask(self, chains=None, cdr=None):
        &#34;&#34;&#34;Get the atom mask of the protein.

        Parameters
        ----------
        chains : str, optional
            If specified, only the atom masks of the specified chains are returned (in the same order);
            otherwise, all atom masks are concatenated in alphabetical order of the chain IDs
        cdr : {&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;}, optional
            If specified, only the CDR region of the specified type is returned

        Returns
        -------
        atom_mask : np.ndarray
            Atom mask array where 1 indicates atoms with known coordinates and 0
            indicates missing or non-existing values, shaped `(L, 14, 3)`

        &#34;&#34;&#34;
        if cdr is not None and self.cdr is None:
            raise ValueError(&#34;CDR information not available&#34;)
        if cdr is not None:
            assert cdr in CDR_REVERSE, f&#34;CDR must be one of {list(CDR_REVERSE.keys())}&#34;
        chains = self._get_chains_list(chains)
        seq = &#34;&#34;.join([self.seq[c] for c in chains])
        atom_mask = np.concatenate([ATOM_MASKS[aa] for aa in seq])
        atom_mask[self.mask == 0] = 0
        if cdr is not None:
            atom_mask = atom_mask[self.cdr == cdr]
        return atom_mask

    @staticmethod
    def decode_cdr(cdr):
        &#34;&#34;&#34;Decode the CDR information.

        Parameters
        ----------
        cdr : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L,)` encoded as integers where each
            integer corresponds to the index of the CDR type in
            `proteinflow.constants.CDR_ALPHABET`

        Returns
        -------
        cdr : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L,)` where CDR residues are marked
            with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...) and non-CDR
            residues are marked with `&#39;-&#39;`

        &#34;&#34;&#34;
        cdr = ProteinEntry._to_numpy(cdr)
        return np.array([CDR_ALPHABET[x] for x in cdr.astype(int)])

    @staticmethod
    def _to_numpy(arr):
        if isinstance(arr, Tensor):
            arr = arr.detach().cpu().numpy()
        if isinstance(arr, list):
            arr = np.array(arr)
        return arr

    @staticmethod
    def decode_sequence(seq):
        &#34;&#34;&#34;Decode the amino acid sequence.

        Parameters
        ----------
        seq : np.ndarray
            A `&#39;numpy&#39;` array of integers where each integer corresponds to the
            index of the amino acid in `proteinflow.constants.ALPHABET`

        Returns
        -------
        seq : str
            Amino acid sequence of the protein (one-letter code)

        &#34;&#34;&#34;
        seq = ProteinEntry._to_numpy(seq)
        return &#34;&#34;.join([ALPHABET[x] for x in seq.astype(int)])

    def _rename_chains(self, chain_dict):
        &#34;&#34;&#34;Rename the chains of the protein (with no safeguards).&#34;&#34;&#34;
        for old_chain, new_chain in chain_dict.items():
            self.seq[new_chain] = self.seq.pop(old_chain)
            self.crd[new_chain] = self.crd.pop(old_chain)
            self.mask[new_chain] = self.mask.pop(old_chain)
            self.mask_original[new_chain] = self.mask_original.pop(old_chain)
            self.cdr[new_chain] = self.cdr.pop(old_chain)
            self.predict_mask[new_chain] = self.predict_mask.pop(old_chain)

    def rename_chains(self, chain_dict):
        &#34;&#34;&#34;Rename the chains of the protein.

        Parameters
        ----------
        chain_dict : dict
            A dictionary mapping old chain IDs to new chain IDs

        &#34;&#34;&#34;
        self._rename_chains({k: k * 5 for k in self.get_chains()})
        self._rename_chains({k * 5: v for k, v in chain_dict.items()})

    def get_predicted_entry(self):
        &#34;&#34;&#34;Return a `ProteinEntry` object that only contains predicted residues.

        Returns
        -------
        entry : ProteinEntry
            The truncated `ProteinEntry` object

        &#34;&#34;&#34;
        if self.predict_mask is None:
            raise ValueError(&#34;Predicted mask not available&#34;)
        entry_dict = self.to_dict()
        for chain in self.get_chains():
            mask_ = self.predict_mask[chain].astype(bool)
            if mask_.sum() == 0:
                entry_dict.pop(chain)
                continue
            if mask_.sum() == len(mask_):
                continue
            seq_arr = np.array(list(entry_dict[chain][&#34;seq&#34;]))
            entry_dict[chain][&#34;seq&#34;] = &#34;&#34;.join(seq_arr[mask_])
            entry_dict[chain][&#34;crd_bb&#34;] = entry_dict[chain][&#34;crd_bb&#34;][mask_]
            entry_dict[chain][&#34;crd_sc&#34;] = entry_dict[chain][&#34;crd_sc&#34;][mask_]
            entry_dict[chain][&#34;msk&#34;] = entry_dict[chain][&#34;msk&#34;][mask_]
            entry_dict[chain][&#34;predict_msk&#34;] = entry_dict[chain][&#34;predict_msk&#34;][mask_]
            if &#34;cdr&#34; in entry_dict[chain]:
                entry_dict[chain][&#34;cdr&#34;] = entry_dict[chain][&#34;cdr&#34;][mask_]
        return ProteinEntry.from_dict(entry_dict)

    def get_predicted_chains(self):
        &#34;&#34;&#34;Return a list of chain IDs that contain predicted residues.

        Returns
        -------
        chains : list of str
            Chain IDs

        &#34;&#34;&#34;
        if not self.has_predict_mask():
            raise ValueError(&#34;Predicted mask not available&#34;)
        return [k for k, v in self.predict_mask.items() if v.sum() != 0]

    def merge(self, entry):
        &#34;&#34;&#34;Merge another `ProteinEntry` object into this one.

        Parameters
        ----------
        entry : ProteinEntry
            The merged `ProteinEntry` object

        &#34;&#34;&#34;
        for chain in entry.get_chains():
            if chain.split(&#34;_&#34;)[0] in {x.split(&#34;_&#34;)[0] for x in self.get_chains()}:
                raise ValueError(&#34;Chain IDs must be unique&#34;)
            self.seq[chain] = entry.seq[chain]
            self.crd[chain] = entry.crd[chain]
            self.mask[chain] = entry.mask[chain]
            self.mask_original[chain] = entry.mask_original[chain]
            self.cdr[chain] = entry.cdr[chain]
            self.predict_mask[chain] = entry.predict_mask[chain]
        if not all([x is None for x in self.predict_mask.values()]):
            for k, v in self.predict_mask.items():
                if v is None:
                    self.predict_mask[k] = np.zeros(len(self.get_sequence(k)))

    @staticmethod
    def from_arrays(
        seqs,
        crds,
        masks,
        chain_id_dict,
        chain_id_array,
        predict_masks=None,
        cdrs=None,
        protein_id=None,
    ):
        &#34;&#34;&#34;Load a protein entry from arrays.

        Parameters
        ----------
        seqs : np.ndarray
            Amino acid sequences of the protein (encoded as integers, see `proteinflow.constants.ALPHABET`), `&#39;numpy&#39;` array of shape `(L,)`
        crds : np.ndarray
            Coordinates of the protein, `&#39;numpy&#39;` array of shape `(L, 14, 3)` or `(L, 4, 3)`
        masks : np.ndarray
            Mask array where 1 indicates residues with known coordinates and 0
            indicates missing values, `&#39;numpy&#39;` array of shape `(L,)`
        chain_id_dict : dict
            A dictionary mapping chain IDs to indices in `chain_id_array`
        chain_id_array : np.ndarray
            A `&#39;numpy&#39;` array of chain IDs encoded as integers
        predict_masks : np.ndarray, optional
            Mask array where 1 indicates residues that were generated by a model and 0
            indicates residues with known coordinates, `&#39;numpy&#39;` array of shape `(L,)`
        cdrs : np.ndarray, optional
            A `&#39;numpy&#39;` array of shape `(L,)` where residues are marked
            with the corresponding CDR type (encoded as integers, see `proteinflow.constants.CDR_ALPHABET`)
        protein_id : str, optional
            Protein ID

        Returns
        -------
        entry : ProteinEntry
            A `ProteinEntry` object

        &#34;&#34;&#34;
        seqs_list = []
        crds_list = []
        masks_list = []
        chain_ids_list = []
        predict_masks_list = None if predict_masks is None else []
        cdrs_list = None if cdrs is None else []
        for chain_id, ind in chain_id_dict.items():
            chain_ids_list.append(chain_id)
            chain_mask = chain_id_array == ind
            seqs_list.append(ProteinEntry.decode_sequence(seqs[chain_mask]))
            if crds.shape[1] != 14:
                crds_ = np.zeros((crds[chain_mask].shape[0], 14, 3))
                crds_[:, :4, :] = ProteinEntry._to_numpy(crds[chain_mask])
            else:
                crds_ = ProteinEntry._to_numpy(crds[chain_mask])
            crds_list.append(crds_)
            masks_list.append(ProteinEntry._to_numpy(masks[chain_mask]))
            if predict_masks is not None:
                predict_masks_list.append(
                    ProteinEntry._to_numpy(predict_masks[chain_mask])
                )
            if cdrs is not None:
                cdrs_list.append(ProteinEntry.decode_cdr(cdrs[chain_mask]))
        return ProteinEntry(
            seqs_list,
            crds_list,
            masks_list,
            chain_ids_list,
            predict_masks_list,
            cdrs_list,
            protein_id,
        )

    @staticmethod
    def from_dict(dictionary):
        &#34;&#34;&#34;Load a protein entry from a dictionary.

        Parameters
        ----------
        dictionary : dict
            A nested dictionary where first-level keys are chain IDs and
            second-level keys are the following:
            - `&#39;seq&#39;` : amino acid sequence (one-letter code)
            - `&#39;crd_bb&#39;` : backbone coordinates, shaped `(L, 4, 3)`
            - `&#39;crd_sc&#39;` : sidechain coordinates, shaped `(L, 10, 3)`
            - `&#39;msk&#39;` : mask array where 1 indicates residues with known coordinates and 0
                indicates missing values, shaped `(L,)`
            - `&#39;cdr&#39;` (optional): CDR information, shaped `(L,)` where CDR residues are marked
                with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...) and non-CDR residues are marked with `&#39;-&#39;`
            - `&#39;predict_msk&#39;` (optional): mask array where 1 indicates residues that were generated by a model and 0
                indicates residues with known coordinates, shaped `(L,)`
            It can also contain a `&#39;protein_id&#39;` first-level key.

        Returns
        -------
        entry : ProteinEntry
            A `ProteinEntry` object

        &#34;&#34;&#34;
        chains = sorted([x for x in dictionary.keys() if x != &#34;protein_id&#34;])
        seq = [dictionary[k][&#34;seq&#34;] for k in chains]
        crd = [
            np.concatenate([dictionary[k][&#34;crd_bb&#34;], dictionary[k][&#34;crd_sc&#34;]], axis=1)
            for k in chains
        ]
        mask = [dictionary[k][&#34;msk&#34;] for k in chains]
        cdr = [dictionary[k].get(&#34;cdr&#34;, None) for k in chains]
        predict_mask = [dictionary[k].get(&#34;predict_msk&#34;, None) for k in chains]
        return ProteinEntry(
            seqs=seq,
            crds=crd,
            masks=mask,
            cdrs=cdr,
            chain_ids=chains,
            predict_masks=predict_mask,
            protein_id=dictionary.get(&#34;protein_id&#34;),
        )

    @staticmethod
    def from_pdb_entry(pdb_entry):
        &#34;&#34;&#34;Load a protein entry from a `PDBEntry` object.

        Parameters
        ----------
        pdb_entry : PDBEntry
            A `PDBEntry` object

        Returns
        -------
        entry : ProteinEntry
            A `ProteinEntry` object

        &#34;&#34;&#34;
        pdb_dict = {}
        fasta_dict = pdb_entry.get_fasta()
        for (chain,) in pdb_entry.get_chains():
            pdb_dict[chain] = {}
            fasta_seq = fasta_dict[chain]

            # align fasta and pdb and check criteria)
            mask = pdb_entry.get_mask([chain])[chain]
            if isinstance(pdb_entry, SAbDabEntry):
                pdb_dict[chain][&#34;cdr&#34;] = pdb_entry.get_cdr([chain])[chain]
            pdb_dict[chain][&#34;seq&#34;] = fasta_seq
            pdb_dict[chain][&#34;msk&#34;] = mask

            # go over rows of coordinates
            crd_arr = pdb_entry.get_coordinates_array(chain)

            pdb_dict[chain][&#34;crd_bb&#34;] = crd_arr[:, :4, :]
            pdb_dict[chain][&#34;crd_sc&#34;] = crd_arr[:, 4:, :]
            pdb_dict[chain][&#34;msk&#34;][
                (pdb_dict[chain][&#34;crd_bb&#34;] == 0).sum(-1).sum(-1) == 4
            ] = 0
        pdb_dict[&#34;protein_id&#34;] = pdb_entry.pdb_id
        return ProteinEntry.from_dict(pdb_dict)

    @staticmethod
    def from_pdb(
        pdb_path,
        fasta_path=None,
        heavy_chain=None,
        light_chain=None,
        antigen_chains=None,
    ):
        &#34;&#34;&#34;Load a protein entry from a PDB file.

        Parameters
        ----------
        pdb_path : str
            Path to the PDB file
        fasta_path : str, optional
            Path to the FASTA file; if not specified, the sequence is extracted
            from the PDB file
        heavy_chain : str, optional
            Chain ID of the heavy chain (to load a SAbDab entry)
        light_chain : str, optional
            Chain ID of the light chain (to load a SAbDab entry)
        antigen_chains : list of str, optional
            Chain IDs of the antigen chains (to load a SAbDab entry)

        Returns
        -------
        entry : ProteinEntry
            A `ProteinEntry` object

        &#34;&#34;&#34;
        if heavy_chain is not None or light_chain is not None:
            pdb_entry = SAbDabEntry(
                pdb_path=pdb_path,
                fasta_path=fasta_path,
                heavy_chain=heavy_chain,
                light_chain=light_chain,
                antigen_chains=antigen_chains,
            )
        else:
            pdb_entry = PDBEntry(pdb_path=pdb_path, fasta_path=fasta_path)
        return ProteinEntry.from_pdb_entry(pdb_entry)

    @staticmethod
    def from_id(
        pdb_id,
        local_folder=&#34;.&#34;,
        heavy_chain=None,
        light_chain=None,
        antigen_chains=None,
    ):
        &#34;&#34;&#34;Load a protein entry from a PDB file.

        Parameters
        ----------
        pdb_id : str
            PDB ID of the protein
        local_folder : str, default &#34;.&#34;
            Path to the local folder where the PDB file is saved
        heavy_chain : str, optional
            Chain ID of the heavy chain (to load a SAbDab entry)
        light_chain : str, optional
            Chain ID of the light chain (to load a SAbDab entry)
        antigen_chains : list of str, optional
            Chain IDs of the antigen chains (to load a SAbDab entry)

        Returns
        -------
        entry : ProteinEntry
            A `ProteinEntry` object

        &#34;&#34;&#34;
        if heavy_chain is not None or light_chain is not None:
            pdb_entry = SAbDabEntry.from_id(
                pdb_id=pdb_id,
                local_folder=local_folder,
                heavy_chain=heavy_chain,
                light_chain=light_chain,
                antigen_chains=antigen_chains,
            )
        else:
            pdb_entry = PDBEntry.from_id(pdb_id=pdb_id)
        return ProteinEntry.from_pdb_entry(pdb_entry)

    @staticmethod
    def from_pickle(path):
        &#34;&#34;&#34;Load a protein entry from a pickle file.

        Parameters
        ----------
        path : str
            Path to the pickle file

        Returns
        -------
        entry : ProteinEntry
            A `ProteinEntry` object

        &#34;&#34;&#34;
        with open(path, &#34;rb&#34;) as f:
            data = pickle.load(f)
        return ProteinEntry.from_dict(data)

    @staticmethod
    def retrieve_ligands_from_pickle(path):
        &#34;&#34;&#34;Retrieve ligands from a pickle file.

        Parameters
        ----------
        path : str
            Path to the pickle file

        Returns
        -------
        chain2ligand : dict
            A dictionary where keys are chain IDs and values are ligand names

        &#34;&#34;&#34;
        with open(path, &#34;rb&#34;) as f:
            data = pickle.load(f)
        chain2ligand = {}
        for chain in data:
            if &#34;ligand&#34; not in data[chain]:
                continue
            chain2ligand[chain] = data[chain][&#34;ligand&#34;]
        return chain2ligand

    def to_dict(self):
        &#34;&#34;&#34;Convert a protein entry into a dictionary.

        Returns
        -------
        dictionary : dict
            A nested dictionary where first-level keys are chain IDs and
            second-level keys are the following:
            - `&#39;seq&#39;` : amino acid sequence (one-letter code)
            - `&#39;crd_bb&#39;` : backbone coordinates, shaped `(L, 4, 3)`
            - `&#39;crd_sc&#39;` : sidechain coordinates, shaped `(L, 10, 3)`
            - `&#39;msk&#39;` : mask array where 1 indicates residues with known coordinates and 0
                indicates missing values, shaped `(L,)`
            - `&#39;cdr&#39;` (optional): CDR information, shaped `(L,)` encoded as integers where each
                integer corresponds to the index of the CDR type in
                `proteinflow.constants.CDR_ALPHABET`
            - `&#39;predict_msk&#39;` (optional): mask array where 1 indicates residues that were generated by a model and 0
                indicates residues with known coordinates, shaped `(L,)`
            It can optionally also contain `protein_id` as a first-level key.

        &#34;&#34;&#34;
        data = {}
        for chain in self.get_chains():
            data[chain] = {
                &#34;seq&#34;: self.seq[chain],
                &#34;crd_bb&#34;: self.crd[chain][:, :4],
                &#34;crd_sc&#34;: self.crd[chain][:, 4:],
                &#34;msk&#34;: self.mask[chain],
            }
            if self.cdr[chain] is not None:
                data[chain][&#34;cdr&#34;] = self.cdr[chain]
            if self.predict_mask[chain] is not None:
                data[chain][&#34;predict_msk&#34;] = self.predict_mask[chain]
        if self.id is not None:
            data[&#34;protein_id&#34;] = self.id
        return data

    def to_pdb(
        self,
        path,
        only_ca=False,
        skip_oxygens=False,
        only_backbone=False,
        title=None,
    ):
        &#34;&#34;&#34;Save the protein entry to a PDB file.

        Parameters
        ----------
        path : str
            Path to the output PDB file
        only_ca : bool, default False
            If `True`, only backbone atoms are saved
        skip_oxygens : bool, default False
            If `True`, oxygen atoms are not saved
        only_backbone : bool, default False
            If `True`, only backbone atoms are saved
        title : str, optional
            Title of the PDB file (by default either the protein id or &#34;Untitled&#34;)

        &#34;&#34;&#34;
        pdb_builder = PDBBuilder(
            self,
            only_ca=only_ca,
            skip_oxygens=skip_oxygens,
            only_backbone=only_backbone,
        )
        if title is None:
            if self.id is not None:
                title = self.id
            else:
                title = &#34;Untitled&#34;
        pdb_builder.save_pdb(path, title=title)

    def to_pickle(self, path):
        &#34;&#34;&#34;Save a protein entry to a pickle file.

        The output files are pickled nested dictionaries where first-level keys are chain Ids and second-level keys are the following:
        - `&#39;crd_bb&#39;`: a `numpy` array of shape `(L, 4, 3)` with backbone atom coordinates (N, C, CA, O),
        - `&#39;crd_sc&#39;`: a `numpy` array of shape `(L, 10, 3)` with sidechain atom coordinates (check `proteinflow.sidechain_order()` for the order of atoms),
        - `&#39;msk&#39;`: a `numpy` array of shape `(L,)` where ones correspond to residues with known coordinates and
            zeros to missing values,
        - `&#39;seq&#39;`: a string of length `L` with residue types.

        In a SAbDab datasets, an additional key is added to the dictionary:
        - `&#39;cdr&#39;`: a `&#39;numpy&#39;` array of shape `(L,)` where CDR residues are marked with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...)
            and non-CDR residues are marked with `&#39;-&#39;`.

        If a prediction mask is available, another additional key is added to the dictionary:
        - `&#39;predict_msk&#39;`: a `numpy` array of shape `(L,)` where ones correspond to residues that were generated by a model and
            zeros to residues with known coordinates.

        Parameters
        ----------
        path : str
            Path to the pickle file

        &#34;&#34;&#34;
        data = self.to_dict()
        with open(path, &#34;wb&#34;) as f:
            pickle.dump(data, f)

    def dihedral_angles(self, chains=None):
        &#34;&#34;&#34;Calculate the backbone dihedral angles (phi, psi) of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the dihedral angles of the specified chains are returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        Returns
        -------
        angles : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L, 2)` with backbone dihedral angles
            (phi, psi) in degrees; missing values are marked with zeros
        chains : list of str, optional
            If specified, only the dihedral angles of the specified chains are returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        &#34;&#34;&#34;
        angles = []
        chains = self._get_chains_list(chains)
        # N, C, Ca, O
        # psi
        for chain in chains:
            chain_angles = []
            crd = self.get_coordinates([chain])
            mask = self.get_mask([chain])
            p = crd[:-1, [0, 2, 1], :]
            p = np.concatenate([p, crd[1:, [0], :]], 1)
            p = np.pad(p, ((0, 1), (0, 0), (0, 0)))
            chain_angles.append(_dihedral_angle(p, mask))
            # phi
            p = crd[:-1, [1], :]
            p = np.concatenate([p, crd[1:, [0, 2, 1]]], 1)
            p = np.pad(p, ((1, 0), (0, 0), (0, 0)))
            chain_angles.append(_dihedral_angle(p, mask))
            angles.append(np.stack(chain_angles, -1))
        angles = np.concatenate(angles, 0)
        return angles

    def secondary_structure(self, chains=None):
        &#34;&#34;&#34;Calculate the secondary structure of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the secondary structure of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        Returns
        -------
        sse : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L, 3)` with secondary structure
            elements encoded as one-hot vectors (alpha-helix, beta-sheet, loop);
            missing values are marked with zeros
        chains : list of str, optional
            If specified, only the secondary structure of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        out = []
        for chain in chains:
            crd = self.get_coordinates([chain])
            sse_map = {&#34;c&#34;: [0, 0, 1], &#34;b&#34;: [0, 1, 0], &#34;a&#34;: [1, 0, 0], &#34;&#34;: [0, 0, 0]}
            sse = _annotate_sse(crd[:, :4])
            out += [sse_map[x] for x in sse]
        sse = np.array(out)
        return sse

    def sidechain_coordinates(self, chains=None):
        &#34;&#34;&#34;Get the sidechain coordinates of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the sidechain coordinates of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        Returns
        -------
        crd : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L, 10, 3)` with sidechain atom
            coordinates (check `proteinflow.sidechain_order()` for the order of
            atoms); missing values are marked with zeros
        chains : list of str, optional
            If specified, only the sidechain coordinates of the specified chains are returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        return self.get_coordinates(chains)[:, 4:, :]

    def chemical_features(self, chains=None):
        &#34;&#34;&#34;Calculate chemical features of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the chemical features of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        Returns
        -------
        features : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L, 4)` with chemical features of the
            protein (hydropathy, volume, charge, polarity, acceptor/donor); missing
            values are marked with zeros
        chains : list of str, optional
            If specified, only the chemical features of the specified chains are returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        seq = &#34;&#34;.join([self.seq[chain] for chain in chains])
        features = np.array([_PMAP(x) for x in seq])
        return features

    def sidechain_orientation(self, chains=None):
        &#34;&#34;&#34;Calculate the (global) sidechain orientation of the protein.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the sidechain orientation of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        Returns
        -------
        orientation : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L, 3)` with sidechain orientation
            vectors; missing values are marked with zeros
        chains : list of str, optional
            If specified, only the sidechain orientation of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        crd = self.get_coordinates(chains=chains)
        crd_bb, crd_sc = crd[:, :4, :], crd[:, 4:, :]
        seq = self.get_sequence(chains=chains, encode=True)
        orientation = np.zeros((crd_sc.shape[0], 3))
        for i in range(1, 21):
            if MAIN_ATOM_DICT[i] is not None:
                orientation[seq == i] = (
                    crd_sc[seq == i, MAIN_ATOM_DICT[i], :] - crd_bb[seq == i, 2, :]
                )
            else:
                S_mask = self.seq == i
                orientation[S_mask] = np.random.rand(*orientation[S_mask].shape)
        orientation /= np.expand_dims(np.linalg.norm(orientation, axis=-1), -1) + 1e-7
        return orientation

    @lru_cache()
    def is_valid_pair(self, chain1, chain2, cutoff=10):
        &#34;&#34;&#34;Check if two chains are a valid pair based on the distance between them.

        We consider two chains to be a valid pair if the distance between them is
        smaller than `cutoff` Angstroms. The distance is calculated as the minimum
        distance between any two atoms of the two chains.

        Parameters
        ----------
        chain1 : str
            Chain ID of the first chain
        chain2 : str
            Chain ID of the second chain
        cutoff : int, optional
            Minimum distance between the two chains (in Angstroms)

        Returns
        -------
        valid : bool
            `True` if the two chains are a valid pair, `False` otherwise

        &#34;&#34;&#34;
        margin = cutoff * 3
        assert chain1 in self.get_chains(), f&#34;Chain {chain1} not found&#34;
        assert chain2 in self.get_chains(), f&#34;Chain {chain2} not found&#34;
        X1 = self.get_coordinates(chains=[chain1], only_known=True)
        X2 = self.get_coordinates(chains=[chain2], only_known=True)
        intersect_dim_X1 = []
        intersect_dim_X2 = []
        intersect_X1 = np.zeros(len(X1))
        intersect_X2 = np.zeros(len(X2))
        for dim in range(3):
            min_dim_1 = X1[:, 2, dim].min()
            max_dim_1 = X1[:, 2, dim].max()
            min_dim_2 = X2[:, 2, dim].min()
            max_dim_2 = X2[:, 2, dim].max()
            intersect_dim_X1.append(
                np.where(
                    np.logical_and(
                        X1[:, 2, dim] &gt;= min_dim_2 - margin,
                        X1[:, 2, dim] &lt;= max_dim_2 + margin,
                    )
                )[0]
            )
            intersect_dim_X2.append(
                np.where(
                    np.logical_and(
                        X2[:, 2, dim] &gt;= min_dim_1 - margin,
                        X2[:, 2, dim] &lt;= max_dim_1 + margin,
                    )
                )[0]
            )

        intersect_X1 = np.intersect1d(
            np.intersect1d(intersect_dim_X1[0], intersect_dim_X1[1]),
            intersect_dim_X1[2],
        )
        intersect_X2 = np.intersect1d(
            np.intersect1d(intersect_dim_X2[0], intersect_dim_X2[1]),
            intersect_dim_X2[2],
        )

        not_end_mask1 = np.where((X1[:, 2, :] == 0).sum(-1) != 3)[0]
        not_end_mask2 = np.where((X2[:, 2, :] == 0).sum(-1) != 3)[0]

        intersect_X1 = np.intersect1d(intersect_X1, not_end_mask1)
        intersect_X2 = np.intersect1d(intersect_X2, not_end_mask2)

        diff = X1[intersect_X1, 2, np.newaxis, :] - X2[intersect_X2, 2, :]
        distances = np.sqrt(np.sum(diff**2, axis=2))

        if np.sum(distances &lt; cutoff) &lt; 3:
            return False
        else:
            return True

    def get_index_array(self, chains=None, index_bump=100):
        &#34;&#34;&#34;Get the index array of the protein.

        The index array is a `&#39;numpy&#39;` array of shape `(L,)` with the index of each residue along the chain.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the index array of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs
        index_bump : int, default 0
            If specified, the index is bumped by this number between chains

        Returns
        -------
        index_array : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L,)` with the index of each residue along the chain; if multiple chains
            are specified, the index is bumped by `index_bump` at the beginning of each chain

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        start_value = 0
        start_index = 0
        index_array = np.zeros(self.get_length(chains))
        for chain in chains:
            chain_length = self.get_length([chain])
            index_array[start_index : start_index + chain_length] = np.arange(
                start_value, start_value + chain_length
            )
            start_value += chain_length + index_bump
            start_index += chain_length
        return index_array.astype(int)

    def get_chain_id_dict(self, chains=None):
        &#34;&#34;&#34;Get the dictionary mapping from chain indices to chain IDs.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the chain IDs of the specified chains are returned

        Returns
        -------
        chain_id_dict : dict
            A dictionary mapping from chain indices to chain IDs

        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        chain_id_dict = {x: i for i, x in enumerate(self.get_chains()) if x in chains}
        return chain_id_dict

    def get_chain_id_array(self, chains=None, encode=True):
        &#34;&#34;&#34;Get the chain ID array of the protein.

        The chain ID array is a `&#39;numpy&#39;` array of shape `(L,)` with the chain ID of each residue.
        The chain ID is the index of the chain in the alphabetical order of the chain IDs. To get a
        mapping from the index to the chain ID, use `get_chain_id_dict()`.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the chain ID array of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs
        encode : bool, default True
            If True, the chain ID is encoded as an integer; otherwise, the chain ID is the chain ID string

        Returns
        -------
        chain_id_array : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L,)` with the chain ID of each residue

        &#34;&#34;&#34;
        id_dict = self.get_chain_id_dict()
        if encode:
            index_array = np.zeros(self.get_length(chains))
        else:
            index_array = np.empty(self.get_length(chains), dtype=object)
        start_index = 0
        for chain in self._get_chains_list(chains):
            chain_length = self.get_length([chain])
            index_array[start_index : start_index + chain_length] = (
                id_dict[chain] if encode else chain
            )
            start_index += chain_length
        return index_array

    def get_ligand_features(self, ligands, chains=None):
        &#34;&#34;&#34;Get ligand coordinates, smiles, and chain mapping.

        Parameters
        ----------
        ligands : dict
            A dictionary mapping from chain IDs to a list of ligands, where each ligand is a dictionary
        chains : list of str, optional
            If specified, only the ligands of the specified chains are returned (in the same order);
            otherwise, all ligands are concatenated in alphabetical order of the chain IDs

        Returns
        -------
        X_ligands : torch.Tensor
            A `&#39;torch&#39;` tensor of shape `(N, 3)` with the ligand coordinates
        ligand_smiles : str
            A string with the ligand smiles separated by a dot
        ligand_chains : torch.Tensor
            A `&#39;torch&#39;` tensor of shape `(N, 1)` with the chain index of each atom
        &#34;&#34;&#34;
        chains = self._get_chains_list(chains)
        X_ligands = []
        ligand_smiles = []
        ligand_chains = []
        for chain_i, chain in enumerate(chains):
            all_smiles = &#34;.&#34;.join([x[&#34;smiles&#34;] for x in ligands[chain]])
            ligand_smiles.append(all_smiles)
            x_lig = np.concatenate([x[&#34;X&#34;] for x in ligands[chain]])
            X_ligands.append(x_lig)
            ligand_chains += [[chain_i]] * len(x_lig)
        ligand_smiles = &#34;.&#34;.join(ligand_smiles)
        X_ligands = from_numpy(np.concatenate(X_ligands, 0))
        ligand_chains = Tensor(ligand_chains)
        return (
            X_ligands,
            ligand_smiles,
            ligand_chains,
        )

    def _get_highlight_mask_dict(self, highlight_mask=None):
        &#34;&#34;&#34;Turn mask array into a dictionary.&#34;&#34;&#34;
        chain_arr = self.get_chain_id_array(encode=False)
        mask_arr = self.get_mask().astype(bool)
        highlight_mask_dict = {}
        if highlight_mask is not None:
            chains = self.get_chains()
            for chain in chains:
                chain_mask = chain_arr == chain
                pdb_highlight = highlight_mask[mask_arr &amp; chain_mask]
                highlight_mask_dict[chain] = pdb_highlight
        return highlight_mask_dict

    def _get_atom_dicts(
        self,
        highlight_mask=None,
        style=&#34;cartoon&#34;,
        opacity=1,
        colors=None,
        accent_color=&#34;#D96181&#34;,
    ):
        &#34;&#34;&#34;Get the atom dictionaries of the protein.&#34;&#34;&#34;
        highlight_mask_dict = self._get_highlight_mask_dict(highlight_mask)
        pdb_entry = PDBEntry(self._temp_pdb_file())
        return pdb_entry._get_atom_dicts(
            highlight_mask_dict=highlight_mask_dict,
            style=style,
            opacity=opacity,
            colors=colors,
            accent_color=accent_color,
        )

    def get_predict_mask(self, chains=None, only_known=False):
        &#34;&#34;&#34;Get the prediction mask of the protein.

        The prediction mask is a `&#39;numpy&#39;` array of shape `(L,)` with ones
        corresponding to residues that were generated by a model and zeros to
        residues with known coordinates. If the prediction mask is not available,
        `None` is returned.

        Parameters
        ----------
        chains : list of str, optional
            If specified, only the prediction mask of the specified chains is returned (in the same order);
            otherwise, all features are concatenated in alphabetical order of the chain IDs
        only_known : bool, default False
            If `True`, only residues with known coordinates are returned

        Returns
        -------
        predict_mask : np.ndarray
            A `&#39;numpy&#39;` array of shape `(L,)` with ones corresponding to residues that were generated by a model and
            zeros to residues with known coordinates

        &#34;&#34;&#34;
        if list(self.predict_mask.values())[0] is None:
            return None
        chains = self._get_chains_list(chains)
        predict_mask = np.concatenate([self.predict_mask[chain] for chain in chains])
        if only_known:
            mask = self.get_mask(chains=chains)
            predict_mask = predict_mask[mask.astype(bool)]
        return predict_mask

    def visualize(
        self,
        highlight_mask=None,
        style=&#34;cartoon&#34;,
        highlight_style=None,
        opacity=1,
        canvas_size=(400, 300),
    ):
        &#34;&#34;&#34;Visualize the protein in a notebook.

        Parameters
        ----------
        highlight_mask : np.ndarray, optional
            A `&#39;numpy&#39;` array of shape `(L,)` with the residues to highlight
            marked with 1 and the rest marked with 0; if not given and
            `self.predict_mask` is not `None`, the predicted residues are highlighted
        style : str, default &#39;cartoon&#39;
            The style of the visualization; one of &#39;cartoon&#39;, &#39;sphere&#39;, &#39;stick&#39;, &#39;line&#39;, &#39;cross&#39;
        highlight_style : str, optional
            The style of the highlighted atoms; one of &#39;cartoon&#39;, &#39;sphere&#39;, &#39;stick&#39;, &#39;line&#39;, &#39;cross&#39;
            (defaults to the same as `style`)
        opacity : float or dict, default 1
            Opacity of the visualization (can be a dictionary mapping from chain IDs to opacity values)
        canvas_size : tuple, default (400, 300)
            Shape of the canvas

        &#34;&#34;&#34;
        if highlight_mask is not None:
            highlight_mask_dict = self._get_highlight_mask_dict(highlight_mask)
        elif list(self.predict_mask.values())[0] is not None:
            highlight_mask_dict = {
                chain: self.predict_mask[chain][self.get_mask([chain]).astype(bool)]
                for chain in self.get_chains()
            }
        else:
            highlight_mask_dict = None
        with tempfile.NamedTemporaryFile(suffix=&#34;.pdb&#34;) as tmp:
            self.to_pdb(tmp.name)
            pdb_entry = PDBEntry(tmp.name)
        pdb_entry.visualize(
            highlight_mask_dict=highlight_mask_dict,
            style=style,
            highlight_style=highlight_style,
            opacity=opacity,
            canvas_size=canvas_size,
        )

    def blosum62_score(self, seq_before, average=True, only_predicted=True):
        &#34;&#34;&#34;Calculate the BLOSUM62 score of the protein.

        Parameters
        ----------
        seq_before : str
            A string with the sequence before the mutation
        average : bool, default True
            If `True`, the score is averaged over the residues; otherwise, the score is summed
        only_predicted : bool, default True
            If `True` and prediction masks are available, only predicted residues are considered

        Returns
        -------
        score : float
            The BLOSUM62 score of the protein

        &#34;&#34;&#34;
        seq_after = self.get_sequence(encode=False)
        if self.predict_mask is not None and only_predicted:
            predict_mask = self.get_predict_mask()
            seq_before = np.array(list(seq_before))[predict_mask.astype(bool)]
            seq_after = np.array(list(seq_after))[predict_mask.astype(bool)]
        score = blosum62_score(seq_before, seq_after)
        if average:
            score /= len(seq_before)
        return score

    def long_repeat_num(self, thr=5):
        &#34;&#34;&#34;Calculate the number of long repeats in the protein.

        Parameters
        ----------
        thr : int, default 5
            The threshold for the minimum length of the repeat

        Returns
        -------
        num : int
            The number of long repeats in the protein

        &#34;&#34;&#34;
        seq = self.get_sequence(encode=False)
        if self.predict_mask is not None:
            predict_mask = self.get_predict_mask()
            seq = np.array(list(seq))[predict_mask.astype(bool)]
        return long_repeat_num(seq, thr=thr)

    def esm_pll(
        self,
        esm_model_name=&#34;esm2_t30_150M_UR50D&#34;,
        esm_model_objects=None,
        average=False,
    ):
        &#34;&#34;&#34;Calculate the ESM PLL score of the protein.

        Parameters
        ----------
        esm_model_name : str, default &#34;esm2_t30_150M_UR50D&#34;
            Name of the ESM-2 model to use
        esm_model_objects : tuple, optional
            Tuple of ESM-2 model, batch converter and tok_to_idx dictionary (if not None, `esm_model_name` will be ignored)
        average : bool, default False
            If `True`, the score is averaged over the residues; otherwise, the score is summed

        Returns
        -------
        score : float
            The ESM PLL score of the protein

        &#34;&#34;&#34;
        chains = self.get_chains()
        chain_sequences = [self.get_sequence(chains=[chain]) for chain in chains]
        if self.predict_mask is not None:
            predict_masks = [
                (self.get_predict_mask(chains=[chain])).astype(float)
                for chain in chains
            ]
        else:
            predict_masks = [np.ones(len(x)) for x in chain_sequences]
        return esm_pll(
            chain_sequences,
            predict_masks,
            esm_model_name=esm_model_name,
            esm_model_objects=esm_model_objects,
            average=average,
        )

    def ablang_pll(self, ablang_model_name=&#34;heavy&#34;, average=False):
        &#34;&#34;&#34;Calculate the AbLang PLL score of the protein.

        Parameters
        ----------
        ablang_model_name : str, default &#34;heavy&#34;
            Name of the AbLang model to use
        average : bool, default False
            If `True`, the score is averaged over the residues; otherwise, the score is summed

        Returns
        -------
        score : float
            The AbLang PLL score of the protein

        &#34;&#34;&#34;
        chains = self.get_predicted_chains()
        chain_sequences = [self.get_sequence(chains=[chain]) for chain in chains]
        if self.predict_mask is not None:
            predict_masks = [
                (self.get_predict_mask(chains=[chain])).astype(float)
                for chain in chains
            ]
        else:
            predict_masks = [np.ones(len(x)) for x in chain_sequences]
        out = sum(
            [
                ablang_pll(
                    sequence,
                    predict_mask,
                    ablang_model_name=ablang_model_name,
                    average=False,
                )
                for sequence, predict_mask in zip(chain_sequences, predict_masks)
            ]
        )
        if average:
            out /= self.get_predict_mask(chains=chains).sum()
        return out

    def accuracy(self, seq_before):
        &#34;&#34;&#34;Calculate the accuracy of the protein.

        Parameters
        ----------
        seq_before : str
            A string with the sequence before the mutation

        Returns
        -------
        score : float
            The accuracy of the protein

        &#34;&#34;&#34;
        seq_after = self.get_sequence(encode=False)
        seq_before = np.array(list(seq_before))
        seq_after = np.array(list(seq_after))
        if self.predict_mask is not None:
            predict_mask = self.get_predict_mask()
            seq_before = seq_before[predict_mask.astype(bool)]
            seq_after = seq_after[predict_mask.astype(bool)]
        return np.mean(seq_before == seq_after)

    def ca_rmsd(self, entry, only_predicted=True):
        &#34;&#34;&#34;Calculate CA RMSD between two proteins.

        Parameters
        ----------
        entry : ProteinEntry
            A `ProteinEntry` object
        only_predicted : bool, default True
            If `True` and prediction masks are available, only predicted residues are considered

        Returns
        -------
        rmsd : float
            The CA RMSD between the two proteins

        &#34;&#34;&#34;
        if only_predicted and not self.has_predict_mask():
            only_predicted = False
        chains = [x for x in self.get_chains() if x in entry.get_chains()]
        structure1 = self.get_coordinates(only_known=True, chains=chains)[:, 2]
        structure2 = entry.get_coordinates(only_known=True, chains=chains)[:, 2]
        if only_predicted:
            mask = self.get_predict_mask(only_known=True, chains=chains).astype(bool)
            structure1 = structure1[mask]
            structure2 = structure2[mask]
        return ca_rmsd(structure1, structure2)

    def tm_score(self, entry, chains=None):
        &#34;&#34;&#34;Calculate TM score between two proteins.

        Parameters
        ----------
        entry : ProteinEntry
            A `ProteinEntry` object
        chains : list of str, optional
            A list of chain IDs to consider

        Returns
        -------
        tm_score : float
            The TM score between the two proteins

        &#34;&#34;&#34;
        structure1 = self.get_coordinates(only_known=True, chains=chains)[:, 2]
        structure2 = entry.get_coordinates(only_known=True, chains=chains)[:, 2]
        sequence1 = self.get_sequence(only_known=True, chains=chains)
        sequence2 = entry.get_sequence(only_known=True, chains=chains)
        return tm_score(structure1, structure2, sequence1, sequence2)

    def _temp_pdb_file(self):
        &#34;&#34;&#34;Save a protein entry to a temporary PDB file.&#34;&#34;&#34;
        with tempfile.NamedTemporaryFile(suffix=&#34;.pdb&#34;, delete=False) as tmp:
            self.to_pdb(tmp.name)
        return tmp.name

    @staticmethod
    def esmfold_metrics(entries, only_antibody=False):
        &#34;&#34;&#34;Calculate ESMFold metrics for a list of entries.

        Parameters
        ----------
        entries : list of ProteinEntry
            A list of `ProteinEntry` objects
        only_antibody : bool, default False
            If `True`, only antibody chains are considered

        Returns
        -------
        plddts_full : list of float
            A list of PLDDT scores averaged over all residues
        plddts_predicted : list of float
            A list of PLDDT scores averaged over predicted residues
        rmsd : list of float
            A list of RMSD values of aligned structures (predicted residues only)
        tm_score : list of float, optional
            A list of TM scores of aligned structures

        &#34;&#34;&#34;
        sequences = []
        chains_list = [
            [
                x
                for x in entry.get_chains()
                if not entry.has_cdr()
                or not only_antibody
                or x not in entry.get_chain_type_dict()[&#34;antigen&#34;]
            ]
            for entry in entries
        ]
        for chains, entry in zip(chains_list, entries):
            sequences.append(
                &#34;:&#34;.join(
                    [
                        entry.get_sequence(chains=[chain], only_known=True)
                        for chain in chains
                    ]
                )
            )
        esmfold_generate(sequences)
        esmfold_paths = [
            os.path.join(&#34;esmfold_output&#34;, f&#34;seq_{i}.pdb&#34;)
            for i in range(len(sequences))
        ]
        plddts_predicted = [
            confidence_from_file(
                path, entry.get_predict_mask(only_known=True, chains=chains)
            )
            for path, entry, chains in zip(esmfold_paths, entries, chains_list)
        ]
        plddts_full = [confidence_from_file(path) for path in esmfold_paths]
        rmsds = []
        tm_scores = []
        for entry, path in zip(entries, esmfold_paths):
            chains = [
                x
                for x in entry.get_chains()
                if not entry.has_cdr()
                or not only_antibody
                or x not in entry.get_chain_type_dict()[&#34;antigen&#34;]
            ]
            esm_entry = ProteinEntry.from_pdb(path)
            chain_rename_dict = {k: v for k, v in zip(string.ascii_uppercase, chains)}
            esm_entry.rename_chains(chain_rename_dict)
            temp_file = entry._temp_pdb_file()
            esm_entry.align_structure(
                reference_pdb_path=temp_file,
                save_pdb_path=path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;,
                chain_ids=entry.get_predicted_chains()
                if entry.has_predict_mask()
                else chains,
            )
            rmsds.append(
                entry.ca_rmsd(
                    ProteinEntry.from_pdb(path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;)
                )
            )
            tm_scores.append(
                entry.tm_score(
                    esm_entry,
                    chains=chains,
                )
            )
        return plddts_full, plddts_predicted, rmsds, tm_scores

    @staticmethod
    def igfold_metrics(entries, use_openmm=False):
        &#34;&#34;&#34;Calculate IgFold metrics for a list of entries.

        Parameters
        ----------
        entries : list of ProteinEntry
            A list of `ProteinEntry` objects
        use_openmm : bool, default False
            Whether to use refinement with OpenMM

        Returns
        -------
        plddts_full : list of float
            A list of PLDDT scores averaged over all residues
        plddts_predicted : list of float
            A list of PLDDT scores averaged over predicted residues
        rmsds : list of float
            A list of RMSD values of aligned structures (predicted residues only)
        tm_scores : list of float
            A list of TM scores of individual chains (self-consistency)

        &#34;&#34;&#34;
        chains_list = [
            [
                x
                for x in entry.get_chains()
                if x not in entry.get_chain_type_dict()[&#34;antigen&#34;]
            ]
            for entry in entries
        ]
        sequences = [
            {
                chain: entry.get_sequence(chains=[chain], only_known=True)
                for chain in chains
            }
            for entry, chains in zip(entries, chains_list)
        ]
        igfold_generate(sequences, use_openmm=use_openmm)
        folder = &#34;igfold_refine_output&#34; if use_openmm else &#34;igfold_output&#34;
        igfold_paths = [
            os.path.join(folder, f&#34;seq_{i}.pdb&#34;) for i in range(len(sequences))
        ]
        prmsds_predicted = [
            confidence_from_file(
                path, entry.get_predict_mask(only_known=True, chains=chains)
            )
            for path, entry, chains in zip(igfold_paths, entries, chains_list)
        ]
        prmsds_full = [confidence_from_file(path) for path in igfold_paths]
        rmsds = []
        tm_scores = []
        for entry, path in zip(entries, igfold_paths):
            igfold_entry = ProteinEntry.from_pdb(path)
            temp_file = entry._temp_pdb_file()
            igfold_entry.align_structure(
                reference_pdb_path=temp_file,
                save_pdb_path=path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;,
                chain_ids=entry.get_predicted_chains(),
            )
            rmsds.append(
                entry.ca_rmsd(
                    ProteinEntry.from_pdb(path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;)
                )
            )
            tm_scores.append(
                entry.tm_score(
                    igfold_entry,
                )
            )
        return prmsds_full, prmsds_predicted, rmsds, tm_scores

    @staticmethod
    def immunebuilder_metrics(entries, protein_type=&#34;antibody&#34;):
        &#34;&#34;&#34;Calculate ImmuneBuilder metrics for a list of entries.

        Parameters
        ----------
        entries : list of ProteinEntry
            A list of `ProteinEntry` objects
        protein_type : {&#34;antibody&#34;, &#34;nanobody&#34;, &#34;tcr&#34;}, default &#34;antibody&#34;
            The type of the protein

        Returns
        -------
        prmsds_full : list of float
            A list of PRMSD scores averaged over all residues
        prmsds_predicted : list of float
            A list of PRMSD scores averaged over predicted residues
        rmsds : list of float
            A list of RMSD values of aligned structures (predicted residues only)
        tm_scores : list of float
            A list of TM scores of aligned structures

        &#34;&#34;&#34;
        sequences = []
        chains_list = [
            [
                x
                for x in entry.get_chains()
                if x not in entry.get_chain_type_dict()[&#34;antigen&#34;]
            ]
            for entry in entries
        ]
        for chains, entry in zip(chains_list, entries):
            chain_type_dict = entry.get_chain_type_dict()
            sequences.append(
                {
                    key[0].upper(): entry.get_sequence(
                        chains=[chain_type_dict[key]], only_known=True
                    )
                    for key in [&#34;heavy&#34;, &#34;light&#34;]
                    if key in chain_type_dict
                }
            )
        immunebuilder_generate(sequences, protein_type=protein_type)
        generated_paths = [
            os.path.join(&#34;immunebuilder_output&#34;, f&#34;seq_{i}.pdb&#34;)
            for i in range(len(sequences))
        ]
        prmsds_predicted = [
            confidence_from_file(
                path, entry.get_predict_mask(only_known=True, chains=chains)
            )
            for path, entry, chains in zip(generated_paths, entries, chains_list)
        ]
        prmsds_full = [confidence_from_file(path) for path in generated_paths]
        rmsds = []
        tm_scores = []
        for entry, path, chains in zip(entries, generated_paths, chains_list):
            generated_entry = ProteinEntry.from_pdb(path)
            chain_type_dict = entry.get_chain_type_dict()
            chain_rename_dict = {}
            if &#34;light&#34; in chain_type_dict:
                chain_rename_dict[&#34;L&#34;] = chain_type_dict[&#34;light&#34;]
            if &#34;heavy&#34; in chain_type_dict:
                chain_rename_dict[&#34;H&#34;] = chain_type_dict[&#34;heavy&#34;]
            generated_entry.rename_chains(chain_rename_dict)
            temp_file = entry._temp_pdb_file()
            generated_entry.align_structure(
                reference_pdb_path=temp_file,
                save_pdb_path=path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;,
                chain_ids=entry.get_predicted_chains(),
            )
            rmsds.append(
                entry.ca_rmsd(
                    ProteinEntry.from_pdb(path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;)
                )
            )
            tm_scores.append(
                entry.tm_score(
                    generated_entry,
                    chains=chains,
                )
            )
        return prmsds_full, prmsds_predicted, rmsds, tm_scores

    def align_structure(self, reference_pdb_path, save_pdb_path, chain_ids=None):
        &#34;&#34;&#34;Aligns the structure to a reference structure using the CA atoms.

        Parameters
        ----------
        reference_pdb_path : str
            Path to the reference structure (in .pdb format)
        save_pdb_path : str
            Path where the aligned structure should be saved (in .pdb format)
        chain_ids : list of str, optional
            If specified, only the chains with the specified IDs are aligned

        &#34;&#34;&#34;
        pdb_parser = Bio.PDB.PDBParser(QUIET=True)

        temp_file = self._temp_pdb_file()
        ref_structure = pdb_parser.get_structure(&#34;reference&#34;, reference_pdb_path)
        sample_structure = pdb_parser.get_structure(&#34;sample&#34;, temp_file)

        ref_model = ref_structure[0]
        sample_model = sample_structure[0]

        ref_atoms = []
        sample_atoms = []

        for ref_chain in ref_model:
            if chain_ids is not None and ref_chain.id not in chain_ids:
                continue
            for ref_res in ref_chain:
                if &#34;CA&#34; in ref_res:
                    ref_atoms.append(ref_res[&#34;CA&#34;])
                elif &#34;C&#34; in ref_res:
                    ref_atoms.append(ref_res[&#34;C&#34;])
                    warnings.warn(
                        &#34;Using a C atom instead of CA for alignment in the reference structure&#34;
                    )

        for sample_chain in sample_model:
            if chain_ids is not None and sample_chain.id not in chain_ids:
                continue
            for sample_res in sample_chain:
                if &#34;CA&#34; in sample_res:
                    sample_atoms.append(sample_res[&#34;CA&#34;])
                elif &#34;C&#34; in sample_res:
                    sample_atoms.append(sample_res[&#34;C&#34;])
                    warnings.warn(
                        &#34;Using a C atom instead of CA for alignment in the sample structure&#34;
                    )

        super_imposer = Bio.PDB.Superimposer()
        super_imposer.set_atoms(ref_atoms, sample_atoms)
        super_imposer.apply(sample_model.get_atoms())

        io = Bio.PDB.PDBIO()
        io.set_structure(sample_structure)
        io.save(save_pdb_path)

    @staticmethod
    @requires_extra(&#34;MDAnalysis&#34;)
    def combine_multiple_frames(files, output_path=&#34;combined.pdb&#34;):
        &#34;&#34;&#34;Combine multiple PDB files into a single multiframe PDB file.

        Parameters
        ----------
        files : list of str
            A list of PDB or proteinflow pickle files
        output_path : str, default &#39;combined.pdb&#39;
            Path to the .pdb output file

        &#34;&#34;&#34;
        with mda.Writer(output_path, multiframe=True) as writer:
            for file in files:
                if file.endswith(&#34;.pickle&#34;):
                    file_ = ProteinEntry.from_pickle(file)._temp_pdb_file()
                else:
                    file_ = file
                u = mda.Universe(file_)
                writer.write(u)

    def set_predict_mask(self, mask_dict):
        &#34;&#34;&#34;Set the predicted mask.

        Parameters
        ----------
        mask_dict : dict
            A dictionary mapping from chain IDs to a `np.ndarray` mask of 0s and 1s of the same length as the chain sequence

        &#34;&#34;&#34;
        for chain in mask_dict:
            if chain not in self.get_chains():
                raise PDBError(&#34;Chain not found&#34;)
            if len(mask_dict[chain]) != self.get_length([chain]):
                raise PDBError(&#34;Mask length does not match sequence length&#34;)
        self.predict_mask = mask_dict

    def apply_mask(self, mask):
        &#34;&#34;&#34;Apply a mask to the protein.

        Parameters
        ----------
        mask : np.ndarray
            A boolean mask of shape `(L,)` where `L` is the length of the protein (the chains are concatenated in alphabetical order)

        Returns
        -------
        entry : ProteinEntry
            A new `ProteinEntry` object

        &#34;&#34;&#34;
        start = 0
        out_dict = {}
        for chain in self.get_chains():
            out_dict[chain] = {}
            chain_mask = mask[start : start + self.get_length([chain])]
            start += self.get_length([chain])
            out_dict[chain][&#34;seq&#34;] = self.decode_sequence(
                self.get_sequence(chains=[chain], encode=True)[chain_mask]
            )
            out_dict[chain][&#34;crd_bb&#34;] = self.get_coordinates(
                chains=[chain], bb_only=True
            )[chain_mask]
            out_dict[chain][&#34;crd_sc&#34;] = self.get_coordinates(chains=[chain])[:, 4:][
                chain_mask
            ]
            out_dict[chain][&#34;msk&#34;] = self.get_mask(chains=[chain])[chain_mask]
            if self.has_cdr():
                out_dict[chain][&#34;cdr&#34;] = self.decode_cdr(
                    self.get_cdr([chain], encode=True)[chain_mask]
                )
            if self.has_predict_mask():
                out_dict[chain][&#34;predict_msk&#34;] = self.predict_mask[chain][chain_mask]
        if self.id is not None:
            out_dict[&#34;protein_id&#34;] = self.id
        return ProteinEntry.from_dict(out_dict)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="proteinflow.data.ProteinEntry.ATOM_ORDER"><code class="name">var <span class="ident">ATOM_ORDER</span></code></dt>
<dd>
<div class="desc"><p>A dictionary mapping 3-letter residue names to the order of atoms in the coordinates array.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="proteinflow.data.ProteinEntry.combine_multiple_frames"><code class="name flex">
<span>def <span class="ident">combine_multiple_frames</span></span>(<span>files, output_path='combined.pdb')</span>
</code></dt>
<dd>
<div class="desc"><p>Combine multiple PDB files into a single multiframe PDB file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of PDB or proteinflow pickle files</dd>
<dt><strong><code>output_path</code></strong> :&ensp;<code>str</code>, default <code>'combined.pdb'</code></dt>
<dd>Path to the .pdb output file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@requires_extra(&#34;MDAnalysis&#34;)
def combine_multiple_frames(files, output_path=&#34;combined.pdb&#34;):
    &#34;&#34;&#34;Combine multiple PDB files into a single multiframe PDB file.

    Parameters
    ----------
    files : list of str
        A list of PDB or proteinflow pickle files
    output_path : str, default &#39;combined.pdb&#39;
        Path to the .pdb output file

    &#34;&#34;&#34;
    with mda.Writer(output_path, multiframe=True) as writer:
        for file in files:
            if file.endswith(&#34;.pickle&#34;):
                file_ = ProteinEntry.from_pickle(file)._temp_pdb_file()
            else:
                file_ = file
            u = mda.Universe(file_)
            writer.write(u)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.decode_cdr"><code class="name flex">
<span>def <span class="ident">decode_cdr</span></span>(<span>cdr)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the CDR information.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cdr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A <code>'numpy'</code> array of shape <code>(L,)</code> encoded as integers where each
integer corresponds to the index of the CDR type in
<code>proteinflow.constants.CDR_ALPHABET</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cdr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A <code>'numpy'</code> array of shape <code>(L,)</code> where CDR residues are marked
with the corresponding type (<code>'H1'</code>, <code>'L1'</code>, &hellip;) and non-CDR
residues are marked with <code>'-'</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode_cdr(cdr):
    &#34;&#34;&#34;Decode the CDR information.

    Parameters
    ----------
    cdr : np.ndarray
        A `&#39;numpy&#39;` array of shape `(L,)` encoded as integers where each
        integer corresponds to the index of the CDR type in
        `proteinflow.constants.CDR_ALPHABET`

    Returns
    -------
    cdr : np.ndarray
        A `&#39;numpy&#39;` array of shape `(L,)` where CDR residues are marked
        with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...) and non-CDR
        residues are marked with `&#39;-&#39;`

    &#34;&#34;&#34;
    cdr = ProteinEntry._to_numpy(cdr)
    return np.array([CDR_ALPHABET[x] for x in cdr.astype(int)])</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.decode_sequence"><code class="name flex">
<span>def <span class="ident">decode_sequence</span></span>(<span>seq)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the amino acid sequence.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>seq</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A <code>'numpy'</code> array of integers where each integer corresponds to the
index of the amino acid in <code>proteinflow.constants.ALPHABET</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>seq</code></strong> :&ensp;<code>str</code></dt>
<dd>Amino acid sequence of the protein (one-letter code)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode_sequence(seq):
    &#34;&#34;&#34;Decode the amino acid sequence.

    Parameters
    ----------
    seq : np.ndarray
        A `&#39;numpy&#39;` array of integers where each integer corresponds to the
        index of the amino acid in `proteinflow.constants.ALPHABET`

    Returns
    -------
    seq : str
        Amino acid sequence of the protein (one-letter code)

    &#34;&#34;&#34;
    seq = ProteinEntry._to_numpy(seq)
    return &#34;&#34;.join([ALPHABET[x] for x in seq.astype(int)])</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.esmfold_metrics"><code class="name flex">
<span>def <span class="ident">esmfold_metrics</span></span>(<span>entries, only_antibody=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate ESMFold metrics for a list of entries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entries</code></strong> :&ensp;<code>list</code> of <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>A list of <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> objects</dd>
<dt><strong><code>only_antibody</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If <code>True</code>, only antibody chains are considered</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>plddts_full</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of PLDDT scores averaged over all residues</dd>
<dt><strong><code>plddts_predicted</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of PLDDT scores averaged over predicted residues</dd>
<dt><strong><code>rmsd</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of RMSD values of aligned structures (predicted residues only)</dd>
<dt><strong><code>tm_score</code></strong> :&ensp;<code>list</code> of <code>float</code>, optional</dt>
<dd>A list of TM scores of aligned structures</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def esmfold_metrics(entries, only_antibody=False):
    &#34;&#34;&#34;Calculate ESMFold metrics for a list of entries.

    Parameters
    ----------
    entries : list of ProteinEntry
        A list of `ProteinEntry` objects
    only_antibody : bool, default False
        If `True`, only antibody chains are considered

    Returns
    -------
    plddts_full : list of float
        A list of PLDDT scores averaged over all residues
    plddts_predicted : list of float
        A list of PLDDT scores averaged over predicted residues
    rmsd : list of float
        A list of RMSD values of aligned structures (predicted residues only)
    tm_score : list of float, optional
        A list of TM scores of aligned structures

    &#34;&#34;&#34;
    sequences = []
    chains_list = [
        [
            x
            for x in entry.get_chains()
            if not entry.has_cdr()
            or not only_antibody
            or x not in entry.get_chain_type_dict()[&#34;antigen&#34;]
        ]
        for entry in entries
    ]
    for chains, entry in zip(chains_list, entries):
        sequences.append(
            &#34;:&#34;.join(
                [
                    entry.get_sequence(chains=[chain], only_known=True)
                    for chain in chains
                ]
            )
        )
    esmfold_generate(sequences)
    esmfold_paths = [
        os.path.join(&#34;esmfold_output&#34;, f&#34;seq_{i}.pdb&#34;)
        for i in range(len(sequences))
    ]
    plddts_predicted = [
        confidence_from_file(
            path, entry.get_predict_mask(only_known=True, chains=chains)
        )
        for path, entry, chains in zip(esmfold_paths, entries, chains_list)
    ]
    plddts_full = [confidence_from_file(path) for path in esmfold_paths]
    rmsds = []
    tm_scores = []
    for entry, path in zip(entries, esmfold_paths):
        chains = [
            x
            for x in entry.get_chains()
            if not entry.has_cdr()
            or not only_antibody
            or x not in entry.get_chain_type_dict()[&#34;antigen&#34;]
        ]
        esm_entry = ProteinEntry.from_pdb(path)
        chain_rename_dict = {k: v for k, v in zip(string.ascii_uppercase, chains)}
        esm_entry.rename_chains(chain_rename_dict)
        temp_file = entry._temp_pdb_file()
        esm_entry.align_structure(
            reference_pdb_path=temp_file,
            save_pdb_path=path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;,
            chain_ids=entry.get_predicted_chains()
            if entry.has_predict_mask()
            else chains,
        )
        rmsds.append(
            entry.ca_rmsd(
                ProteinEntry.from_pdb(path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;)
            )
        )
        tm_scores.append(
            entry.tm_score(
                esm_entry,
                chains=chains,
            )
        )
    return plddts_full, plddts_predicted, rmsds, tm_scores</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.from_arrays"><code class="name flex">
<span>def <span class="ident">from_arrays</span></span>(<span>seqs, crds, masks, chain_id_dict, chain_id_array, predict_masks=None, cdrs=None, protein_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a protein entry from arrays.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>seqs</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Amino acid sequences of the protein (encoded as integers, see <code>proteinflow.constants.ALPHABET</code>), <code>'numpy'</code> array of shape <code>(L,)</code></dd>
<dt><strong><code>crds</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Coordinates of the protein, <code>'numpy'</code> array of shape <code>(L, 14, 3)</code> or <code>(L, 4, 3)</code></dd>
<dt><strong><code>masks</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Mask array where 1 indicates residues with known coordinates and 0
indicates missing values, <code>'numpy'</code> array of shape <code>(L,)</code></dd>
<dt><strong><code>chain_id_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary mapping chain IDs to indices in <code>chain_id_array</code></dd>
<dt><strong><code>chain_id_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A <code>'numpy'</code> array of chain IDs encoded as integers</dd>
<dt><strong><code>predict_masks</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>Mask array where 1 indicates residues that were generated by a model and 0
indicates residues with known coordinates, <code>'numpy'</code> array of shape <code>(L,)</code></dd>
<dt><strong><code>cdrs</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>A <code>'numpy'</code> array of shape <code>(L,)</code> where residues are marked
with the corresponding CDR type (encoded as integers, see <code>proteinflow.constants.CDR_ALPHABET</code>)</dd>
<dt><strong><code>protein_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Protein ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>A <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_arrays(
    seqs,
    crds,
    masks,
    chain_id_dict,
    chain_id_array,
    predict_masks=None,
    cdrs=None,
    protein_id=None,
):
    &#34;&#34;&#34;Load a protein entry from arrays.

    Parameters
    ----------
    seqs : np.ndarray
        Amino acid sequences of the protein (encoded as integers, see `proteinflow.constants.ALPHABET`), `&#39;numpy&#39;` array of shape `(L,)`
    crds : np.ndarray
        Coordinates of the protein, `&#39;numpy&#39;` array of shape `(L, 14, 3)` or `(L, 4, 3)`
    masks : np.ndarray
        Mask array where 1 indicates residues with known coordinates and 0
        indicates missing values, `&#39;numpy&#39;` array of shape `(L,)`
    chain_id_dict : dict
        A dictionary mapping chain IDs to indices in `chain_id_array`
    chain_id_array : np.ndarray
        A `&#39;numpy&#39;` array of chain IDs encoded as integers
    predict_masks : np.ndarray, optional
        Mask array where 1 indicates residues that were generated by a model and 0
        indicates residues with known coordinates, `&#39;numpy&#39;` array of shape `(L,)`
    cdrs : np.ndarray, optional
        A `&#39;numpy&#39;` array of shape `(L,)` where residues are marked
        with the corresponding CDR type (encoded as integers, see `proteinflow.constants.CDR_ALPHABET`)
    protein_id : str, optional
        Protein ID

    Returns
    -------
    entry : ProteinEntry
        A `ProteinEntry` object

    &#34;&#34;&#34;
    seqs_list = []
    crds_list = []
    masks_list = []
    chain_ids_list = []
    predict_masks_list = None if predict_masks is None else []
    cdrs_list = None if cdrs is None else []
    for chain_id, ind in chain_id_dict.items():
        chain_ids_list.append(chain_id)
        chain_mask = chain_id_array == ind
        seqs_list.append(ProteinEntry.decode_sequence(seqs[chain_mask]))
        if crds.shape[1] != 14:
            crds_ = np.zeros((crds[chain_mask].shape[0], 14, 3))
            crds_[:, :4, :] = ProteinEntry._to_numpy(crds[chain_mask])
        else:
            crds_ = ProteinEntry._to_numpy(crds[chain_mask])
        crds_list.append(crds_)
        masks_list.append(ProteinEntry._to_numpy(masks[chain_mask]))
        if predict_masks is not None:
            predict_masks_list.append(
                ProteinEntry._to_numpy(predict_masks[chain_mask])
            )
        if cdrs is not None:
            cdrs_list.append(ProteinEntry.decode_cdr(cdrs[chain_mask]))
    return ProteinEntry(
        seqs_list,
        crds_list,
        masks_list,
        chain_ids_list,
        predict_masks_list,
        cdrs_list,
        protein_id,
    )</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>dictionary)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a protein entry from a dictionary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>A nested dictionary where first-level keys are chain IDs and
second-level keys are the following:
- <code>'seq'</code> : amino acid sequence (one-letter code)
- <code>'crd_bb'</code> : backbone coordinates, shaped <code>(L, 4, 3)</code>
- <code>'crd_sc'</code> : sidechain coordinates, shaped <code>(L, 10, 3)</code>
- <code>'msk'</code> : mask array where 1 indicates residues with known coordinates and 0
indicates missing values, shaped <code>(L,)</code>
- <code>'cdr'</code> (optional): CDR information, shaped <code>(L,)</code> where CDR residues are marked
with the corresponding type (<code>'H1'</code>, <code>'L1'</code>, &hellip;) and non-CDR residues are marked with <code>'-'</code>
- <code>'predict_msk'</code> (optional): mask array where 1 indicates residues that were generated by a model and 0
indicates residues with known coordinates, shaped <code>(L,)</code>
It can also contain a <code>'protein_id'</code> first-level key.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>A <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(dictionary):
    &#34;&#34;&#34;Load a protein entry from a dictionary.

    Parameters
    ----------
    dictionary : dict
        A nested dictionary where first-level keys are chain IDs and
        second-level keys are the following:
        - `&#39;seq&#39;` : amino acid sequence (one-letter code)
        - `&#39;crd_bb&#39;` : backbone coordinates, shaped `(L, 4, 3)`
        - `&#39;crd_sc&#39;` : sidechain coordinates, shaped `(L, 10, 3)`
        - `&#39;msk&#39;` : mask array where 1 indicates residues with known coordinates and 0
            indicates missing values, shaped `(L,)`
        - `&#39;cdr&#39;` (optional): CDR information, shaped `(L,)` where CDR residues are marked
            with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...) and non-CDR residues are marked with `&#39;-&#39;`
        - `&#39;predict_msk&#39;` (optional): mask array where 1 indicates residues that were generated by a model and 0
            indicates residues with known coordinates, shaped `(L,)`
        It can also contain a `&#39;protein_id&#39;` first-level key.

    Returns
    -------
    entry : ProteinEntry
        A `ProteinEntry` object

    &#34;&#34;&#34;
    chains = sorted([x for x in dictionary.keys() if x != &#34;protein_id&#34;])
    seq = [dictionary[k][&#34;seq&#34;] for k in chains]
    crd = [
        np.concatenate([dictionary[k][&#34;crd_bb&#34;], dictionary[k][&#34;crd_sc&#34;]], axis=1)
        for k in chains
    ]
    mask = [dictionary[k][&#34;msk&#34;] for k in chains]
    cdr = [dictionary[k].get(&#34;cdr&#34;, None) for k in chains]
    predict_mask = [dictionary[k].get(&#34;predict_msk&#34;, None) for k in chains]
    return ProteinEntry(
        seqs=seq,
        crds=crd,
        masks=mask,
        cdrs=cdr,
        chain_ids=chains,
        predict_masks=predict_mask,
        protein_id=dictionary.get(&#34;protein_id&#34;),
    )</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.from_id"><code class="name flex">
<span>def <span class="ident">from_id</span></span>(<span>pdb_id, local_folder='.', heavy_chain=None, light_chain=None, antigen_chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a protein entry from a PDB file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pdb_id</code></strong> :&ensp;<code>str</code></dt>
<dd>PDB ID of the protein</dd>
<dt><strong><code>local_folder</code></strong> :&ensp;<code>str</code>, default <code>"."</code></dt>
<dd>Path to the local folder where the PDB file is saved</dd>
<dt><strong><code>heavy_chain</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Chain ID of the heavy chain (to load a SAbDab entry)</dd>
<dt><strong><code>light_chain</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Chain ID of the light chain (to load a SAbDab entry)</dd>
<dt><strong><code>antigen_chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>Chain IDs of the antigen chains (to load a SAbDab entry)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>A <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_id(
    pdb_id,
    local_folder=&#34;.&#34;,
    heavy_chain=None,
    light_chain=None,
    antigen_chains=None,
):
    &#34;&#34;&#34;Load a protein entry from a PDB file.

    Parameters
    ----------
    pdb_id : str
        PDB ID of the protein
    local_folder : str, default &#34;.&#34;
        Path to the local folder where the PDB file is saved
    heavy_chain : str, optional
        Chain ID of the heavy chain (to load a SAbDab entry)
    light_chain : str, optional
        Chain ID of the light chain (to load a SAbDab entry)
    antigen_chains : list of str, optional
        Chain IDs of the antigen chains (to load a SAbDab entry)

    Returns
    -------
    entry : ProteinEntry
        A `ProteinEntry` object

    &#34;&#34;&#34;
    if heavy_chain is not None or light_chain is not None:
        pdb_entry = SAbDabEntry.from_id(
            pdb_id=pdb_id,
            local_folder=local_folder,
            heavy_chain=heavy_chain,
            light_chain=light_chain,
            antigen_chains=antigen_chains,
        )
    else:
        pdb_entry = PDBEntry.from_id(pdb_id=pdb_id)
    return ProteinEntry.from_pdb_entry(pdb_entry)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.from_pdb"><code class="name flex">
<span>def <span class="ident">from_pdb</span></span>(<span>pdb_path, fasta_path=None, heavy_chain=None, light_chain=None, antigen_chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a protein entry from a PDB file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pdb_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the PDB file</dd>
<dt><strong><code>fasta_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path to the FASTA file; if not specified, the sequence is extracted
from the PDB file</dd>
<dt><strong><code>heavy_chain</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Chain ID of the heavy chain (to load a SAbDab entry)</dd>
<dt><strong><code>light_chain</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Chain ID of the light chain (to load a SAbDab entry)</dd>
<dt><strong><code>antigen_chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>Chain IDs of the antigen chains (to load a SAbDab entry)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>A <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_pdb(
    pdb_path,
    fasta_path=None,
    heavy_chain=None,
    light_chain=None,
    antigen_chains=None,
):
    &#34;&#34;&#34;Load a protein entry from a PDB file.

    Parameters
    ----------
    pdb_path : str
        Path to the PDB file
    fasta_path : str, optional
        Path to the FASTA file; if not specified, the sequence is extracted
        from the PDB file
    heavy_chain : str, optional
        Chain ID of the heavy chain (to load a SAbDab entry)
    light_chain : str, optional
        Chain ID of the light chain (to load a SAbDab entry)
    antigen_chains : list of str, optional
        Chain IDs of the antigen chains (to load a SAbDab entry)

    Returns
    -------
    entry : ProteinEntry
        A `ProteinEntry` object

    &#34;&#34;&#34;
    if heavy_chain is not None or light_chain is not None:
        pdb_entry = SAbDabEntry(
            pdb_path=pdb_path,
            fasta_path=fasta_path,
            heavy_chain=heavy_chain,
            light_chain=light_chain,
            antigen_chains=antigen_chains,
        )
    else:
        pdb_entry = PDBEntry(pdb_path=pdb_path, fasta_path=fasta_path)
    return ProteinEntry.from_pdb_entry(pdb_entry)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.from_pdb_entry"><code class="name flex">
<span>def <span class="ident">from_pdb_entry</span></span>(<span>pdb_entry)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a protein entry from a <code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code> object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pdb_entry</code></strong> :&ensp;<code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code></dt>
<dd>A <code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code> object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>A <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_pdb_entry(pdb_entry):
    &#34;&#34;&#34;Load a protein entry from a `PDBEntry` object.

    Parameters
    ----------
    pdb_entry : PDBEntry
        A `PDBEntry` object

    Returns
    -------
    entry : ProteinEntry
        A `ProteinEntry` object

    &#34;&#34;&#34;
    pdb_dict = {}
    fasta_dict = pdb_entry.get_fasta()
    for (chain,) in pdb_entry.get_chains():
        pdb_dict[chain] = {}
        fasta_seq = fasta_dict[chain]

        # align fasta and pdb and check criteria)
        mask = pdb_entry.get_mask([chain])[chain]
        if isinstance(pdb_entry, SAbDabEntry):
            pdb_dict[chain][&#34;cdr&#34;] = pdb_entry.get_cdr([chain])[chain]
        pdb_dict[chain][&#34;seq&#34;] = fasta_seq
        pdb_dict[chain][&#34;msk&#34;] = mask

        # go over rows of coordinates
        crd_arr = pdb_entry.get_coordinates_array(chain)

        pdb_dict[chain][&#34;crd_bb&#34;] = crd_arr[:, :4, :]
        pdb_dict[chain][&#34;crd_sc&#34;] = crd_arr[:, 4:, :]
        pdb_dict[chain][&#34;msk&#34;][
            (pdb_dict[chain][&#34;crd_bb&#34;] == 0).sum(-1).sum(-1) == 4
        ] = 0
    pdb_dict[&#34;protein_id&#34;] = pdb_entry.pdb_id
    return ProteinEntry.from_dict(pdb_dict)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.from_pickle"><code class="name flex">
<span>def <span class="ident">from_pickle</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a protein entry from a pickle file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the pickle file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>A <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_pickle(path):
    &#34;&#34;&#34;Load a protein entry from a pickle file.

    Parameters
    ----------
    path : str
        Path to the pickle file

    Returns
    -------
    entry : ProteinEntry
        A `ProteinEntry` object

    &#34;&#34;&#34;
    with open(path, &#34;rb&#34;) as f:
        data = pickle.load(f)
    return ProteinEntry.from_dict(data)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.igfold_metrics"><code class="name flex">
<span>def <span class="ident">igfold_metrics</span></span>(<span>entries, use_openmm=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate IgFold metrics for a list of entries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entries</code></strong> :&ensp;<code>list</code> of <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>A list of <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> objects</dd>
<dt><strong><code>use_openmm</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Whether to use refinement with OpenMM</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>plddts_full</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of PLDDT scores averaged over all residues</dd>
<dt><strong><code>plddts_predicted</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of PLDDT scores averaged over predicted residues</dd>
<dt><strong><code>rmsds</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of RMSD values of aligned structures (predicted residues only)</dd>
<dt><strong><code>tm_scores</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of TM scores of individual chains (self-consistency)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def igfold_metrics(entries, use_openmm=False):
    &#34;&#34;&#34;Calculate IgFold metrics for a list of entries.

    Parameters
    ----------
    entries : list of ProteinEntry
        A list of `ProteinEntry` objects
    use_openmm : bool, default False
        Whether to use refinement with OpenMM

    Returns
    -------
    plddts_full : list of float
        A list of PLDDT scores averaged over all residues
    plddts_predicted : list of float
        A list of PLDDT scores averaged over predicted residues
    rmsds : list of float
        A list of RMSD values of aligned structures (predicted residues only)
    tm_scores : list of float
        A list of TM scores of individual chains (self-consistency)

    &#34;&#34;&#34;
    chains_list = [
        [
            x
            for x in entry.get_chains()
            if x not in entry.get_chain_type_dict()[&#34;antigen&#34;]
        ]
        for entry in entries
    ]
    sequences = [
        {
            chain: entry.get_sequence(chains=[chain], only_known=True)
            for chain in chains
        }
        for entry, chains in zip(entries, chains_list)
    ]
    igfold_generate(sequences, use_openmm=use_openmm)
    folder = &#34;igfold_refine_output&#34; if use_openmm else &#34;igfold_output&#34;
    igfold_paths = [
        os.path.join(folder, f&#34;seq_{i}.pdb&#34;) for i in range(len(sequences))
    ]
    prmsds_predicted = [
        confidence_from_file(
            path, entry.get_predict_mask(only_known=True, chains=chains)
        )
        for path, entry, chains in zip(igfold_paths, entries, chains_list)
    ]
    prmsds_full = [confidence_from_file(path) for path in igfold_paths]
    rmsds = []
    tm_scores = []
    for entry, path in zip(entries, igfold_paths):
        igfold_entry = ProteinEntry.from_pdb(path)
        temp_file = entry._temp_pdb_file()
        igfold_entry.align_structure(
            reference_pdb_path=temp_file,
            save_pdb_path=path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;,
            chain_ids=entry.get_predicted_chains(),
        )
        rmsds.append(
            entry.ca_rmsd(
                ProteinEntry.from_pdb(path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;)
            )
        )
        tm_scores.append(
            entry.tm_score(
                igfold_entry,
            )
        )
    return prmsds_full, prmsds_predicted, rmsds, tm_scores</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.immunebuilder_metrics"><code class="name flex">
<span>def <span class="ident">immunebuilder_metrics</span></span>(<span>entries, protein_type='antibody')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate ImmuneBuilder metrics for a list of entries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entries</code></strong> :&ensp;<code>list</code> of <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>A list of <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> objects</dd>
<dt><strong><code>protein_type</code></strong> :&ensp;<code>{"antibody", "nanobody", "tcr"}</code>, default <code>"antibody"</code></dt>
<dd>The type of the protein</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>prmsds_full</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of PRMSD scores averaged over all residues</dd>
<dt><strong><code>prmsds_predicted</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of PRMSD scores averaged over predicted residues</dd>
<dt><strong><code>rmsds</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of RMSD values of aligned structures (predicted residues only)</dd>
<dt><strong><code>tm_scores</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>A list of TM scores of aligned structures</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def immunebuilder_metrics(entries, protein_type=&#34;antibody&#34;):
    &#34;&#34;&#34;Calculate ImmuneBuilder metrics for a list of entries.

    Parameters
    ----------
    entries : list of ProteinEntry
        A list of `ProteinEntry` objects
    protein_type : {&#34;antibody&#34;, &#34;nanobody&#34;, &#34;tcr&#34;}, default &#34;antibody&#34;
        The type of the protein

    Returns
    -------
    prmsds_full : list of float
        A list of PRMSD scores averaged over all residues
    prmsds_predicted : list of float
        A list of PRMSD scores averaged over predicted residues
    rmsds : list of float
        A list of RMSD values of aligned structures (predicted residues only)
    tm_scores : list of float
        A list of TM scores of aligned structures

    &#34;&#34;&#34;
    sequences = []
    chains_list = [
        [
            x
            for x in entry.get_chains()
            if x not in entry.get_chain_type_dict()[&#34;antigen&#34;]
        ]
        for entry in entries
    ]
    for chains, entry in zip(chains_list, entries):
        chain_type_dict = entry.get_chain_type_dict()
        sequences.append(
            {
                key[0].upper(): entry.get_sequence(
                    chains=[chain_type_dict[key]], only_known=True
                )
                for key in [&#34;heavy&#34;, &#34;light&#34;]
                if key in chain_type_dict
            }
        )
    immunebuilder_generate(sequences, protein_type=protein_type)
    generated_paths = [
        os.path.join(&#34;immunebuilder_output&#34;, f&#34;seq_{i}.pdb&#34;)
        for i in range(len(sequences))
    ]
    prmsds_predicted = [
        confidence_from_file(
            path, entry.get_predict_mask(only_known=True, chains=chains)
        )
        for path, entry, chains in zip(generated_paths, entries, chains_list)
    ]
    prmsds_full = [confidence_from_file(path) for path in generated_paths]
    rmsds = []
    tm_scores = []
    for entry, path, chains in zip(entries, generated_paths, chains_list):
        generated_entry = ProteinEntry.from_pdb(path)
        chain_type_dict = entry.get_chain_type_dict()
        chain_rename_dict = {}
        if &#34;light&#34; in chain_type_dict:
            chain_rename_dict[&#34;L&#34;] = chain_type_dict[&#34;light&#34;]
        if &#34;heavy&#34; in chain_type_dict:
            chain_rename_dict[&#34;H&#34;] = chain_type_dict[&#34;heavy&#34;]
        generated_entry.rename_chains(chain_rename_dict)
        temp_file = entry._temp_pdb_file()
        generated_entry.align_structure(
            reference_pdb_path=temp_file,
            save_pdb_path=path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;,
            chain_ids=entry.get_predicted_chains(),
        )
        rmsds.append(
            entry.ca_rmsd(
                ProteinEntry.from_pdb(path.rsplit(&#34;.&#34;, 1)[0] + &#34;_aligned.pdb&#34;)
            )
        )
        tm_scores.append(
            entry.tm_score(
                generated_entry,
                chains=chains,
            )
        )
    return prmsds_full, prmsds_predicted, rmsds, tm_scores</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.retrieve_ligands_from_pickle"><code class="name flex">
<span>def <span class="ident">retrieve_ligands_from_pickle</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve ligands from a pickle file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the pickle file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chain2ligand</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary where keys are chain IDs and values are ligand names</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def retrieve_ligands_from_pickle(path):
    &#34;&#34;&#34;Retrieve ligands from a pickle file.

    Parameters
    ----------
    path : str
        Path to the pickle file

    Returns
    -------
    chain2ligand : dict
        A dictionary where keys are chain IDs and values are ligand names

    &#34;&#34;&#34;
    with open(path, &#34;rb&#34;) as f:
        data = pickle.load(f)
    chain2ligand = {}
    for chain in data:
        if &#34;ligand&#34; not in data[chain]:
            continue
        chain2ligand[chain] = data[chain][&#34;ligand&#34;]
    return chain2ligand</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="proteinflow.data.ProteinEntry.ablang_pll"><code class="name flex">
<span>def <span class="ident">ablang_pll</span></span>(<span>self, ablang_model_name='heavy', average=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the AbLang PLL score of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ablang_model_name</code></strong> :&ensp;<code>str</code>, default <code>"heavy"</code></dt>
<dd>Name of the AbLang model to use</dd>
<dt><strong><code>average</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If <code>True</code>, the score is averaged over the residues; otherwise, the score is summed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>score</code></strong> :&ensp;<code>float</code></dt>
<dd>The AbLang PLL score of the protein</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ablang_pll(self, ablang_model_name=&#34;heavy&#34;, average=False):
    &#34;&#34;&#34;Calculate the AbLang PLL score of the protein.

    Parameters
    ----------
    ablang_model_name : str, default &#34;heavy&#34;
        Name of the AbLang model to use
    average : bool, default False
        If `True`, the score is averaged over the residues; otherwise, the score is summed

    Returns
    -------
    score : float
        The AbLang PLL score of the protein

    &#34;&#34;&#34;
    chains = self.get_predicted_chains()
    chain_sequences = [self.get_sequence(chains=[chain]) for chain in chains]
    if self.predict_mask is not None:
        predict_masks = [
            (self.get_predict_mask(chains=[chain])).astype(float)
            for chain in chains
        ]
    else:
        predict_masks = [np.ones(len(x)) for x in chain_sequences]
    out = sum(
        [
            ablang_pll(
                sequence,
                predict_mask,
                ablang_model_name=ablang_model_name,
                average=False,
            )
            for sequence, predict_mask in zip(chain_sequences, predict_masks)
        ]
    )
    if average:
        out /= self.get_predict_mask(chains=chains).sum()
    return out</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.accuracy"><code class="name flex">
<span>def <span class="ident">accuracy</span></span>(<span>self, seq_before)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the accuracy of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>seq_before</code></strong> :&ensp;<code>str</code></dt>
<dd>A string with the sequence before the mutation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>score</code></strong> :&ensp;<code>float</code></dt>
<dd>The accuracy of the protein</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accuracy(self, seq_before):
    &#34;&#34;&#34;Calculate the accuracy of the protein.

    Parameters
    ----------
    seq_before : str
        A string with the sequence before the mutation

    Returns
    -------
    score : float
        The accuracy of the protein

    &#34;&#34;&#34;
    seq_after = self.get_sequence(encode=False)
    seq_before = np.array(list(seq_before))
    seq_after = np.array(list(seq_after))
    if self.predict_mask is not None:
        predict_mask = self.get_predict_mask()
        seq_before = seq_before[predict_mask.astype(bool)]
        seq_after = seq_after[predict_mask.astype(bool)]
    return np.mean(seq_before == seq_after)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.align_structure"><code class="name flex">
<span>def <span class="ident">align_structure</span></span>(<span>self, reference_pdb_path, save_pdb_path, chain_ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Aligns the structure to a reference structure using the CA atoms.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reference_pdb_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the reference structure (in .pdb format)</dd>
<dt><strong><code>save_pdb_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path where the aligned structure should be saved (in .pdb format)</dd>
<dt><strong><code>chain_ids</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the chains with the specified IDs are aligned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_structure(self, reference_pdb_path, save_pdb_path, chain_ids=None):
    &#34;&#34;&#34;Aligns the structure to a reference structure using the CA atoms.

    Parameters
    ----------
    reference_pdb_path : str
        Path to the reference structure (in .pdb format)
    save_pdb_path : str
        Path where the aligned structure should be saved (in .pdb format)
    chain_ids : list of str, optional
        If specified, only the chains with the specified IDs are aligned

    &#34;&#34;&#34;
    pdb_parser = Bio.PDB.PDBParser(QUIET=True)

    temp_file = self._temp_pdb_file()
    ref_structure = pdb_parser.get_structure(&#34;reference&#34;, reference_pdb_path)
    sample_structure = pdb_parser.get_structure(&#34;sample&#34;, temp_file)

    ref_model = ref_structure[0]
    sample_model = sample_structure[0]

    ref_atoms = []
    sample_atoms = []

    for ref_chain in ref_model:
        if chain_ids is not None and ref_chain.id not in chain_ids:
            continue
        for ref_res in ref_chain:
            if &#34;CA&#34; in ref_res:
                ref_atoms.append(ref_res[&#34;CA&#34;])
            elif &#34;C&#34; in ref_res:
                ref_atoms.append(ref_res[&#34;C&#34;])
                warnings.warn(
                    &#34;Using a C atom instead of CA for alignment in the reference structure&#34;
                )

    for sample_chain in sample_model:
        if chain_ids is not None and sample_chain.id not in chain_ids:
            continue
        for sample_res in sample_chain:
            if &#34;CA&#34; in sample_res:
                sample_atoms.append(sample_res[&#34;CA&#34;])
            elif &#34;C&#34; in sample_res:
                sample_atoms.append(sample_res[&#34;C&#34;])
                warnings.warn(
                    &#34;Using a C atom instead of CA for alignment in the sample structure&#34;
                )

    super_imposer = Bio.PDB.Superimposer()
    super_imposer.set_atoms(ref_atoms, sample_atoms)
    super_imposer.apply(sample_model.get_atoms())

    io = Bio.PDB.PDBIO()
    io.set_structure(sample_structure)
    io.save(save_pdb_path)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.apply_mask"><code class="name flex">
<span>def <span class="ident">apply_mask</span></span>(<span>self, mask)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a mask to the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A boolean mask of shape <code>(L,)</code> where <code>L</code> is the length of the protein (the chains are concatenated in alphabetical order)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>A new <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_mask(self, mask):
    &#34;&#34;&#34;Apply a mask to the protein.

    Parameters
    ----------
    mask : np.ndarray
        A boolean mask of shape `(L,)` where `L` is the length of the protein (the chains are concatenated in alphabetical order)

    Returns
    -------
    entry : ProteinEntry
        A new `ProteinEntry` object

    &#34;&#34;&#34;
    start = 0
    out_dict = {}
    for chain in self.get_chains():
        out_dict[chain] = {}
        chain_mask = mask[start : start + self.get_length([chain])]
        start += self.get_length([chain])
        out_dict[chain][&#34;seq&#34;] = self.decode_sequence(
            self.get_sequence(chains=[chain], encode=True)[chain_mask]
        )
        out_dict[chain][&#34;crd_bb&#34;] = self.get_coordinates(
            chains=[chain], bb_only=True
        )[chain_mask]
        out_dict[chain][&#34;crd_sc&#34;] = self.get_coordinates(chains=[chain])[:, 4:][
            chain_mask
        ]
        out_dict[chain][&#34;msk&#34;] = self.get_mask(chains=[chain])[chain_mask]
        if self.has_cdr():
            out_dict[chain][&#34;cdr&#34;] = self.decode_cdr(
                self.get_cdr([chain], encode=True)[chain_mask]
            )
        if self.has_predict_mask():
            out_dict[chain][&#34;predict_msk&#34;] = self.predict_mask[chain][chain_mask]
    if self.id is not None:
        out_dict[&#34;protein_id&#34;] = self.id
    return ProteinEntry.from_dict(out_dict)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.blosum62_score"><code class="name flex">
<span>def <span class="ident">blosum62_score</span></span>(<span>self, seq_before, average=True, only_predicted=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the BLOSUM62 score of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>seq_before</code></strong> :&ensp;<code>str</code></dt>
<dd>A string with the sequence before the mutation</dd>
<dt><strong><code>average</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If <code>True</code>, the score is averaged over the residues; otherwise, the score is summed</dd>
<dt><strong><code>only_predicted</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If <code>True</code> and prediction masks are available, only predicted residues are considered</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>score</code></strong> :&ensp;<code>float</code></dt>
<dd>The BLOSUM62 score of the protein</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blosum62_score(self, seq_before, average=True, only_predicted=True):
    &#34;&#34;&#34;Calculate the BLOSUM62 score of the protein.

    Parameters
    ----------
    seq_before : str
        A string with the sequence before the mutation
    average : bool, default True
        If `True`, the score is averaged over the residues; otherwise, the score is summed
    only_predicted : bool, default True
        If `True` and prediction masks are available, only predicted residues are considered

    Returns
    -------
    score : float
        The BLOSUM62 score of the protein

    &#34;&#34;&#34;
    seq_after = self.get_sequence(encode=False)
    if self.predict_mask is not None and only_predicted:
        predict_mask = self.get_predict_mask()
        seq_before = np.array(list(seq_before))[predict_mask.astype(bool)]
        seq_after = np.array(list(seq_after))[predict_mask.astype(bool)]
    score = blosum62_score(seq_before, seq_after)
    if average:
        score /= len(seq_before)
    return score</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.ca_rmsd"><code class="name flex">
<span>def <span class="ident">ca_rmsd</span></span>(<span>self, entry, only_predicted=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate CA RMSD between two proteins.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>A <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object</dd>
<dt><strong><code>only_predicted</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If <code>True</code> and prediction masks are available, only predicted residues are considered</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rmsd</code></strong> :&ensp;<code>float</code></dt>
<dd>The CA RMSD between the two proteins</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ca_rmsd(self, entry, only_predicted=True):
    &#34;&#34;&#34;Calculate CA RMSD between two proteins.

    Parameters
    ----------
    entry : ProteinEntry
        A `ProteinEntry` object
    only_predicted : bool, default True
        If `True` and prediction masks are available, only predicted residues are considered

    Returns
    -------
    rmsd : float
        The CA RMSD between the two proteins

    &#34;&#34;&#34;
    if only_predicted and not self.has_predict_mask():
        only_predicted = False
    chains = [x for x in self.get_chains() if x in entry.get_chains()]
    structure1 = self.get_coordinates(only_known=True, chains=chains)[:, 2]
    structure2 = entry.get_coordinates(only_known=True, chains=chains)[:, 2]
    if only_predicted:
        mask = self.get_predict_mask(only_known=True, chains=chains).astype(bool)
        structure1 = structure1[mask]
        structure2 = structure2[mask]
    return ca_rmsd(structure1, structure2)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.chemical_features"><code class="name flex">
<span>def <span class="ident">chemical_features</span></span>(<span>self, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate chemical features of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the chemical features of the specified chains is returned (in the same order);
otherwise, all features are concatenated in alphabetical order of the chain IDs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A <code>'numpy'</code> array of shape <code>(L, 4)</code> with chemical features of the
protein (hydropathy, volume, charge, polarity, acceptor/donor); missing
values are marked with zeros</dd>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the chemical features of the specified chains are returned (in the same order);
otherwise, all features are concatenated in alphabetical order of the chain IDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chemical_features(self, chains=None):
    &#34;&#34;&#34;Calculate chemical features of the protein.

    Parameters
    ----------
    chains : list of str, optional
        If specified, only the chemical features of the specified chains is returned (in the same order);
        otherwise, all features are concatenated in alphabetical order of the chain IDs

    Returns
    -------
    features : np.ndarray
        A `&#39;numpy&#39;` array of shape `(L, 4)` with chemical features of the
        protein (hydropathy, volume, charge, polarity, acceptor/donor); missing
        values are marked with zeros
    chains : list of str, optional
        If specified, only the chemical features of the specified chains are returned (in the same order);
        otherwise, all features are concatenated in alphabetical order of the chain IDs

    &#34;&#34;&#34;
    chains = self._get_chains_list(chains)
    seq = &#34;&#34;.join([self.seq[chain] for chain in chains])
    features = np.array([_PMAP(x) for x in seq])
    return features</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.cut_missing_edges"><code class="name flex">
<span>def <span class="ident">cut_missing_edges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Cut off the ends of the protein sequence that have missing coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut_missing_edges(self):
    &#34;&#34;&#34;Cut off the ends of the protein sequence that have missing coordinates.&#34;&#34;&#34;
    for chain in self.get_chains():
        mask = self.mask[chain]
        known_ind = np.where(mask == 1)[0]
        start, end = known_ind[0], known_ind[-1] + 1
        self.seq[chain] = self.seq[chain][start:end]
        self.crd[chain] = self.crd[chain][start:end]
        self.mask[chain] = self.mask[chain][start:end]
        if self.cdr[chain] is not None:
            self.cdr[chain] = self.cdr[chain][start:end]</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.dihedral_angles"><code class="name flex">
<span>def <span class="ident">dihedral_angles</span></span>(<span>self, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the backbone dihedral angles (phi, psi) of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the dihedral angles of the specified chains are returned (in the same order);
otherwise, all features are concatenated in alphabetical order of the chain IDs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>angles</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A <code>'numpy'</code> array of shape <code>(L, 2)</code> with backbone dihedral angles
(phi, psi) in degrees; missing values are marked with zeros</dd>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the dihedral angles of the specified chains are returned (in the same order);
otherwise, all features are concatenated in alphabetical order of the chain IDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dihedral_angles(self, chains=None):
    &#34;&#34;&#34;Calculate the backbone dihedral angles (phi, psi) of the protein.

    Parameters
    ----------
    chains : list of str, optional
        If specified, only the dihedral angles of the specified chains are returned (in the same order);
        otherwise, all features are concatenated in alphabetical order of the chain IDs

    Returns
    -------
    angles : np.ndarray
        A `&#39;numpy&#39;` array of shape `(L, 2)` with backbone dihedral angles
        (phi, psi) in degrees; missing values are marked with zeros
    chains : list of str, optional
        If specified, only the dihedral angles of the specified chains are returned (in the same order);
        otherwise, all features are concatenated in alphabetical order of the chain IDs

    &#34;&#34;&#34;
    angles = []
    chains = self._get_chains_list(chains)
    # N, C, Ca, O
    # psi
    for chain in chains:
        chain_angles = []
        crd = self.get_coordinates([chain])
        mask = self.get_mask([chain])
        p = crd[:-1, [0, 2, 1], :]
        p = np.concatenate([p, crd[1:, [0], :]], 1)
        p = np.pad(p, ((0, 1), (0, 0), (0, 0)))
        chain_angles.append(_dihedral_angle(p, mask))
        # phi
        p = crd[:-1, [1], :]
        p = np.concatenate([p, crd[1:, [0, 2, 1]]], 1)
        p = np.pad(p, ((1, 0), (0, 0), (0, 0)))
        chain_angles.append(_dihedral_angle(p, mask))
        angles.append(np.stack(chain_angles, -1))
    angles = np.concatenate(angles, 0)
    return angles</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.esm_pll"><code class="name flex">
<span>def <span class="ident">esm_pll</span></span>(<span>self, esm_model_name='esm2_t30_150M_UR50D', esm_model_objects=None, average=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the ESM PLL score of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>esm_model_name</code></strong> :&ensp;<code>str</code>, default <code>"esm2_t30_150M_UR50D"</code></dt>
<dd>Name of the ESM-2 model to use</dd>
<dt><strong><code>esm_model_objects</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Tuple of ESM-2 model, batch converter and tok_to_idx dictionary (if not None, <code>esm_model_name</code> will be ignored)</dd>
<dt><strong><code>average</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If <code>True</code>, the score is averaged over the residues; otherwise, the score is summed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>score</code></strong> :&ensp;<code>float</code></dt>
<dd>The ESM PLL score of the protein</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esm_pll(
    self,
    esm_model_name=&#34;esm2_t30_150M_UR50D&#34;,
    esm_model_objects=None,
    average=False,
):
    &#34;&#34;&#34;Calculate the ESM PLL score of the protein.

    Parameters
    ----------
    esm_model_name : str, default &#34;esm2_t30_150M_UR50D&#34;
        Name of the ESM-2 model to use
    esm_model_objects : tuple, optional
        Tuple of ESM-2 model, batch converter and tok_to_idx dictionary (if not None, `esm_model_name` will be ignored)
    average : bool, default False
        If `True`, the score is averaged over the residues; otherwise, the score is summed

    Returns
    -------
    score : float
        The ESM PLL score of the protein

    &#34;&#34;&#34;
    chains = self.get_chains()
    chain_sequences = [self.get_sequence(chains=[chain]) for chain in chains]
    if self.predict_mask is not None:
        predict_masks = [
            (self.get_predict_mask(chains=[chain])).astype(float)
            for chain in chains
        ]
    else:
        predict_masks = [np.ones(len(x)) for x in chain_sequences]
    return esm_pll(
        chain_sequences,
        predict_masks,
        esm_model_name=esm_model_name,
        esm_model_objects=esm_model_objects,
        average=average,
    )</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_atom_mask"><code class="name flex">
<span>def <span class="ident">get_atom_mask</span></span>(<span>self, chains=None, cdr=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the atom mask of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>If specified, only the atom masks of the specified chains are returned (in the same order);
otherwise, all atom masks are concatenated in alphabetical order of the chain IDs</dd>
<dt><strong><code>cdr</code></strong> :&ensp;<code>{"H1", "H2", "H3", "L1", "L2", "L3"}</code>, optional</dt>
<dd>If specified, only the CDR region of the specified type is returned</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>atom_mask</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Atom mask array where 1 indicates atoms with known coordinates and 0
indicates missing or non-existing values, shaped <code>(L, 14, 3)</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_atom_mask(self, chains=None, cdr=None):
    &#34;&#34;&#34;Get the atom mask of the protein.

    Parameters
    ----------
    chains : str, optional
        If specified, only the atom masks of the specified chains are returned (in the same order);
        otherwise, all atom masks are concatenated in alphabetical order of the chain IDs
    cdr : {&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;}, optional
        If specified, only the CDR region of the specified type is returned

    Returns
    -------
    atom_mask : np.ndarray
        Atom mask array where 1 indicates atoms with known coordinates and 0
        indicates missing or non-existing values, shaped `(L, 14, 3)`

    &#34;&#34;&#34;
    if cdr is not None and self.cdr is None:
        raise ValueError(&#34;CDR information not available&#34;)
    if cdr is not None:
        assert cdr in CDR_REVERSE, f&#34;CDR must be one of {list(CDR_REVERSE.keys())}&#34;
    chains = self._get_chains_list(chains)
    seq = &#34;&#34;.join([self.seq[c] for c in chains])
    atom_mask = np.concatenate([ATOM_MASKS[aa] for aa in seq])
    atom_mask[self.mask == 0] = 0
    if cdr is not None:
        atom_mask = atom_mask[self.cdr == cdr]
    return atom_mask</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_cdr"><code class="name flex">
<span>def <span class="ident">get_cdr</span></span>(<span>self, chains=None, encode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the CDR information of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the CDR information of the specified chains is
returned (in the same order); otherwise, all CDR information is concatenated in
alphabetical order of the chain IDs</dd>
<dt><strong><code>encode</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If <code>True</code>, the CDR information is encoded as a <code>'numpy'</code> array of
integers where each integer corresponds to the index of the CDR
type in <code>proteinflow.constants.CDR_ALPHABET</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cdr</code></strong> :&ensp;<code>np.ndarray</code> or <code>None</code></dt>
<dd>A <code>'numpy'</code> array of shape <code>(L,)</code> where CDR residues are marked
with the corresponding type (<code>'H1'</code>, <code>'L1'</code>, &hellip;) and non-CDR
residues are marked with <code>'-'</code> or an encoded array of integers
ir <code>encode=True</code>; <code>None</code> if CDR information is not available</dd>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the CDR information of the specified chains is
returned (in the same order); otherwise, all CDR information is concatenated in
alphabetical order of the chain IDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cdr(self, chains=None, encode=False):
    &#34;&#34;&#34;Get the CDR information of the protein.

    Parameters
    ----------
    chains : list of str, optional
        If specified, only the CDR information of the specified chains is
        returned (in the same order); otherwise, all CDR information is concatenated in
        alphabetical order of the chain IDs
    encode : bool, default False
        If `True`, the CDR information is encoded as a `&#39;numpy&#39;` array of
        integers where each integer corresponds to the index of the CDR
        type in `proteinflow.constants.CDR_ALPHABET`

    Returns
    -------
    cdr : np.ndarray or None
        A `&#39;numpy&#39;` array of shape `(L,)` where CDR residues are marked
        with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...) and non-CDR
        residues are marked with `&#39;-&#39;` or an encoded array of integers
        ir `encode=True`; `None` if CDR information is not available
    chains : list of str, optional
        If specified, only the CDR information of the specified chains is
        returned (in the same order); otherwise, all CDR information is concatenated in
        alphabetical order of the chain IDs

    &#34;&#34;&#34;
    chains = self._get_chains_list(chains)
    if self.cdr is None:
        return None
    cdr = np.concatenate([self.cdr[c] for c in chains], axis=0)
    if encode:
        cdr = np.array([CDR_REVERSE[aa] for aa in cdr])
    return cdr</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_cdr_length"><code class="name flex">
<span>def <span class="ident">get_cdr_length</span></span>(<span>self, chains)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the length of the CDR regions of a set of chains.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chain</code></strong> :&ensp;<code>str</code></dt>
<dd>Chain ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of the CDR regions of the chain</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cdr_length(self, chains):
    &#34;&#34;&#34;Get the length of the CDR regions of a set of chains.

    Parameters
    ----------
    chain : str
        Chain ID

    Returns
    -------
    length : int
        Length of the CDR regions of the chain

    &#34;&#34;&#34;
    if not self.has_cdr():
        return {x: None for x in [&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;]}
    return {
        x: len(self.get_sequence(chains=chains, cdr=x))
        for x in [&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;]
    }</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_chain_id_array"><code class="name flex">
<span>def <span class="ident">get_chain_id_array</span></span>(<span>self, chains=None, encode=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the chain ID array of the protein.</p>
<p>The chain ID array is a <code>'numpy'</code> array of shape <code>(L,)</code> with the chain ID of each residue.
The chain ID is the index of the chain in the alphabetical order of the chain IDs. To get a
mapping from the index to the chain ID, use <code>get_chain_id_dict()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the chain ID array of the specified chains is returned (in the same order);
otherwise, all features are concatenated in alphabetical order of the chain IDs</dd>
<dt><strong><code>encode</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If True, the chain ID is encoded as an integer; otherwise, the chain ID is the chain ID string</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chain_id_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A <code>'numpy'</code> array of shape <code>(L,)</code> with the chain ID of each residue</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chain_id_array(self, chains=None, encode=True):
    &#34;&#34;&#34;Get the chain ID array of the protein.

    The chain ID array is a `&#39;numpy&#39;` array of shape `(L,)` with the chain ID of each residue.
    The chain ID is the index of the chain in the alphabetical order of the chain IDs. To get a
    mapping from the index to the chain ID, use `get_chain_id_dict()`.

    Parameters
    ----------
    chains : list of str, optional
        If specified, only the chain ID array of the specified chains is returned (in the same order);
        otherwise, all features are concatenated in alphabetical order of the chain IDs
    encode : bool, default True
        If True, the chain ID is encoded as an integer; otherwise, the chain ID is the chain ID string

    Returns
    -------
    chain_id_array : np.ndarray
        A `&#39;numpy&#39;` array of shape `(L,)` with the chain ID of each residue

    &#34;&#34;&#34;
    id_dict = self.get_chain_id_dict()
    if encode:
        index_array = np.zeros(self.get_length(chains))
    else:
        index_array = np.empty(self.get_length(chains), dtype=object)
    start_index = 0
    for chain in self._get_chains_list(chains):
        chain_length = self.get_length([chain])
        index_array[start_index : start_index + chain_length] = (
            id_dict[chain] if encode else chain
        )
        start_index += chain_length
    return index_array</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_chain_id_dict"><code class="name flex">
<span>def <span class="ident">get_chain_id_dict</span></span>(<span>self, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the dictionary mapping from chain indices to chain IDs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the chain IDs of the specified chains are returned</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chain_id_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary mapping from chain indices to chain IDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chain_id_dict(self, chains=None):
    &#34;&#34;&#34;Get the dictionary mapping from chain indices to chain IDs.

    Parameters
    ----------
    chains : list of str, optional
        If specified, only the chain IDs of the specified chains are returned

    Returns
    -------
    chain_id_dict : dict
        A dictionary mapping from chain indices to chain IDs

    &#34;&#34;&#34;
    chains = self._get_chains_list(chains)
    chain_id_dict = {x: i for i, x in enumerate(self.get_chains()) if x in chains}
    return chain_id_dict</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_chain_type_dict"><code class="name flex">
<span>def <span class="ident">get_chain_type_dict</span></span>(<span>self, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the chain types of the protein.</p>
<p>If the CDRs are not annotated, this function will return <code>None</code>.
If there is no light or heavy chain, the corresponding key will be missing.
If there is no antigen chain, the <code>'antigen'</code> key will map to an empty list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, default <code>None</code></dt>
<dd>Chain IDs to consider</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chain_type_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary with keys <code>'heavy'</code>, <code>'light'</code> and <code>'antigen'</code> and values
the corresponding chain IDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chain_type_dict(self, chains=None):
    &#34;&#34;&#34;Get the chain types of the protein.

    If the CDRs are not annotated, this function will return `None`.
    If there is no light or heavy chain, the corresponding key will be missing.
    If there is no antigen chain, the `&#39;antigen&#39;` key will map to an empty list.

    Parameters
    ----------
    chains : list of str, default None
        Chain IDs to consider

    Returns
    -------
    chain_type_dict : dict
        A dictionary with keys `&#39;heavy&#39;`, `&#39;light&#39;` and `&#39;antigen&#39;` and values
        the corresponding chain IDs

    &#34;&#34;&#34;
    if not self.has_cdr():
        return None
    chain_type_dict = {&#34;antigen&#34;: []}
    chains = self._get_chains_list(chains)
    for chain, cdr in self.cdr.items():
        if chain not in chains:
            continue
        u = np.unique(cdr)
        if &#34;H1&#34; in u:
            chain_type_dict[&#34;heavy&#34;] = chain
        elif &#34;L1&#34; in u:
            chain_type_dict[&#34;light&#34;] = chain
        else:
            chain_type_dict[&#34;antigen&#34;].append(chain)
    return chain_type_dict</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_chains"><code class="name flex">
<span>def <span class="ident">get_chains</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the chain IDs of the protein.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Chain IDs of the protein</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chains(self):
    &#34;&#34;&#34;Get the chain IDs of the protein.

    Returns
    -------
    chains : list of str
        Chain IDs of the protein

    &#34;&#34;&#34;
    return sorted(self.seq.keys())</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_coordinates"><code class="name flex">
<span>def <span class="ident">get_coordinates</span></span>(<span>self, chains=None, bb_only=False, cdr=None, only_known=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the coordinates of the protein.</p>
<p>Backbone atoms are in the order of <code>N, C, CA, O</code>; for the full-atom
order see <code><a title="proteinflow.data.ProteinEntry.ATOM_ORDER" href="#proteinflow.data.ProteinEntry.ATOM_ORDER">ProteinEntry.ATOM_ORDER</a></code> (sidechain atoms come after the
backbone atoms).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the coordinates of the specified chains are returned (in the same order);
otherwise, all coordinates are concatenated in alphabetical order of the chain IDs</dd>
<dt><strong><code>bb_only</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If <code>True</code>, only the backbone atoms are returned</dd>
<dt><strong><code>cdr</code></strong> :&ensp;<code>{"H1", "H2", "H3", "L1", "L2", "L3"}</code>, optional</dt>
<dd>If specified, only the CDR region of the specified type is returned</dd>
<dt><strong><code>only_known</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If <code>True</code>, only return the coordinates of residues with known coordinates</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>crd</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Coordinates of the protein, <code>'numpy'</code> array of shape <code>(L, 14, 3)</code>
or <code>(L, 4, 3)</code> if <code>bb_only=True</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coordinates(self, chains=None, bb_only=False, cdr=None, only_known=False):
    &#34;&#34;&#34;Get the coordinates of the protein.

    Backbone atoms are in the order of `N, C, CA, O`; for the full-atom
    order see `ProteinEntry.ATOM_ORDER` (sidechain atoms come after the
    backbone atoms).

    Parameters
    ----------
    chains : list of str, optional
        If specified, only the coordinates of the specified chains are returned (in the same order);
        otherwise, all coordinates are concatenated in alphabetical order of the chain IDs
    bb_only : bool, default False
        If `True`, only the backbone atoms are returned
    cdr : {&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;}, optional
        If specified, only the CDR region of the specified type is returned
    only_known : bool, default False
        If `True`, only return the coordinates of residues with known coordinates

    Returns
    -------
    crd : np.ndarray
        Coordinates of the protein, `&#39;numpy&#39;` array of shape `(L, 14, 3)`
        or `(L, 4, 3)` if `bb_only=True`

    &#34;&#34;&#34;
    if cdr is not None and self.cdr is None:
        raise ValueError(&#34;CDR information not available&#34;)
    if cdr is not None:
        assert cdr in CDR_REVERSE, f&#34;CDR must be one of {list(CDR_REVERSE.keys())}&#34;
    chains = self._get_chains_list(chains)
    crd = np.concatenate([self.crd[c] for c in chains], axis=0)
    if cdr is not None:
        crd = crd[self.cdr == cdr]
    if bb_only:
        crd = crd[:, :4, :]
    if only_known:
        crd = crd[self.get_mask(chains=chains, cdr=cdr).astype(bool)]
    return crd</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_id"><code class="name flex">
<span>def <span class="ident">get_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the ID of the protein.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id(self):
    &#34;&#34;&#34;Return the ID of the protein.&#34;&#34;&#34;
    return self.id</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_index_array"><code class="name flex">
<span>def <span class="ident">get_index_array</span></span>(<span>self, chains=None, index_bump=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the index array of the protein.</p>
<p>The index array is a <code>'numpy'</code> array of shape <code>(L,)</code> with the index of each residue along the chain.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the index array of the specified chains is returned (in the same order);
otherwise, all features are concatenated in alphabetical order of the chain IDs</dd>
<dt><strong><code>index_bump</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>If specified, the index is bumped by this number between chains</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>index_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A <code>'numpy'</code> array of shape <code>(L,)</code> with the index of each residue along the chain; if multiple chains
are specified, the index is bumped by <code>index_bump</code> at the beginning of each chain</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_index_array(self, chains=None, index_bump=100):
    &#34;&#34;&#34;Get the index array of the protein.

    The index array is a `&#39;numpy&#39;` array of shape `(L,)` with the index of each residue along the chain.

    Parameters
    ----------
    chains : list of str, optional
        If specified, only the index array of the specified chains is returned (in the same order);
        otherwise, all features are concatenated in alphabetical order of the chain IDs
    index_bump : int, default 0
        If specified, the index is bumped by this number between chains

    Returns
    -------
    index_array : np.ndarray
        A `&#39;numpy&#39;` array of shape `(L,)` with the index of each residue along the chain; if multiple chains
        are specified, the index is bumped by `index_bump` at the beginning of each chain

    &#34;&#34;&#34;
    chains = self._get_chains_list(chains)
    start_value = 0
    start_index = 0
    index_array = np.zeros(self.get_length(chains))
    for chain in chains:
        chain_length = self.get_length([chain])
        index_array[start_index : start_index + chain_length] = np.arange(
            start_value, start_value + chain_length
        )
        start_value += chain_length + index_bump
        start_index += chain_length
    return index_array.astype(int)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_length"><code class="name flex">
<span>def <span class="ident">get_length</span></span>(<span>self, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the total length of a set of chains.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chain</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Chain ID; if <code>None</code>, the length of the whole protein is returned</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of the chain</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_length(self, chains=None):
    &#34;&#34;&#34;Get the total length of a set of chains.

    Parameters
    ----------
    chain : str, optional
        Chain ID; if `None`, the length of the whole protein is returned

    Returns
    -------
    length : int
        Length of the chain

    &#34;&#34;&#34;
    chains = self._get_chains_list(chains)
    return sum([len(self.seq[x]) for x in chains])</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_ligand_features"><code class="name flex">
<span>def <span class="ident">get_ligand_features</span></span>(<span>self, ligands, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get ligand coordinates, smiles, and chain mapping.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ligands</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary mapping from chain IDs to a list of ligands, where each ligand is a dictionary</dd>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the ligands of the specified chains are returned (in the same order);
otherwise, all ligands are concatenated in alphabetical order of the chain IDs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>X_ligands</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>A <code>'torch'</code> tensor of shape <code>(N, 3)</code> with the ligand coordinates</dd>
<dt><strong><code>ligand_smiles</code></strong> :&ensp;<code>str</code></dt>
<dd>A string with the ligand smiles separated by a dot</dd>
<dt><strong><code>ligand_chains</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>A <code>'torch'</code> tensor of shape <code>(N, 1)</code> with the chain index of each atom</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ligand_features(self, ligands, chains=None):
    &#34;&#34;&#34;Get ligand coordinates, smiles, and chain mapping.

    Parameters
    ----------
    ligands : dict
        A dictionary mapping from chain IDs to a list of ligands, where each ligand is a dictionary
    chains : list of str, optional
        If specified, only the ligands of the specified chains are returned (in the same order);
        otherwise, all ligands are concatenated in alphabetical order of the chain IDs

    Returns
    -------
    X_ligands : torch.Tensor
        A `&#39;torch&#39;` tensor of shape `(N, 3)` with the ligand coordinates
    ligand_smiles : str
        A string with the ligand smiles separated by a dot
    ligand_chains : torch.Tensor
        A `&#39;torch&#39;` tensor of shape `(N, 1)` with the chain index of each atom
    &#34;&#34;&#34;
    chains = self._get_chains_list(chains)
    X_ligands = []
    ligand_smiles = []
    ligand_chains = []
    for chain_i, chain in enumerate(chains):
        all_smiles = &#34;.&#34;.join([x[&#34;smiles&#34;] for x in ligands[chain]])
        ligand_smiles.append(all_smiles)
        x_lig = np.concatenate([x[&#34;X&#34;] for x in ligands[chain]])
        X_ligands.append(x_lig)
        ligand_chains += [[chain_i]] * len(x_lig)
    ligand_smiles = &#34;.&#34;.join(ligand_smiles)
    X_ligands = from_numpy(np.concatenate(X_ligands, 0))
    ligand_chains = Tensor(ligand_chains)
    return (
        X_ligands,
        ligand_smiles,
        ligand_chains,
    )</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_mask"><code class="name flex">
<span>def <span class="ident">get_mask</span></span>(<span>self, chains=None, cdr=None, original=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the mask of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the masks of the specified chains are returned (in the same order);
otherwise, all masks are concatenated in alphabetical order of the chain IDs</dd>
<dt><strong><code>cdr</code></strong> :&ensp;<code>{"H1", "H2", "H3", "L1", "L2", "L3"}</code>, optional</dt>
<dd>If specified, only the CDR region of the specified type is returned</dd>
<dt><strong><code>original</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If <code>True</code>, return the original mask (before interpolation)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Mask array where 1 indicates residues with known coordinates and 0
indicates missing values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mask(self, chains=None, cdr=None, original=False):
    &#34;&#34;&#34;Get the mask of the protein.

    Parameters
    ----------
    chains : list of str, optional
        If specified, only the masks of the specified chains are returned (in the same order);
        otherwise, all masks are concatenated in alphabetical order of the chain IDs
    cdr : {&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;}, optional
        If specified, only the CDR region of the specified type is returned
    original : bool, default False
        If `True`, return the original mask (before interpolation)

    Returns
    -------
    mask : np.ndarray
        Mask array where 1 indicates residues with known coordinates and 0
        indicates missing values

    &#34;&#34;&#34;
    if cdr is not None and self.cdr is None:
        raise ValueError(&#34;CDR information not available&#34;)
    if cdr is not None:
        assert cdr in CDR_REVERSE, f&#34;CDR must be one of {list(CDR_REVERSE.keys())}&#34;
    chains = self._get_chains_list(chains)
    mask = np.concatenate(
        [self.mask_original[c] if original else self.mask[c] for c in chains],
        axis=0,
    )
    if cdr is not None:
        mask = mask[self.cdr == cdr]
    return mask</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_predict_mask"><code class="name flex">
<span>def <span class="ident">get_predict_mask</span></span>(<span>self, chains=None, only_known=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the prediction mask of the protein.</p>
<p>The prediction mask is a <code>'numpy'</code> array of shape <code>(L,)</code> with ones
corresponding to residues that were generated by a model and zeros to
residues with known coordinates. If the prediction mask is not available,
<code>None</code> is returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the prediction mask of the specified chains is returned (in the same order);
otherwise, all features are concatenated in alphabetical order of the chain IDs</dd>
<dt><strong><code>only_known</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If <code>True</code>, only residues with known coordinates are returned</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>predict_mask</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A <code>'numpy'</code> array of shape <code>(L,)</code> with ones corresponding to residues that were generated by a model and
zeros to residues with known coordinates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_predict_mask(self, chains=None, only_known=False):
    &#34;&#34;&#34;Get the prediction mask of the protein.

    The prediction mask is a `&#39;numpy&#39;` array of shape `(L,)` with ones
    corresponding to residues that were generated by a model and zeros to
    residues with known coordinates. If the prediction mask is not available,
    `None` is returned.

    Parameters
    ----------
    chains : list of str, optional
        If specified, only the prediction mask of the specified chains is returned (in the same order);
        otherwise, all features are concatenated in alphabetical order of the chain IDs
    only_known : bool, default False
        If `True`, only residues with known coordinates are returned

    Returns
    -------
    predict_mask : np.ndarray
        A `&#39;numpy&#39;` array of shape `(L,)` with ones corresponding to residues that were generated by a model and
        zeros to residues with known coordinates

    &#34;&#34;&#34;
    if list(self.predict_mask.values())[0] is None:
        return None
    chains = self._get_chains_list(chains)
    predict_mask = np.concatenate([self.predict_mask[chain] for chain in chains])
    if only_known:
        mask = self.get_mask(chains=chains)
        predict_mask = predict_mask[mask.astype(bool)]
    return predict_mask</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_predicted_chains"><code class="name flex">
<span>def <span class="ident">get_predicted_chains</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of chain IDs that contain predicted residues.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Chain IDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_predicted_chains(self):
    &#34;&#34;&#34;Return a list of chain IDs that contain predicted residues.

    Returns
    -------
    chains : list of str
        Chain IDs

    &#34;&#34;&#34;
    if not self.has_predict_mask():
        raise ValueError(&#34;Predicted mask not available&#34;)
    return [k for k, v in self.predict_mask.items() if v.sum() != 0]</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_predicted_entry"><code class="name flex">
<span>def <span class="ident">get_predicted_entry</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object that only contains predicted residues.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>The truncated <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_predicted_entry(self):
    &#34;&#34;&#34;Return a `ProteinEntry` object that only contains predicted residues.

    Returns
    -------
    entry : ProteinEntry
        The truncated `ProteinEntry` object

    &#34;&#34;&#34;
    if self.predict_mask is None:
        raise ValueError(&#34;Predicted mask not available&#34;)
    entry_dict = self.to_dict()
    for chain in self.get_chains():
        mask_ = self.predict_mask[chain].astype(bool)
        if mask_.sum() == 0:
            entry_dict.pop(chain)
            continue
        if mask_.sum() == len(mask_):
            continue
        seq_arr = np.array(list(entry_dict[chain][&#34;seq&#34;]))
        entry_dict[chain][&#34;seq&#34;] = &#34;&#34;.join(seq_arr[mask_])
        entry_dict[chain][&#34;crd_bb&#34;] = entry_dict[chain][&#34;crd_bb&#34;][mask_]
        entry_dict[chain][&#34;crd_sc&#34;] = entry_dict[chain][&#34;crd_sc&#34;][mask_]
        entry_dict[chain][&#34;msk&#34;] = entry_dict[chain][&#34;msk&#34;][mask_]
        entry_dict[chain][&#34;predict_msk&#34;] = entry_dict[chain][&#34;predict_msk&#34;][mask_]
        if &#34;cdr&#34; in entry_dict[chain]:
            entry_dict[chain][&#34;cdr&#34;] = entry_dict[chain][&#34;cdr&#34;][mask_]
    return ProteinEntry.from_dict(entry_dict)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.get_sequence"><code class="name flex">
<span>def <span class="ident">get_sequence</span></span>(<span>self, chains=None, encode=False, cdr=None, only_known=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the amino acid sequence of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the sequences of the specified chains is returned (in the same order);
otherwise, all sequences are concatenated in alphabetical order of the chain IDs</dd>
<dt><strong><code>encode</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If <code>True</code>, the sequence is encoded as a <code>'numpy'</code> array of integers
where each integer corresponds to the index of the amino acid in
<code>proteinflow.constants.ALPHABET</code></dd>
<dt><strong><code>cdr</code></strong> :&ensp;<code>{"H1", "H2", "H3", "L1", "L2", "L3"}</code>, optional</dt>
<dd>If specified, only the CDR region of the specified type is returned</dd>
<dt><strong><code>only_known</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If <code>True</code>, only the residues with known coordinates are returned</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>seq</code></strong> :&ensp;<code>str</code> or <code>np.ndarray</code></dt>
<dd>Amino acid sequence of the protein (one-letter code) or an encoded
sequence as a <code>'numpy'</code> array of integers</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sequence(self, chains=None, encode=False, cdr=None, only_known=False):
    &#34;&#34;&#34;Get the amino acid sequence of the protein.

    Parameters
    ----------
    chains : list of str, optional
        If specified, only the sequences of the specified chains is returned (in the same order);
        otherwise, all sequences are concatenated in alphabetical order of the chain IDs
    encode : bool, default False
        If `True`, the sequence is encoded as a `&#39;numpy&#39;` array of integers
        where each integer corresponds to the index of the amino acid in
        `proteinflow.constants.ALPHABET`
    cdr : {&#34;H1&#34;, &#34;H2&#34;, &#34;H3&#34;, &#34;L1&#34;, &#34;L2&#34;, &#34;L3&#34;}, optional
        If specified, only the CDR region of the specified type is returned
    only_known : bool, default False
        If `True`, only the residues with known coordinates are returned

    Returns
    -------
    seq : str or np.ndarray
        Amino acid sequence of the protein (one-letter code) or an encoded
        sequence as a `&#39;numpy&#39;` array of integers

    &#34;&#34;&#34;
    if cdr is not None and self.cdr is None:
        raise ValueError(&#34;CDR information not available&#34;)
    if cdr is not None:
        assert cdr in CDR_REVERSE, f&#34;CDR must be one of {list(CDR_REVERSE.keys())}&#34;
    chains = self._get_chains_list(chains)
    seq = &#34;&#34;.join([self.seq[c] for c in chains]).replace(&#34;B&#34;, &#34;&#34;)
    if encode:
        seq = np.array([ALPHABET_REVERSE[aa] for aa in seq])
    elif cdr is not None or only_known:
        seq = np.array(list(seq))
    if cdr is not None:
        cdr_arr = self.get_cdr(chains=chains)
        seq = seq[cdr_arr == cdr]
    if only_known:
        seq = seq[self.get_mask(chains=chains, cdr=cdr).astype(bool)]
    if not encode and not isinstance(seq, str):
        seq = &#34;&#34;.join(seq)
    return seq</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.has_cdr"><code class="name flex">
<span>def <span class="ident">has_cdr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the protein is from the SAbDab database.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>is_sabdab</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if the protein is from the SAbDab database</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_cdr(self):
    &#34;&#34;&#34;Check if the protein is from the SAbDab database.

    Returns
    -------
    is_sabdab : bool
        True if the protein is from the SAbDab database

    &#34;&#34;&#34;
    return list(self.cdr.values())[0] is not None</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.has_predict_mask"><code class="name flex">
<span>def <span class="ident">has_predict_mask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the protein has a predicted mask.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>has_predict_mask</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if the protein has a predicted mask</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_predict_mask(self):
    &#34;&#34;&#34;Check if the protein has a predicted mask.

    Returns
    -------
    has_predict_mask : bool
        True if the protein has a predicted mask

    &#34;&#34;&#34;
    return list(self.predict_mask.values())[0] is not None</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.interpolate_coords"><code class="name flex">
<span>def <span class="ident">interpolate_coords</span></span>(<span>self, fill_ends=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill in missing values in the coordinates arrays with linear interpolation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fill_ends</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If <code>True</code>, fill in missing values at the ends of the protein sequence with the edge values;
otherwise fill them in with zeros</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_coords(self, fill_ends=True):
    &#34;&#34;&#34;Fill in missing values in the coordinates arrays with linear interpolation.

    Parameters
    ----------
    fill_ends : bool, default True
        If `True`, fill in missing values at the ends of the protein sequence with the edge values;
        otherwise fill them in with zeros

    &#34;&#34;&#34;
    for chain in self.get_chains():
        self.crd[chain], self.mask[chain] = interpolate_coords(
            self.crd[chain], self.mask[chain], fill_ends=fill_ends
        )</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.is_valid_pair"><code class="name flex">
<span>def <span class="ident">is_valid_pair</span></span>(<span>self, chain1, chain2, cutoff=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if two chains are a valid pair based on the distance between them.</p>
<p>We consider two chains to be a valid pair if the distance between them is
smaller than <code>cutoff</code> Angstroms. The distance is calculated as the minimum
distance between any two atoms of the two chains.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chain1</code></strong> :&ensp;<code>str</code></dt>
<dd>Chain ID of the first chain</dd>
<dt><strong><code>chain2</code></strong> :&ensp;<code>str</code></dt>
<dd>Chain ID of the second chain</dd>
<dt><strong><code>cutoff</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Minimum distance between the two chains (in Angstroms)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>valid</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the two chains are a valid pair, <code>False</code> otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@lru_cache()
def is_valid_pair(self, chain1, chain2, cutoff=10):
    &#34;&#34;&#34;Check if two chains are a valid pair based on the distance between them.

    We consider two chains to be a valid pair if the distance between them is
    smaller than `cutoff` Angstroms. The distance is calculated as the minimum
    distance between any two atoms of the two chains.

    Parameters
    ----------
    chain1 : str
        Chain ID of the first chain
    chain2 : str
        Chain ID of the second chain
    cutoff : int, optional
        Minimum distance between the two chains (in Angstroms)

    Returns
    -------
    valid : bool
        `True` if the two chains are a valid pair, `False` otherwise

    &#34;&#34;&#34;
    margin = cutoff * 3
    assert chain1 in self.get_chains(), f&#34;Chain {chain1} not found&#34;
    assert chain2 in self.get_chains(), f&#34;Chain {chain2} not found&#34;
    X1 = self.get_coordinates(chains=[chain1], only_known=True)
    X2 = self.get_coordinates(chains=[chain2], only_known=True)
    intersect_dim_X1 = []
    intersect_dim_X2 = []
    intersect_X1 = np.zeros(len(X1))
    intersect_X2 = np.zeros(len(X2))
    for dim in range(3):
        min_dim_1 = X1[:, 2, dim].min()
        max_dim_1 = X1[:, 2, dim].max()
        min_dim_2 = X2[:, 2, dim].min()
        max_dim_2 = X2[:, 2, dim].max()
        intersect_dim_X1.append(
            np.where(
                np.logical_and(
                    X1[:, 2, dim] &gt;= min_dim_2 - margin,
                    X1[:, 2, dim] &lt;= max_dim_2 + margin,
                )
            )[0]
        )
        intersect_dim_X2.append(
            np.where(
                np.logical_and(
                    X2[:, 2, dim] &gt;= min_dim_1 - margin,
                    X2[:, 2, dim] &lt;= max_dim_1 + margin,
                )
            )[0]
        )

    intersect_X1 = np.intersect1d(
        np.intersect1d(intersect_dim_X1[0], intersect_dim_X1[1]),
        intersect_dim_X1[2],
    )
    intersect_X2 = np.intersect1d(
        np.intersect1d(intersect_dim_X2[0], intersect_dim_X2[1]),
        intersect_dim_X2[2],
    )

    not_end_mask1 = np.where((X1[:, 2, :] == 0).sum(-1) != 3)[0]
    not_end_mask2 = np.where((X2[:, 2, :] == 0).sum(-1) != 3)[0]

    intersect_X1 = np.intersect1d(intersect_X1, not_end_mask1)
    intersect_X2 = np.intersect1d(intersect_X2, not_end_mask2)

    diff = X1[intersect_X1, 2, np.newaxis, :] - X2[intersect_X2, 2, :]
    distances = np.sqrt(np.sum(diff**2, axis=2))

    if np.sum(distances &lt; cutoff) &lt; 3:
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.long_repeat_num"><code class="name flex">
<span>def <span class="ident">long_repeat_num</span></span>(<span>self, thr=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the number of long repeats in the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>thr</code></strong> :&ensp;<code>int</code>, default <code>5</code></dt>
<dd>The threshold for the minimum length of the repeat</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of long repeats in the protein</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def long_repeat_num(self, thr=5):
    &#34;&#34;&#34;Calculate the number of long repeats in the protein.

    Parameters
    ----------
    thr : int, default 5
        The threshold for the minimum length of the repeat

    Returns
    -------
    num : int
        The number of long repeats in the protein

    &#34;&#34;&#34;
    seq = self.get_sequence(encode=False)
    if self.predict_mask is not None:
        predict_mask = self.get_predict_mask()
        seq = np.array(list(seq))[predict_mask.astype(bool)]
    return long_repeat_num(seq, thr=thr)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, entry)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge another <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object into this one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>The merged <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, entry):
    &#34;&#34;&#34;Merge another `ProteinEntry` object into this one.

    Parameters
    ----------
    entry : ProteinEntry
        The merged `ProteinEntry` object

    &#34;&#34;&#34;
    for chain in entry.get_chains():
        if chain.split(&#34;_&#34;)[0] in {x.split(&#34;_&#34;)[0] for x in self.get_chains()}:
            raise ValueError(&#34;Chain IDs must be unique&#34;)
        self.seq[chain] = entry.seq[chain]
        self.crd[chain] = entry.crd[chain]
        self.mask[chain] = entry.mask[chain]
        self.mask_original[chain] = entry.mask_original[chain]
        self.cdr[chain] = entry.cdr[chain]
        self.predict_mask[chain] = entry.predict_mask[chain]
    if not all([x is None for x in self.predict_mask.values()]):
        for k, v in self.predict_mask.items():
            if v is None:
                self.predict_mask[k] = np.zeros(len(self.get_sequence(k)))</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.rename_chains"><code class="name flex">
<span>def <span class="ident">rename_chains</span></span>(<span>self, chain_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename the chains of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chain_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary mapping old chain IDs to new chain IDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_chains(self, chain_dict):
    &#34;&#34;&#34;Rename the chains of the protein.

    Parameters
    ----------
    chain_dict : dict
        A dictionary mapping old chain IDs to new chain IDs

    &#34;&#34;&#34;
    self._rename_chains({k: k * 5 for k in self.get_chains()})
    self._rename_chains({k * 5: v for k, v in chain_dict.items()})</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.secondary_structure"><code class="name flex">
<span>def <span class="ident">secondary_structure</span></span>(<span>self, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the secondary structure of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the secondary structure of the specified chains is returned (in the same order);
otherwise, all features are concatenated in alphabetical order of the chain IDs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sse</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A <code>'numpy'</code> array of shape <code>(L, 3)</code> with secondary structure
elements encoded as one-hot vectors (alpha-helix, beta-sheet, loop);
missing values are marked with zeros</dd>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the secondary structure of the specified chains is returned (in the same order);
otherwise, all features are concatenated in alphabetical order of the chain IDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def secondary_structure(self, chains=None):
    &#34;&#34;&#34;Calculate the secondary structure of the protein.

    Parameters
    ----------
    chains : list of str, optional
        If specified, only the secondary structure of the specified chains is returned (in the same order);
        otherwise, all features are concatenated in alphabetical order of the chain IDs

    Returns
    -------
    sse : np.ndarray
        A `&#39;numpy&#39;` array of shape `(L, 3)` with secondary structure
        elements encoded as one-hot vectors (alpha-helix, beta-sheet, loop);
        missing values are marked with zeros
    chains : list of str, optional
        If specified, only the secondary structure of the specified chains is returned (in the same order);
        otherwise, all features are concatenated in alphabetical order of the chain IDs

    &#34;&#34;&#34;
    chains = self._get_chains_list(chains)
    out = []
    for chain in chains:
        crd = self.get_coordinates([chain])
        sse_map = {&#34;c&#34;: [0, 0, 1], &#34;b&#34;: [0, 1, 0], &#34;a&#34;: [1, 0, 0], &#34;&#34;: [0, 0, 0]}
        sse = _annotate_sse(crd[:, :4])
        out += [sse_map[x] for x in sse]
    sse = np.array(out)
    return sse</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.set_predict_mask"><code class="name flex">
<span>def <span class="ident">set_predict_mask</span></span>(<span>self, mask_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the predicted mask.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mask_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary mapping from chain IDs to a <code>np.ndarray</code> mask of 0s and 1s of the same length as the chain sequence</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_predict_mask(self, mask_dict):
    &#34;&#34;&#34;Set the predicted mask.

    Parameters
    ----------
    mask_dict : dict
        A dictionary mapping from chain IDs to a `np.ndarray` mask of 0s and 1s of the same length as the chain sequence

    &#34;&#34;&#34;
    for chain in mask_dict:
        if chain not in self.get_chains():
            raise PDBError(&#34;Chain not found&#34;)
        if len(mask_dict[chain]) != self.get_length([chain]):
            raise PDBError(&#34;Mask length does not match sequence length&#34;)
    self.predict_mask = mask_dict</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.sidechain_coordinates"><code class="name flex">
<span>def <span class="ident">sidechain_coordinates</span></span>(<span>self, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the sidechain coordinates of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the sidechain coordinates of the specified chains is returned (in the same order);
otherwise, all features are concatenated in alphabetical order of the chain IDs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>crd</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A <code>'numpy'</code> array of shape <code>(L, 10, 3)</code> with sidechain atom
coordinates (check <code><a title="proteinflow.sidechain_order" href="../index.html#proteinflow.sidechain_order">sidechain_order()</a></code> for the order of
atoms); missing values are marked with zeros</dd>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the sidechain coordinates of the specified chains are returned (in the same order);
otherwise, all features are concatenated in alphabetical order of the chain IDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sidechain_coordinates(self, chains=None):
    &#34;&#34;&#34;Get the sidechain coordinates of the protein.

    Parameters
    ----------
    chains : list of str, optional
        If specified, only the sidechain coordinates of the specified chains is returned (in the same order);
        otherwise, all features are concatenated in alphabetical order of the chain IDs

    Returns
    -------
    crd : np.ndarray
        A `&#39;numpy&#39;` array of shape `(L, 10, 3)` with sidechain atom
        coordinates (check `proteinflow.sidechain_order()` for the order of
        atoms); missing values are marked with zeros
    chains : list of str, optional
        If specified, only the sidechain coordinates of the specified chains are returned (in the same order);
        otherwise, all features are concatenated in alphabetical order of the chain IDs

    &#34;&#34;&#34;
    chains = self._get_chains_list(chains)
    return self.get_coordinates(chains)[:, 4:, :]</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.sidechain_orientation"><code class="name flex">
<span>def <span class="ident">sidechain_orientation</span></span>(<span>self, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the (global) sidechain orientation of the protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the sidechain orientation of the specified chains is returned (in the same order);
otherwise, all features are concatenated in alphabetical order of the chain IDs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>orientation</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A <code>'numpy'</code> array of shape <code>(L, 3)</code> with sidechain orientation
vectors; missing values are marked with zeros</dd>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>If specified, only the sidechain orientation of the specified chains is returned (in the same order);
otherwise, all features are concatenated in alphabetical order of the chain IDs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sidechain_orientation(self, chains=None):
    &#34;&#34;&#34;Calculate the (global) sidechain orientation of the protein.

    Parameters
    ----------
    chains : list of str, optional
        If specified, only the sidechain orientation of the specified chains is returned (in the same order);
        otherwise, all features are concatenated in alphabetical order of the chain IDs

    Returns
    -------
    orientation : np.ndarray
        A `&#39;numpy&#39;` array of shape `(L, 3)` with sidechain orientation
        vectors; missing values are marked with zeros
    chains : list of str, optional
        If specified, only the sidechain orientation of the specified chains is returned (in the same order);
        otherwise, all features are concatenated in alphabetical order of the chain IDs

    &#34;&#34;&#34;
    chains = self._get_chains_list(chains)
    crd = self.get_coordinates(chains=chains)
    crd_bb, crd_sc = crd[:, :4, :], crd[:, 4:, :]
    seq = self.get_sequence(chains=chains, encode=True)
    orientation = np.zeros((crd_sc.shape[0], 3))
    for i in range(1, 21):
        if MAIN_ATOM_DICT[i] is not None:
            orientation[seq == i] = (
                crd_sc[seq == i, MAIN_ATOM_DICT[i], :] - crd_bb[seq == i, 2, :]
            )
        else:
            S_mask = self.seq == i
            orientation[S_mask] = np.random.rand(*orientation[S_mask].shape)
    orientation /= np.expand_dims(np.linalg.norm(orientation, axis=-1), -1) + 1e-7
    return orientation</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.tm_score"><code class="name flex">
<span>def <span class="ident">tm_score</span></span>(<span>self, entry, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate TM score between two proteins.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></dt>
<dd>A <code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code> object</dd>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>A list of chain IDs to consider</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tm_score</code></strong> :&ensp;<code>float</code></dt>
<dd>The TM score between the two proteins</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tm_score(self, entry, chains=None):
    &#34;&#34;&#34;Calculate TM score between two proteins.

    Parameters
    ----------
    entry : ProteinEntry
        A `ProteinEntry` object
    chains : list of str, optional
        A list of chain IDs to consider

    Returns
    -------
    tm_score : float
        The TM score between the two proteins

    &#34;&#34;&#34;
    structure1 = self.get_coordinates(only_known=True, chains=chains)[:, 2]
    structure2 = entry.get_coordinates(only_known=True, chains=chains)[:, 2]
    sequence1 = self.get_sequence(only_known=True, chains=chains)
    sequence2 = entry.get_sequence(only_known=True, chains=chains)
    return tm_score(structure1, structure2, sequence1, sequence2)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a protein entry into a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>A nested dictionary where first-level keys are chain IDs and
second-level keys are the following:
- <code>'seq'</code> : amino acid sequence (one-letter code)
- <code>'crd_bb'</code> : backbone coordinates, shaped <code>(L, 4, 3)</code>
- <code>'crd_sc'</code> : sidechain coordinates, shaped <code>(L, 10, 3)</code>
- <code>'msk'</code> : mask array where 1 indicates residues with known coordinates and 0
indicates missing values, shaped <code>(L,)</code>
- <code>'cdr'</code> (optional): CDR information, shaped <code>(L,)</code> encoded as integers where each
integer corresponds to the index of the CDR type in
<code>proteinflow.constants.CDR_ALPHABET</code>
- <code>'predict_msk'</code> (optional): mask array where 1 indicates residues that were generated by a model and 0
indicates residues with known coordinates, shaped <code>(L,)</code>
It can optionally also contain <code>protein_id</code> as a first-level key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    &#34;&#34;&#34;Convert a protein entry into a dictionary.

    Returns
    -------
    dictionary : dict
        A nested dictionary where first-level keys are chain IDs and
        second-level keys are the following:
        - `&#39;seq&#39;` : amino acid sequence (one-letter code)
        - `&#39;crd_bb&#39;` : backbone coordinates, shaped `(L, 4, 3)`
        - `&#39;crd_sc&#39;` : sidechain coordinates, shaped `(L, 10, 3)`
        - `&#39;msk&#39;` : mask array where 1 indicates residues with known coordinates and 0
            indicates missing values, shaped `(L,)`
        - `&#39;cdr&#39;` (optional): CDR information, shaped `(L,)` encoded as integers where each
            integer corresponds to the index of the CDR type in
            `proteinflow.constants.CDR_ALPHABET`
        - `&#39;predict_msk&#39;` (optional): mask array where 1 indicates residues that were generated by a model and 0
            indicates residues with known coordinates, shaped `(L,)`
        It can optionally also contain `protein_id` as a first-level key.

    &#34;&#34;&#34;
    data = {}
    for chain in self.get_chains():
        data[chain] = {
            &#34;seq&#34;: self.seq[chain],
            &#34;crd_bb&#34;: self.crd[chain][:, :4],
            &#34;crd_sc&#34;: self.crd[chain][:, 4:],
            &#34;msk&#34;: self.mask[chain],
        }
        if self.cdr[chain] is not None:
            data[chain][&#34;cdr&#34;] = self.cdr[chain]
        if self.predict_mask[chain] is not None:
            data[chain][&#34;predict_msk&#34;] = self.predict_mask[chain]
    if self.id is not None:
        data[&#34;protein_id&#34;] = self.id
    return data</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.to_pdb"><code class="name flex">
<span>def <span class="ident">to_pdb</span></span>(<span>self, path, only_ca=False, skip_oxygens=False, only_backbone=False, title=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the protein entry to a PDB file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the output PDB file</dd>
<dt><strong><code>only_ca</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If <code>True</code>, only backbone atoms are saved</dd>
<dt><strong><code>skip_oxygens</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If <code>True</code>, oxygen atoms are not saved</dd>
<dt><strong><code>only_backbone</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If <code>True</code>, only backbone atoms are saved</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Title of the PDB file (by default either the protein id or "Untitled")</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_pdb(
    self,
    path,
    only_ca=False,
    skip_oxygens=False,
    only_backbone=False,
    title=None,
):
    &#34;&#34;&#34;Save the protein entry to a PDB file.

    Parameters
    ----------
    path : str
        Path to the output PDB file
    only_ca : bool, default False
        If `True`, only backbone atoms are saved
    skip_oxygens : bool, default False
        If `True`, oxygen atoms are not saved
    only_backbone : bool, default False
        If `True`, only backbone atoms are saved
    title : str, optional
        Title of the PDB file (by default either the protein id or &#34;Untitled&#34;)

    &#34;&#34;&#34;
    pdb_builder = PDBBuilder(
        self,
        only_ca=only_ca,
        skip_oxygens=skip_oxygens,
        only_backbone=only_backbone,
    )
    if title is None:
        if self.id is not None:
            title = self.id
        else:
            title = &#34;Untitled&#34;
    pdb_builder.save_pdb(path, title=title)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.to_pickle"><code class="name flex">
<span>def <span class="ident">to_pickle</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Save a protein entry to a pickle file.</p>
<p>The output files are pickled nested dictionaries where first-level keys are chain Ids and second-level keys are the following:
- <code>'crd_bb'</code>: a <code>numpy</code> array of shape <code>(L, 4, 3)</code> with backbone atom coordinates (N, C, CA, O),
- <code>'crd_sc'</code>: a <code>numpy</code> array of shape <code>(L, 10, 3)</code> with sidechain atom coordinates (check <code><a title="proteinflow.sidechain_order" href="../index.html#proteinflow.sidechain_order">sidechain_order()</a></code> for the order of atoms),
- <code>'msk'</code>: a <code>numpy</code> array of shape <code>(L,)</code> where ones correspond to residues with known coordinates and
zeros to missing values,
- <code>'seq'</code>: a string of length <code>L</code> with residue types.</p>
<p>In a SAbDab datasets, an additional key is added to the dictionary:
- <code>'cdr'</code>: a <code>'numpy'</code> array of shape <code>(L,)</code> where CDR residues are marked with the corresponding type (<code>'H1'</code>, <code>'L1'</code>, &hellip;)
and non-CDR residues are marked with <code>'-'</code>.</p>
<p>If a prediction mask is available, another additional key is added to the dictionary:
- <code>'predict_msk'</code>: a <code>numpy</code> array of shape <code>(L,)</code> where ones correspond to residues that were generated by a model and
zeros to residues with known coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the pickle file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_pickle(self, path):
    &#34;&#34;&#34;Save a protein entry to a pickle file.

    The output files are pickled nested dictionaries where first-level keys are chain Ids and second-level keys are the following:
    - `&#39;crd_bb&#39;`: a `numpy` array of shape `(L, 4, 3)` with backbone atom coordinates (N, C, CA, O),
    - `&#39;crd_sc&#39;`: a `numpy` array of shape `(L, 10, 3)` with sidechain atom coordinates (check `proteinflow.sidechain_order()` for the order of atoms),
    - `&#39;msk&#39;`: a `numpy` array of shape `(L,)` where ones correspond to residues with known coordinates and
        zeros to missing values,
    - `&#39;seq&#39;`: a string of length `L` with residue types.

    In a SAbDab datasets, an additional key is added to the dictionary:
    - `&#39;cdr&#39;`: a `&#39;numpy&#39;` array of shape `(L,)` where CDR residues are marked with the corresponding type (`&#39;H1&#39;`, `&#39;L1&#39;`, ...)
        and non-CDR residues are marked with `&#39;-&#39;`.

    If a prediction mask is available, another additional key is added to the dictionary:
    - `&#39;predict_msk&#39;`: a `numpy` array of shape `(L,)` where ones correspond to residues that were generated by a model and
        zeros to residues with known coordinates.

    Parameters
    ----------
    path : str
        Path to the pickle file

    &#34;&#34;&#34;
    data = self.to_dict()
    with open(path, &#34;wb&#34;) as f:
        pickle.dump(data, f)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.ProteinEntry.visualize"><code class="name flex">
<span>def <span class="ident">visualize</span></span>(<span>self, highlight_mask=None, style='cartoon', highlight_style=None, opacity=1, canvas_size=(400, 300))</span>
</code></dt>
<dd>
<div class="desc"><p>Visualize the protein in a notebook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>highlight_mask</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>A <code>'numpy'</code> array of shape <code>(L,)</code> with the residues to highlight
marked with 1 and the rest marked with 0; if not given and
<code>self.predict_mask</code> is not <code>None</code>, the predicted residues are highlighted</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str</code>, default <code>'cartoon'</code></dt>
<dd>The style of the visualization; one of 'cartoon', 'sphere', 'stick', 'line', 'cross'</dd>
<dt><strong><code>highlight_style</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The style of the highlighted atoms; one of 'cartoon', 'sphere', 'stick', 'line', 'cross'
(defaults to the same as <code>style</code>)</dd>
<dt><strong><code>opacity</code></strong> :&ensp;<code>float</code> or <code>dict</code>, default <code>1</code></dt>
<dd>Opacity of the visualization (can be a dictionary mapping from chain IDs to opacity values)</dd>
<dt><strong><code>canvas_size</code></strong> :&ensp;<code>tuple</code>, default <code>(400, 300)</code></dt>
<dd>Shape of the canvas</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualize(
    self,
    highlight_mask=None,
    style=&#34;cartoon&#34;,
    highlight_style=None,
    opacity=1,
    canvas_size=(400, 300),
):
    &#34;&#34;&#34;Visualize the protein in a notebook.

    Parameters
    ----------
    highlight_mask : np.ndarray, optional
        A `&#39;numpy&#39;` array of shape `(L,)` with the residues to highlight
        marked with 1 and the rest marked with 0; if not given and
        `self.predict_mask` is not `None`, the predicted residues are highlighted
    style : str, default &#39;cartoon&#39;
        The style of the visualization; one of &#39;cartoon&#39;, &#39;sphere&#39;, &#39;stick&#39;, &#39;line&#39;, &#39;cross&#39;
    highlight_style : str, optional
        The style of the highlighted atoms; one of &#39;cartoon&#39;, &#39;sphere&#39;, &#39;stick&#39;, &#39;line&#39;, &#39;cross&#39;
        (defaults to the same as `style`)
    opacity : float or dict, default 1
        Opacity of the visualization (can be a dictionary mapping from chain IDs to opacity values)
    canvas_size : tuple, default (400, 300)
        Shape of the canvas

    &#34;&#34;&#34;
    if highlight_mask is not None:
        highlight_mask_dict = self._get_highlight_mask_dict(highlight_mask)
    elif list(self.predict_mask.values())[0] is not None:
        highlight_mask_dict = {
            chain: self.predict_mask[chain][self.get_mask([chain]).astype(bool)]
            for chain in self.get_chains()
        }
    else:
        highlight_mask_dict = None
    with tempfile.NamedTemporaryFile(suffix=&#34;.pdb&#34;) as tmp:
        self.to_pdb(tmp.name)
        pdb_entry = PDBEntry(tmp.name)
    pdb_entry.visualize(
        highlight_mask_dict=highlight_mask_dict,
        style=style,
        highlight_style=highlight_style,
        opacity=opacity,
        canvas_size=canvas_size,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="proteinflow.data.SAbDabEntry"><code class="flex name class">
<span>class <span class="ident">SAbDabEntry</span></span>
<span>(</span><span>pdb_path, fasta_path, heavy_chain=None, light_chain=None, antigen_chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for parsing SAbDab entries.</p>
<p>Initialize the SAbDabEntry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pdb_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the PDB file</dd>
<dt><strong><code>fasta_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the FASTA file</dd>
<dt><strong><code>heavy_chain</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Heavy chain identifier (author chain name)</dd>
<dt><strong><code>light_chain</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Light chain identifier (author chain name)</dd>
<dt><strong><code>antigen_chains</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>List of antigen chain identifiers (author chain names)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SAbDabEntry(PDBEntry):
    &#34;&#34;&#34;A class for parsing SAbDab entries.&#34;&#34;&#34;

    def __init__(
        self,
        pdb_path,
        fasta_path,
        heavy_chain=None,
        light_chain=None,
        antigen_chains=None,
    ):
        &#34;&#34;&#34;Initialize the SAbDabEntry.

        Parameters
        ----------
        pdb_path : str
            Path to the PDB file
        fasta_path : str
            Path to the FASTA file
        heavy_chain : str, optional
            Heavy chain identifier (author chain name)
        light_chain : str, optional
            Light chain identifier (author chain name)
        antigen_chains : list, optional
            List of antigen chain identifiers (author chain names)

        &#34;&#34;&#34;
        if heavy_chain is None and light_chain is None:
            raise PDBError(&#34;At least one chain must be provided&#34;)
        self.chain_dict = {
            &#34;heavy&#34;: heavy_chain,
            &#34;light&#34;: light_chain,
        }
        if antigen_chains is None:
            antigen_chains = []
        self.chain_dict[&#34;antigen&#34;] = antigen_chains
        self.reverse_chain_dict = {
            heavy_chain: &#34;heavy&#34;,
            light_chain: &#34;light&#34;,
        }
        for antigen_chain in antigen_chains:
            self.reverse_chain_dict[antigen_chain] = &#34;antigen&#34;
        super().__init__(pdb_path, fasta_path)

    def _get_relevant_chains(self):
        &#34;&#34;&#34;Get the chains that are included in the entry.&#34;&#34;&#34;
        chains = []
        if self.chain_dict[&#34;heavy&#34;] is not None:
            chains.append(self.chain_dict[&#34;heavy&#34;])
        if self.chain_dict[&#34;light&#34;] is not None:
            chains.append(self.chain_dict[&#34;light&#34;])
        chains.extend(self.chain_dict[&#34;antigen&#34;])
        return chains

    @staticmethod
    def from_id(
        pdb_id,
        local_folder=&#34;.&#34;,
        light_chain=None,
        heavy_chain=None,
        antigen_chains=None,
    ):
        &#34;&#34;&#34;Create a SAbDabEntry from a PDB ID.

        Either the light or the heavy chain must be provided.

        Parameters
        ----------
        pdb_id : str
            PDB ID
        local_folder : str, optional
            Local folder to download the PDB and FASTA files
        light_chain : str, optional
            Light chain identifier (author chain name)
        heavy_chain : str, optional
            Heavy chain identifier (author chain name)
        antigen_chains : list, optional
            List of antigen chain identifiers (author chain names)

        Returns
        -------
        entry : SAbDabEntry
            A SAbDabEntry object

        &#34;&#34;&#34;
        pdb_path = download_pdb(pdb_id, local_folder, sabdab=True)
        fasta_path = download_fasta(pdb_id, local_folder)
        return SAbDabEntry(
            pdb_path=pdb_path,
            fasta_path=fasta_path,
            light_chain=light_chain,
            heavy_chain=heavy_chain,
            antigen_chains=antigen_chains,
        )

    def _get_chain(self, chain):
        &#34;&#34;&#34;Return the chain identifier.&#34;&#34;&#34;
        if chain in [&#34;heavy&#34;, &#34;light&#34;]:
            chain = self.chain_dict[chain]
        return super()._get_chain(chain)

    def heavy_chain(self):
        &#34;&#34;&#34;Return the heavy chain identifier.

        Returns
        -------
        chain : str
            The heavy chain identifier

        &#34;&#34;&#34;
        return self.chain_dict[&#34;heavy&#34;]

    def light_chain(self):
        &#34;&#34;&#34;Return the light chain identifier.

        Returns
        -------
        chain : str
            The light chain identifier

        &#34;&#34;&#34;
        return self.chain_dict[&#34;light&#34;]

    def antigen_chains(self):
        &#34;&#34;&#34;Return the antigen chain identifiers.

        Returns
        -------
        chains : list
            The antigen chain identifiers

        &#34;&#34;&#34;
        return self.chain_dict[&#34;antigen&#34;]

    def chains(self):
        &#34;&#34;&#34;Return the chains in the PDB.

        Returns
        -------
        chains : list
            A list of chain identifiers

        &#34;&#34;&#34;
        return [self.heavy_chain(), self.light_chain()] + self.antigen_chains()

    def chain_type(self, chain):
        &#34;&#34;&#34;Return the type of a chain.

        Parameters
        ----------
        chain : str
            Chain identifier

        Returns
        -------
        chain_type : str
            The type of the chain (heavy, light or antigen)

        &#34;&#34;&#34;
        if chain in self.reverse_chain_dict:
            return self.reverse_chain_dict[chain]
        raise PDBError(&#34;Chain not found&#34;)

    @lru_cache()
    def _get_chain_cdr(self, chain, align_to_fasta=True):
        &#34;&#34;&#34;Return the CDRs for a given chain ID.&#34;&#34;&#34;
        chain = self._get_chain(chain)
        chain_crd = self.get_pdb_df(chain)
        chain_type = self.chain_type(chain)[0].upper()
        pdb_seq = self._pdb_sequence(chain)
        unique_numbers = chain_crd[&#34;unique_residue_number&#34;].unique()
        if len(unique_numbers) != len(pdb_seq):
            raise PDBError(&#34;Inconsistencies in the biopandas dataframe&#34;)
        if chain_type in [&#34;H&#34;, &#34;L&#34;]:
            cdr_arr = [
                CDR_VALUES[chain_type][int(x.split(&#34;_&#34;)[0])] for x in unique_numbers
            ]
            cdr_arr = np.array(cdr_arr)
        else:
            cdr_arr = np.array([&#34;-&#34;] * len(unique_numbers), dtype=object)
        if align_to_fasta:
            aligned_seq, _ = self._align_chain(chain)
            aligned_seq_arr = np.array(list(aligned_seq))
            cdr_arr_aligned = np.array([&#34;-&#34;] * len(aligned_seq), dtype=object)
            cdr_arr_aligned[aligned_seq_arr != &#34;-&#34;] = cdr_arr
            cdr_arr = cdr_arr_aligned
        return cdr_arr

    def get_cdr(self, chains=None):
        &#34;&#34;&#34;Return CDR arrays.

        Parameters
        ----------
        chains : list, optional
            A list of chain identifiers (if not provided, all chains are processed)

        Returns
        -------
        cdrs : dict
            A dictionary containing the CDR arrays for each of the chains

        &#34;&#34;&#34;
        if chains is None:
            chains = self.chains()
        return {chain: self._get_chain_cdr(chain) for chain in chains}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="proteinflow.data.SAbDabEntry.from_id"><code class="name flex">
<span>def <span class="ident">from_id</span></span>(<span>pdb_id, local_folder='.', light_chain=None, heavy_chain=None, antigen_chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a SAbDabEntry from a PDB ID.</p>
<p>Either the light or the heavy chain must be provided.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pdb_id</code></strong> :&ensp;<code>str</code></dt>
<dd>PDB ID</dd>
<dt><strong><code>local_folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Local folder to download the PDB and FASTA files</dd>
<dt><strong><code>light_chain</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Light chain identifier (author chain name)</dd>
<dt><strong><code>heavy_chain</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Heavy chain identifier (author chain name)</dd>
<dt><strong><code>antigen_chains</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>List of antigen chain identifiers (author chain names)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>entry</code></strong> :&ensp;<code><a title="proteinflow.data.SAbDabEntry" href="#proteinflow.data.SAbDabEntry">SAbDabEntry</a></code></dt>
<dd>A SAbDabEntry object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_id(
    pdb_id,
    local_folder=&#34;.&#34;,
    light_chain=None,
    heavy_chain=None,
    antigen_chains=None,
):
    &#34;&#34;&#34;Create a SAbDabEntry from a PDB ID.

    Either the light or the heavy chain must be provided.

    Parameters
    ----------
    pdb_id : str
        PDB ID
    local_folder : str, optional
        Local folder to download the PDB and FASTA files
    light_chain : str, optional
        Light chain identifier (author chain name)
    heavy_chain : str, optional
        Heavy chain identifier (author chain name)
    antigen_chains : list, optional
        List of antigen chain identifiers (author chain names)

    Returns
    -------
    entry : SAbDabEntry
        A SAbDabEntry object

    &#34;&#34;&#34;
    pdb_path = download_pdb(pdb_id, local_folder, sabdab=True)
    fasta_path = download_fasta(pdb_id, local_folder)
    return SAbDabEntry(
        pdb_path=pdb_path,
        fasta_path=fasta_path,
        light_chain=light_chain,
        heavy_chain=heavy_chain,
        antigen_chains=antigen_chains,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="proteinflow.data.SAbDabEntry.antigen_chains"><code class="name flex">
<span>def <span class="ident">antigen_chains</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the antigen chain identifiers.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code></dt>
<dd>The antigen chain identifiers</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def antigen_chains(self):
    &#34;&#34;&#34;Return the antigen chain identifiers.

    Returns
    -------
    chains : list
        The antigen chain identifiers

    &#34;&#34;&#34;
    return self.chain_dict[&#34;antigen&#34;]</code></pre>
</details>
</dd>
<dt id="proteinflow.data.SAbDabEntry.chain_type"><code class="name flex">
<span>def <span class="ident">chain_type</span></span>(<span>self, chain)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the type of a chain.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chain</code></strong> :&ensp;<code>str</code></dt>
<dd>Chain identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chain_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of the chain (heavy, light or antigen)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chain_type(self, chain):
    &#34;&#34;&#34;Return the type of a chain.

    Parameters
    ----------
    chain : str
        Chain identifier

    Returns
    -------
    chain_type : str
        The type of the chain (heavy, light or antigen)

    &#34;&#34;&#34;
    if chain in self.reverse_chain_dict:
        return self.reverse_chain_dict[chain]
    raise PDBError(&#34;Chain not found&#34;)</code></pre>
</details>
</dd>
<dt id="proteinflow.data.SAbDabEntry.chains"><code class="name flex">
<span>def <span class="ident">chains</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the chains in the PDB.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of chain identifiers</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chains(self):
    &#34;&#34;&#34;Return the chains in the PDB.

    Returns
    -------
    chains : list
        A list of chain identifiers

    &#34;&#34;&#34;
    return [self.heavy_chain(), self.light_chain()] + self.antigen_chains()</code></pre>
</details>
</dd>
<dt id="proteinflow.data.SAbDabEntry.get_cdr"><code class="name flex">
<span>def <span class="ident">get_cdr</span></span>(<span>self, chains=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return CDR arrays.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chains</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>A list of chain identifiers (if not provided, all chains are processed)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cdrs</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing the CDR arrays for each of the chains</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cdr(self, chains=None):
    &#34;&#34;&#34;Return CDR arrays.

    Parameters
    ----------
    chains : list, optional
        A list of chain identifiers (if not provided, all chains are processed)

    Returns
    -------
    cdrs : dict
        A dictionary containing the CDR arrays for each of the chains

    &#34;&#34;&#34;
    if chains is None:
        chains = self.chains()
    return {chain: self._get_chain_cdr(chain) for chain in chains}</code></pre>
</details>
</dd>
<dt id="proteinflow.data.SAbDabEntry.heavy_chain"><code class="name flex">
<span>def <span class="ident">heavy_chain</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the heavy chain identifier.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chain</code></strong> :&ensp;<code>str</code></dt>
<dd>The heavy chain identifier</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heavy_chain(self):
    &#34;&#34;&#34;Return the heavy chain identifier.

    Returns
    -------
    chain : str
        The heavy chain identifier

    &#34;&#34;&#34;
    return self.chain_dict[&#34;heavy&#34;]</code></pre>
</details>
</dd>
<dt id="proteinflow.data.SAbDabEntry.light_chain"><code class="name flex">
<span>def <span class="ident">light_chain</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the light chain identifier.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chain</code></strong> :&ensp;<code>str</code></dt>
<dd>The light chain identifier</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def light_chain(self):
    &#34;&#34;&#34;Return the light chain identifier.

    Returns
    -------
    chain : str
        The light chain identifier

    &#34;&#34;&#34;
    return self.chain_dict[&#34;light&#34;]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></b></code>:
<ul class="hlist">
<li><code><a title="proteinflow.data.PDBEntry.get_alignment" href="#proteinflow.data.PDBEntry.get_alignment">get_alignment</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_chains" href="#proteinflow.data.PDBEntry.get_chains">get_chains</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_coordinates_array" href="#proteinflow.data.PDBEntry.get_coordinates_array">get_coordinates_array</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_fasta" href="#proteinflow.data.PDBEntry.get_fasta">get_fasta</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_ligands" href="#proteinflow.data.PDBEntry.get_ligands">get_ligands</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_mask" href="#proteinflow.data.PDBEntry.get_mask">get_mask</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_pdb_df" href="#proteinflow.data.PDBEntry.get_pdb_df">get_pdb_df</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_sequence_df" href="#proteinflow.data.PDBEntry.get_sequence_df">get_sequence_df</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_unique_residue_numbers" href="#proteinflow.data.PDBEntry.get_unique_residue_numbers">get_unique_residue_numbers</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.has_unnatural_amino_acids" href="#proteinflow.data.PDBEntry.has_unnatural_amino_acids">has_unnatural_amino_acids</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.merge" href="#proteinflow.data.PDBEntry.merge">merge</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.parse_fasta" href="#proteinflow.data.PDBEntry.parse_fasta">parse_fasta</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.rename_chains" href="#proteinflow.data.PDBEntry.rename_chains">rename_chains</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.visualize" href="#proteinflow.data.PDBEntry.visualize">visualize</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://adaptyvbio.github.io/ProteinFlow/">
<img src="https://raw.githubusercontent.com/adaptyvbio/ProteinFlow/main/media/proteinflow_logo.png" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="proteinflow" href="../index.html">proteinflow</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="proteinflow.data.torch" href="torch.html">proteinflow.data.torch</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="proteinflow.data.interpolate_coords" href="#proteinflow.data.interpolate_coords">interpolate_coords</a></code></li>
<li><code><a title="proteinflow.data.lru_cache" href="#proteinflow.data.lru_cache">lru_cache</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="proteinflow.data.PDBEntry" href="#proteinflow.data.PDBEntry">PDBEntry</a></code></h4>
<ul class="">
<li><code><a title="proteinflow.data.PDBEntry.from_id" href="#proteinflow.data.PDBEntry.from_id">from_id</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_alignment" href="#proteinflow.data.PDBEntry.get_alignment">get_alignment</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_chains" href="#proteinflow.data.PDBEntry.get_chains">get_chains</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_coordinates_array" href="#proteinflow.data.PDBEntry.get_coordinates_array">get_coordinates_array</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_fasta" href="#proteinflow.data.PDBEntry.get_fasta">get_fasta</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_ligands" href="#proteinflow.data.PDBEntry.get_ligands">get_ligands</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_mask" href="#proteinflow.data.PDBEntry.get_mask">get_mask</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_pdb_df" href="#proteinflow.data.PDBEntry.get_pdb_df">get_pdb_df</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_sequence_df" href="#proteinflow.data.PDBEntry.get_sequence_df">get_sequence_df</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.get_unique_residue_numbers" href="#proteinflow.data.PDBEntry.get_unique_residue_numbers">get_unique_residue_numbers</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.has_unnatural_amino_acids" href="#proteinflow.data.PDBEntry.has_unnatural_amino_acids">has_unnatural_amino_acids</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.merge" href="#proteinflow.data.PDBEntry.merge">merge</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.parse_fasta" href="#proteinflow.data.PDBEntry.parse_fasta">parse_fasta</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.rename_chains" href="#proteinflow.data.PDBEntry.rename_chains">rename_chains</a></code></li>
<li><code><a title="proteinflow.data.PDBEntry.visualize" href="#proteinflow.data.PDBEntry.visualize">visualize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="proteinflow.data.ProteinEntry" href="#proteinflow.data.ProteinEntry">ProteinEntry</a></code></h4>
<ul class="">
<li><code><a title="proteinflow.data.ProteinEntry.ATOM_ORDER" href="#proteinflow.data.ProteinEntry.ATOM_ORDER">ATOM_ORDER</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.ablang_pll" href="#proteinflow.data.ProteinEntry.ablang_pll">ablang_pll</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.accuracy" href="#proteinflow.data.ProteinEntry.accuracy">accuracy</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.align_structure" href="#proteinflow.data.ProteinEntry.align_structure">align_structure</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.apply_mask" href="#proteinflow.data.ProteinEntry.apply_mask">apply_mask</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.blosum62_score" href="#proteinflow.data.ProteinEntry.blosum62_score">blosum62_score</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.ca_rmsd" href="#proteinflow.data.ProteinEntry.ca_rmsd">ca_rmsd</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.chemical_features" href="#proteinflow.data.ProteinEntry.chemical_features">chemical_features</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.combine_multiple_frames" href="#proteinflow.data.ProteinEntry.combine_multiple_frames">combine_multiple_frames</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.cut_missing_edges" href="#proteinflow.data.ProteinEntry.cut_missing_edges">cut_missing_edges</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.decode_cdr" href="#proteinflow.data.ProteinEntry.decode_cdr">decode_cdr</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.decode_sequence" href="#proteinflow.data.ProteinEntry.decode_sequence">decode_sequence</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.dihedral_angles" href="#proteinflow.data.ProteinEntry.dihedral_angles">dihedral_angles</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.esm_pll" href="#proteinflow.data.ProteinEntry.esm_pll">esm_pll</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.esmfold_metrics" href="#proteinflow.data.ProteinEntry.esmfold_metrics">esmfold_metrics</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.from_arrays" href="#proteinflow.data.ProteinEntry.from_arrays">from_arrays</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.from_dict" href="#proteinflow.data.ProteinEntry.from_dict">from_dict</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.from_id" href="#proteinflow.data.ProteinEntry.from_id">from_id</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.from_pdb" href="#proteinflow.data.ProteinEntry.from_pdb">from_pdb</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.from_pdb_entry" href="#proteinflow.data.ProteinEntry.from_pdb_entry">from_pdb_entry</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.from_pickle" href="#proteinflow.data.ProteinEntry.from_pickle">from_pickle</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_atom_mask" href="#proteinflow.data.ProteinEntry.get_atom_mask">get_atom_mask</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_cdr" href="#proteinflow.data.ProteinEntry.get_cdr">get_cdr</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_cdr_length" href="#proteinflow.data.ProteinEntry.get_cdr_length">get_cdr_length</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_chain_id_array" href="#proteinflow.data.ProteinEntry.get_chain_id_array">get_chain_id_array</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_chain_id_dict" href="#proteinflow.data.ProteinEntry.get_chain_id_dict">get_chain_id_dict</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_chain_type_dict" href="#proteinflow.data.ProteinEntry.get_chain_type_dict">get_chain_type_dict</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_chains" href="#proteinflow.data.ProteinEntry.get_chains">get_chains</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_coordinates" href="#proteinflow.data.ProteinEntry.get_coordinates">get_coordinates</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_id" href="#proteinflow.data.ProteinEntry.get_id">get_id</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_index_array" href="#proteinflow.data.ProteinEntry.get_index_array">get_index_array</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_length" href="#proteinflow.data.ProteinEntry.get_length">get_length</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_ligand_features" href="#proteinflow.data.ProteinEntry.get_ligand_features">get_ligand_features</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_mask" href="#proteinflow.data.ProteinEntry.get_mask">get_mask</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_predict_mask" href="#proteinflow.data.ProteinEntry.get_predict_mask">get_predict_mask</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_predicted_chains" href="#proteinflow.data.ProteinEntry.get_predicted_chains">get_predicted_chains</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_predicted_entry" href="#proteinflow.data.ProteinEntry.get_predicted_entry">get_predicted_entry</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.get_sequence" href="#proteinflow.data.ProteinEntry.get_sequence">get_sequence</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.has_cdr" href="#proteinflow.data.ProteinEntry.has_cdr">has_cdr</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.has_predict_mask" href="#proteinflow.data.ProteinEntry.has_predict_mask">has_predict_mask</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.igfold_metrics" href="#proteinflow.data.ProteinEntry.igfold_metrics">igfold_metrics</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.immunebuilder_metrics" href="#proteinflow.data.ProteinEntry.immunebuilder_metrics">immunebuilder_metrics</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.interpolate_coords" href="#proteinflow.data.ProteinEntry.interpolate_coords">interpolate_coords</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.is_valid_pair" href="#proteinflow.data.ProteinEntry.is_valid_pair">is_valid_pair</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.long_repeat_num" href="#proteinflow.data.ProteinEntry.long_repeat_num">long_repeat_num</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.merge" href="#proteinflow.data.ProteinEntry.merge">merge</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.rename_chains" href="#proteinflow.data.ProteinEntry.rename_chains">rename_chains</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.retrieve_ligands_from_pickle" href="#proteinflow.data.ProteinEntry.retrieve_ligands_from_pickle">retrieve_ligands_from_pickle</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.secondary_structure" href="#proteinflow.data.ProteinEntry.secondary_structure">secondary_structure</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.set_predict_mask" href="#proteinflow.data.ProteinEntry.set_predict_mask">set_predict_mask</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.sidechain_coordinates" href="#proteinflow.data.ProteinEntry.sidechain_coordinates">sidechain_coordinates</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.sidechain_orientation" href="#proteinflow.data.ProteinEntry.sidechain_orientation">sidechain_orientation</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.tm_score" href="#proteinflow.data.ProteinEntry.tm_score">tm_score</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.to_dict" href="#proteinflow.data.ProteinEntry.to_dict">to_dict</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.to_pdb" href="#proteinflow.data.ProteinEntry.to_pdb">to_pdb</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.to_pickle" href="#proteinflow.data.ProteinEntry.to_pickle">to_pickle</a></code></li>
<li><code><a title="proteinflow.data.ProteinEntry.visualize" href="#proteinflow.data.ProteinEntry.visualize">visualize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="proteinflow.data.SAbDabEntry" href="#proteinflow.data.SAbDabEntry">SAbDabEntry</a></code></h4>
<ul class="two-column">
<li><code><a title="proteinflow.data.SAbDabEntry.antigen_chains" href="#proteinflow.data.SAbDabEntry.antigen_chains">antigen_chains</a></code></li>
<li><code><a title="proteinflow.data.SAbDabEntry.chain_type" href="#proteinflow.data.SAbDabEntry.chain_type">chain_type</a></code></li>
<li><code><a title="proteinflow.data.SAbDabEntry.chains" href="#proteinflow.data.SAbDabEntry.chains">chains</a></code></li>
<li><code><a title="proteinflow.data.SAbDabEntry.from_id" href="#proteinflow.data.SAbDabEntry.from_id">from_id</a></code></li>
<li><code><a title="proteinflow.data.SAbDabEntry.get_cdr" href="#proteinflow.data.SAbDabEntry.get_cdr">get_cdr</a></code></li>
<li><code><a title="proteinflow.data.SAbDabEntry.heavy_chain" href="#proteinflow.data.SAbDabEntry.heavy_chain">heavy_chain</a></code></li>
<li><code><a title="proteinflow.data.SAbDabEntry.light_chain" href="#proteinflow.data.SAbDabEntry.light_chain">light_chain</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>